---
title: "13.Diversity_calculation_contemporary_data"
output: html_document
---

En este script voy a hacer los análisis de diversidad para las poblaciones contemporaneas. 

Ahora tengo que descargarme todos los archivos de cada población y despues hacer un super-join para cada población para acabar haciendo una unica tabla con rbind con todas las poblaciones. 

# Creación tablas

```{r}

# https://github.com/MTFA/CohortEx/wiki/Run-rJava-with-RStudio-under-OSX-10.10,-10.11-(El-Capitan)-or-10.12-(Sierra)

# Ahora hago un join de la tabla principal de diversidad con las de telómeros, centrómeros y cromosoma. 

library(dplyr)
library(ggplot2)
library(tidyr)

wd_in <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/raw_tables/"
wd_out <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_recom <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/recombination"
wd_diver <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/divergence"

# Ojo! antes de correr esto, asegurarme que no lo he corrido antes porque si no estoy haciendo append a las tablas viejas y no creando nuevas. --> YA NO PASA ESTO PQ LO TENGO EN CARPETAS DISTINTAS!!!!

poplist <- c("c_ll_ki_n013", "c_ll_po_n008","c_ll_no_n008","c_lp_sm_n019", "c_lp_do_n012")

  
for (pop in poplist)
{
  if (exists("dataset"))
  {rm (dataset)
  }
  
  files_for_given_pop <- list.files(path = wd_in, pattern = pop)
  
  for (file_for_given_pop in files_for_given_pop)
  {
    # if the merged dataset doesn't exist, create it
    if (!exists("dataset"))
    {
      dataset <- read.table(paste(wd_in,file_for_given_pop, sep=""), header=TRUE, sep="\t") 
    }
    
    # if the merged dataset does exist, append to it
    if (exists("dataset"))
    {
      temp_dataset <-read.table(paste(wd_in,file_for_given_pop, sep=""), header=TRUE, sep="\t", na.strings = c("NA", "na"))
      dataset<-full_join(dataset, temp_dataset, by = c("scaffold", "start_cero_based", "end", "length", "NAs", "informative_sites", "feature", "strandness", "frame", "id_gene", "id", "watterson_ave", "watterson_sd", "pairwise_ave", "pairwise_sd", "tajimaD", "pop", "specie", "epoch"))   
      rm(temp_dataset)
      assign(pop, dataset) # Con esto quiero ponerle el nombre de la población a la dataframe. 
    }
  }    
}



rm(dataset)



data_diversity_raw <-rbind(c_ll_ki_n013,c_ll_po_n008,c_ll_no_n008,c_lp_sm_n019,c_lp_do_n012) %>% 
    mutate( watterson_ave = as.numeric(gsub("\\*10\\^","e",watterson_ave)),
            watterson_sd = as.numeric(gsub("\\*10\\^","e",watterson_sd)),
            pairwise_ave  = as.numeric(gsub("\\*10\\^","e",pairwise_ave)),
            pairwise_sd  = as.numeric(gsub("\\*10\\^","e",pairwise_sd)),
            tajimaD = as.numeric(gsub("\\*10\\^","e",tajimaD)))


# write.table (data_diversity_raw, paste(wd_out, "global.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_ki_n013, paste(wd_out, "c_ll_ki_n013.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_ki_n008, paste(wd_out, "c_ll_ki_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_no_n008, paste(wd_out, "c_ll_no_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_po_n008, paste(wd_out, "c_ll_po_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_lp_do_n012, paste(wd_out, "c_ll_do_n012.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_lp_sm_n019, paste(wd_out, "c_ll_sm_n019.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
#write.table (c_lp_sm_n012, paste(wd_out, "c_ll_sm_n012.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
```

## Cargar tablas y filtrarlas. 


```{r}

library(dplyr)
library(ggplot2)
library(tidyr)

wd_in <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/raw_tables/"
wd_out <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_recom <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/recombination"
wd_diver <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/divergence"


# data_diversity <- data_diversity_raw 
# En teoría debería de funcionar llamando a la tabla anterior, pero como no funciona no le doy más vueltas. Me he descargado la raw y la he vuelto a cargar, que así funcionaba antes, y así ha funcionado ahora. 

data_diversity <- read.table(paste(wd_out, "global.per.unit.averages.chr.all.regions.tsv", sep=""), header=T, na.strings = c("NA", "na")) %>%  
  replace(., is.na(.), "0") %>%  # Para que pueda calcular cuando es mayor o menor que 75%; si es NA no lo reconoce. 
  mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "Bialowieza",
                            ifelse (pop == "c_ll_ki_n013", "Kirov", 
                            ifelse (pop == "c_ll_no_n008", "Norway", 
                            ifelse (pop == "c_lp_sm_n019", "Andujar",  
                            ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
  mutate (., Species =ifelse (specie=="ll", "L.lynx", 
                   ifelse (specie=="lp", "L.pardinus", NA))) %>% 
  # Anoto qué es cada región 
  mutate (., region = ifelse (tel2m_percentage >= 0.75, "Telomere_2m", 
                       ifelse (centr_percentage >= 0.75, "Centromere", "Arm" )))  %>% 
  # Ahora elimino la barra baja que encuentro en algunos de los lncRNA
  #mutate(new_id=ifelse(feature=="lncRNA", substr(.$id_gene,start=1,stop=13), as.character(id_gene))) %>% 
  #select(-id_gene) %>% 
  #dplyr::rename(id_gene = new_id) %>% 
  # Creo un identificador único para luego poder filtrar por este cuando tenga que sacar los comunes a todas las poblaciones. 
  mutate (., chr = ifelse (chr.x == chr.y, as.character(chr.x), "PROBLEMA")) %>% 
  select (-c(chr.x, chr.y)) %>% 
  mutate (., unique_id = paste (id,feature, sep="_")) %>% 
  #Haciendo este mutate lo que hago es modificar el valor de watterson para tener en ucenta el tamaño poblacional verdadero de la población (chr) cuando consideramos la diferencia entre machos y hembras. En el xls modif_a_watterson_chrX viene explicado. 
  mutate (., watterson_modif = ifelse (chr=="chrX" & pop == "c_ll_ki_n013", watterson_ave * 1.09, 
                               ifelse (chr=="chrX" & pop == "c_ll_po_n008", watterson_ave * 1.12,
                               ifelse (chr=="chrX" & pop == "c_ll_no_n008", watterson_ave * 1.15,
                               ifelse (chr=="chrX" & pop == "c_lp_sm_n019", watterson_ave * 1.07, 
                               ifelse (chr=="chrX" & pop == "c_lp_do_n012", watterson_ave * 1.10, watterson_ave)))))) %>% 
  select (., -watterson_ave) %>% 
  dplyr::rename(watterson_ave = watterson_modif) %>% 
  dplyr::rowwise() %>%
 # los promotores de los lncRNA siguen llamandose igual, y ojo que están sacados de la notación de los propios lncrNA pero sin tener en cuenta los distintos transcritos. 
  dplyr::mutate(new_id = ifelse ( feature=="lncRNA" | feature =="intron_lncRNA",substr(as.character(id_gene), start = 1, stop = 13),as.character(id_gene))) %>% 
  select (.,-id_gene) %>% 
  dplyr::rename(id_gene = new_id)
                                     

#View(data_diversity)
#unique(data_diversity$pop)
#unique(data_diversity$Populations)

#¡Ojo! el filtro que estás aplicando se está quedando con las que para la Tajima son NA. Si las quieres eliminar ¡ojo!
# 2248581

# Compruebo que efectivamente no hay ningún cromosoma que no encaje. 
# unique(data_diversity$chr)
# Está bien!


# Sanity checks de que no hay duplicados:
# filter (data_diversity, pop=="c_ll_ki_n013") %>% nrow
# 450064
# filter (data_diversity, pop=="c_ll_ki_n013") %>% select(id_feature) %>% unique() %>% nrow
# 450064

# Ojo los lncRNA tienen más de un trasncrito, así que hay que eliminarlo. 
# En primer lugar vamos a sacar una lista para que luego la podamos filtrar. 


all_lncRNA <- data_diversity %>% ungroup(.) %>% dplyr::filter (pop=="c_ll_ki_n013") %>%  dplyr::filter (feature=="lncRNA"| feature=="intron_lncRNA" ) %>% mutate(id2=id) %>% separate (id2,c("a", "b", "c", "d", "e"), "_", extra = "drop") %>% mutate(new_id=paste(c,d, sep="_")) %>% select (-c(a,b,c,d,e)) 

# Selecciono todos los que tienen más de un transcrito.
all_lncRNA_sum_lenght_repeted <- all_lncRNA %>% as.data.frame(.) %>% dplyr::group_by (id_gene, new_id) %>% dplyr::summarise (sum_length = sum(length)) %>% dplyr::group_by(id_gene) %>% dplyr::filter(n()>1)

# Me quedo con el más largo, y añado la información que se pierde al hacer el resumen de la identidad del transcrito. 
all_lncRNA_sum_lenght_repeted_large_length <- all_lncRNA_sum_lenght_repeted %>% dplyr::summarise(sum_length = max(sum_length))  %>%  dplyr::inner_join(., all_lncRNA_sum_lenght_repeted, by=c("id_gene", "sum_length"))

# Elimino duplicados en caso de que haya más de un transcrito con la misma longitud, quedandome con uno al azar--> Esta tabla sería la buena, con la que me tengo que quedar, asi que hago antijoin para lograr lo que tengo que tirar. 
all_lncRNA_sum_lenght_repeted_large_length_no_duplicates <- all_lncRNA_sum_lenght_repeted_large_length[!duplicated(all_lncRNA_sum_lenght_repeted_large_length$id_gene),]

# Selecciono el id de todos estos.
all_lncRNA_sum_lenght_repeted_large_length_no_duplicates_unique_id  <- dplyr::anti_join(all_lncRNA, all_lncRNA_sum_lenght_repeted_large_length_no_duplicates, by=c("id_gene", "new_id")) %>% dplyr::select("unique_id")


data_diversity_pre <- data_diversity %>% ungroup(.) %>%  
  dplyr::anti_join(all_lncRNA_sum_lenght_repeted_large_length_no_duplicates_unique_id,by="unique_id") %>% 
  dplyr::filter (., informative_sites>=50) %>% 
  dplyr::filter (., informative_sites/length>=0.20) %>% 
  dplyr::filter (., !(feature=="promoter_gene_250")) %>% 
  dplyr::filter (., !(feature=="promoter_gene_500")) %>% 
  dplyr::filter (., !(feature=="promoter_gene_1000" & length < 1000)) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_250")) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_500")) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_1000" & length < 1000)) 


# Sanity check de que nada con las mismas coordenadas y con las misma longitud y strandness y frame se va a contar doble, pq no debería. 
# kk1 <- data_diversity_pre %>% mutate (position=paste(scaffold,start_cero_based,end, length, feature, strandness, frame, id_gene)) 
# kk2 <- as.data.frame(table (kk3$position)) %>% filter(Freq>5)



# Saco la lista de elementos comunes a todas las unidades para cada especie. 

# Primero par lynx lynx:

data_diversity_pre_ki <- data_diversity_pre %>% filter (pop=="c_ll_ki_n013")
data_diversity_pre_no <- data_diversity_pre %>% filter (pop=="c_ll_no_n008")
data_diversity_pre_po <- data_diversity_pre %>% filter (pop=="c_ll_po_n008")


lista_lynxlynx <- dplyr::inner_join(data_diversity_pre_ki, data_diversity_pre_no, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id")) %>% dplyr::inner_join(., data_diversity_pre_po, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id" ))  %>% select("unique_id")

data_diversity_filtered_lynxlynx <- data_diversity_pre %>% dplyr::filter (specie=="ll") %>% dplyr::filter(unique_id %in% lista_lynxlynx$unique_id)

# Ahora para pardinus:

data_diversity_pre_sm <- data_diversity_pre %>% dplyr::filter (pop=="c_lp_sm_n019")
data_diversity_pre_do <- data_diversity_pre %>% dplyr::filter (pop=="c_lp_do_n012")

lista_lynxpardinus <- dplyr::inner_join( data_diversity_pre_sm, data_diversity_pre_do, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id")) %>% dplyr::select("unique_id")

data_diversity_filtered_lynxpardinus <- data_diversity_pre %>% dplyr::filter (specie=="lp") %>% dplyr::filter(unique_id %in% lista_lynxpardinus$unique_id)

# Con los filtrados hemos perdido 251.736 unidades. Aqui entran los promotores que se han caido. 


####### Adjunto tasa de divergencia #########

divergence_per_unit_lynx_lynx <- read.table(paste(wd_diver, "/c_ll_ki_0090_plus_c_lr_zz_0001_recal_round-1_25x_SNPs.divergence.tsv", sep=""), header=T, fill = TRUE) %>% rename("informative_sites_substitutions"="informative_sites") %>% rename("unique_id"="id_gene")
# empty_divergence_per_unit_lynx_lynx <- subset(divergence_per_unit_lynx_lynx, is.na(divergence_per_unit_lynx_lynx$divergence))
# rm(empty_divergence_per_unit_lynx_lynx)

divergence_per_unit_lynx_pardinus <- read.table(paste(wd_diver, "/c_lp_sm_0298_plus_c_lr_zz_0001_recal_round-1_25x_SNPs.divergence.tsv", sep=""), header=T, fill = TRUE) %>% rename("informative_sites_substitutions"="informative_sites") %>% rename("unique_id"="id_gene")
# empty_divergence_per_unit_lynx_pardinus <- subset(divergence_per_unit_lynx_pardinus, is.na(divergence_per_unit_lynx_pardinus$divergence))
# rm(empty_divergence_per_unit_lynx_pardinus)


data_diversity_filtered_lynxlynx_divergence <- data_diversity_filtered_lynxlynx %>% dplyr::left_join (., divergence_per_unit_lynx_lynx)
data_diversity_filtered_lynxpardinus_divergence <- data_diversity_filtered_lynxpardinus %>%  dplyr::left_join (., divergence_per_unit_lynx_pardinus)


####### Adjunto tasa de recombinación #########

# Ahora adjunto los datos de recombinación. 

recombination_per_unit <- read.table(paste(wd_recom, "/recombination_rate_per_unit_all_info_sorted_filtered_uniq.bed", sep=""), header=F, na.strings = c("NA", "na"))
colnames(recombination_per_unit) <- c("unique_id","recombination_rate")
recombination_per_unit$unique_id <- as.factor(recombination_per_unit$unique_id)


data_diversity_filtered <- rbind(data_diversity_filtered_lynxlynx_divergence, data_diversity_filtered_lynxpardinus_divergence) %>% left_join (., recombination_per_unit, by = "unique_id")   



# Ordenar los factores. 

data_diversity_filtered$Populations <- factor (data_diversity_filtered$Populations, levels=c("Kirov","Kirov_subsampled","Bialowieza","Norway", "Andujar","Donana"))

data_diversity_filtered$chr <- factor(data_diversity_filtered$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrC2","chrB2","chrB3","chrB4","chrA3","chrD1","chrD3","chrD4","chrD2","chrF2","chrF1","chrE2","chrE1","chrX"))

data_diversity_filtered$watterson_ave <- as.numeric(data_diversity_filtered$watterson_ave)
data_diversity_filtered$watterson_sd <- as.numeric(data_diversity_filtered$watterson_sd)
data_diversity_filtered$pairwise_ave <- as.numeric(data_diversity_filtered$pairwise_ave)
data_diversity_filtered$pairwise_sd <- as.numeric(data_diversity_filtered$pairwise_sd)
data_diversity_filtered$tajimaD <- as.numeric(data_diversity_filtered$tajimaD)

write.table (data_diversity_filtered, paste(wd_out, "global.per.unit.averages.chr.all.regions.filtered.watterson.modif.chrX.tsv", sep=""), row.names = F, quote = F, sep = '\t')

# 5/6/2018
# Hemos decidido filtrar el 20% de sitios informativos/length.
# También que tengan un mínimo de 50 sitios informativos. 
# Por último tamibén quitamos los promotores que tengan menos del tamaño esperado. 
## Aquí abajo están todas las pruebecillas que he ido haciendo para al final quedarnos con los filtro que explicamos arriba. 

# Voy a nombrar como telómero 10m, 2m o centr lo que tenga más de 75% de bases como tal. 
# Ojo que : Todo lo que tiene bases como tel2m está contenido en 10m, pero por supuesto no todo lo que está en 2m está en 10m . 
# 21/06/2018 --> Despues de pensarlo, y hacer gráficas que comparaban tel 0-10 con tel 0-2 me voy a quedar solo con tel2.  
#
# uu <- filter (data_diversity, data_diversity$tel10m_percentage!=data_diversity$tel2m_percentage)

# # Porcentaje de telomericas.
# ggplot (data = data_diversity, aes(tel10m_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# 
# ggplot (data = data_diversity, aes(data_diversity$tel2m_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# ggplot (data = data_diversity, aes(data_diversity$centr_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# Para cada una de las unidades voy comprobando
# ggplot (data = filter (data_diversity,data_diversity$feature=="CDS" & data_diversity$length<2000), aes(informative_sites)) +
#   geom_histogram(bins=500) 
# ggplot (data = filter(data_diversity, data_diversity$feature=="CDS"), aes(x=informative_sites, y=length)) +
#   geom_point()
# ggplot (data = filter (data_diversity,data_diversity$feature=="intergenic"), aes(length)) +
#   geom_histogram(bins=1000)
# ggplot (data = filter (data_diversity,data_diversity$feature=="intron" & data_diversity$length<150000), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="5UTR"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="3UTR"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="lncRNA"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="ncRNA "), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="UCNE"), aes(length)) +
#   geom_histogram(bins=1000) 
### Otros sanity checks

# SANITY CHECKS:

# lncRNA <- data_diversity %>% filter (feature=="lncRNA")
# 55885 observaciones

# ggplot(lncRNA, aes(x=length))+
#   geom_histogram(bins = 2000) +
#  coord_cartesian(xlim=c(0, 3000))

# sncRNA <- data_diversity %>% filter (feature=="ncRNA")
# 21043 observaciones

# ggplot(sncRNA, aes(x=length))+
#   geom_histogram(bins = 2000) +
#  coord_cartesian(xlim=c(0, 3000))

# ncRNA <- inner_join(lncRNA, sncRNA, by = c("scaffold", "start_cero_based", "end", "length")) %>%  select ("scaffold", "start_cero_based", "end","feature.x","id_gene.x", "id.x", "feature.y","id_gene.y", "id.y" ) %>% unique
# Son 14 los que coinciden. 

# Algunas notas sobre los lncRNA y ncRNA
# Infernal ("INFERence of RNA ALignment") is for searching DNA sequence databases for RNA structure and sequence similarities. It is an implementation of a special case of profile stochastic context-free grammars called covariance models (CMs). A CM is like a sequence profile, but it scores a combination of sequence consensus and RNA secondary structure consensus, so in many cases, it is more capable of identifying RNA homologs that conserve their secondary structure more than their primary sequence.

# En su momento:
# He sacado graficas para tel2m y telomero de 0 a 10m y hemos decidido quedarnos con tel2m.

# Borro las que no necesito luego

rm (data_diversity_pre_sm)
rm (data_diversity_pre_do)
rm (data_diversity_pre_ki)
rm (data_diversity_pre_po)
rm (data_diversity_pre_no)
rm (data_diversity)
rm (data_diversity_filtered_lynxlynx)
rm (data_diversity_filtered_lynxpardinus)
rm (data_diversity_pre)
rm (lista_lynxlynx)
rm (lista_lynxpardinus)
rm (c_ll_ki_n013)
rm (c_ll_no_n008)
rm (c_ll_po_n008)
rm (c_lp_do_n012)
rm (c_lp_sm_n019)

```

# -------------------------------------------------

# Analisis de la diversidad

```{r}

library(dplyr)
library(ggplot2)
library(tidyr)
library(plyr)



wd <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/"

data_diversity_filtered <- read.table(paste(wd, "global.per.unit.averages.chr.all.regions.filtered.watterson.modif.chrX.tsv", sep=""), header=T, na.strings = c("NA", "na"))


# str(data_diversity_filtered)



# Tamaño de las unidades

ggplot (data = data_diversity_filtered, aes(length)) +
  geom_histogram() +
  facet_wrap (~feature, scales = "free")
ggsave(paste (wd_output, "length_per_unit_all_pops.pdf", sep=""))


for (pop in unique(data_diversity_filtered$Populations))
  {
  
  print (pop)
  ggplot (data=dplyr::filter(data_diversity_filtered,data_diversity_filtered$Populations==!!pop), aes(length)) +
  geom_histogram() +
  facet_wrap (~feature, scales = "free") 
  ggsave(paste (wd_output, "length_per_unit_",pop,".pdf", sep="" ), device="pdf")

  }
 
```


## Feature per chr

```{r}

cuentas_perfeature_per_chr <- data_diversity_filtered %>% mutate (autosome_chrX = ifelse(chr=="chrX", "chrX" , ifelse(chr=="chrA1" | chr=="chrC1" | chr=="chrB1" | chr=="chrA2" | chr=="chrC2" | chr=="chrB2" | chr=="chrB3" | chr=="chrB4" | chr=="chrA3" | chr=="chrD1" | chr=="chrD3" | chr=="chrD4" | chr=="chrD2" | chr=="chrF2" | chr=="chrF1" | chr=="chrE2" | chr=="chrE1", "autosome", NA))) %>% dplyr::group_by(feature, autosome_chrX) %>% dplyr::summarise(total_count=n()) 

write.csv(cuentas_perfeature_per_chr, paste (wd_output, "counts_autosome_vs_chrX.csv", sep="" ), quote = F, row.names = F)

```


## Autosomes vs chrX

A partir de ahora debería separar todo el rato cromosomas chrXes de no chrXes. 

```{r}

# Consideramos como autosomicas todas aquellas posiciones que no estén en un cromosoma chrX.

data_diversity_filtered_autosomes <- data_diversity_filtered %>% filter (chr!="chrX") %>% mutate (type_chr="autosomes") 
data_diversity_filtered_chrX <- data_diversity_filtered %>% filter (chr=="chrX") %>% mutate (type_chr="chrX") 

data_diversity_filtered_autosomes$Populations <- factor (data_diversity_filtered_autosomes$Populations, levels=c("Kirov","Bialowieza","Norway", "Andujar","Donana"))
data_diversity_filtered_chrX$Populations <- factor (data_diversity_filtered_chrX$Populations, levels=c("Kirov","Bialowieza","Norway", "Andujar","Donana"))




data_diversity_filtered_autosomes$feature <- plyr::revalue(data_diversity_filtered_autosomes$feature, c("intergenic"="Intergenic", "promoter_gene_1000"="Gen_promoter", "5UTR"="5UTR", "CDS"="CDS", "intron"="Intron", "3UTR"="3UTR", "promoter_lncRNA_1000"="lncRNA_promoter", "lncRNA"="lncRNA_exons", "intron_lncRNA"="lncRNA_intron", "ncRNA"="ncRNA", "UCNE"="UCNE"))

data_diversity_filtered_chrX$feature <- plyr::revalue(data_diversity_filtered_chrX$feature, c("intergenic"="Intergenic", "promoter_gene_1000"="Gen_promoter", "5UTR"="5UTR", "CDS"="CDS", "intron"="Intron", "3UTR"="3UTR", "promoter_lncRNA_1000"="lncRNA_promoter", "lncRNA"="lncRNA_exons", "intron_lncRNA"="lncRNA_intron", "ncRNA"="ncRNA", "UCNE"="UCNE"))


data_diversity_filtered_autosomes$feature <- factor (data_diversity_filtered_autosomes$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))

data_diversity_filtered_chrX$feature <- factor (data_diversity_filtered_chrX$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))



```



## Corrected with intergenic

Corrijo los valores individuales para la media de intergénico

Los datos para qcada poblacion van a tener el mismo dibujo, pero en los ratios si afecta.

```{r}

# Primero calculo los valores para intergénico para poder corregir por ellos, de media y mediana, pero voy a usar media para corregir.

autosomes_intergenic_average_values <- data_diversity_filtered_autosomes  %>% filter (feature=="Intergenic") %>% dplyr::group_by(pop) %>%
             dplyr::summarise(
                       total_count=n(), 
                       mean_watterson_ave_intergenic=mean(watterson_ave),
                       mean_pairwise_ave_intergenic=mean(pairwise_ave),

                       median_watterson_ave_intergenic=median(watterson_ave),
                       median_pairwise_ave_intergenic=median(pairwise_ave))

  
    
chrX_intergenic_average_values <- data_diversity_filtered_chrX  %>% filter (feature=="Intergenic") %>% dplyr::group_by(pop) %>%
             dplyr::summarise(
                       total_count=n(), 
                       mean_watterson_ave_intergenic=mean(watterson_ave),
                       mean_pairwise_ave_intergenic=mean(pairwise_ave),

                       median_watterson_ave_intergenic=median(watterson_ave),
                       median_pairwise_ave_intergenic=median(pairwise_ave))
  
  
# Saco las tablas para cada población y añado una columna en la que corrijo por la media de pairwise, per unit. 
# Los valores calculados, también me servirán a posteriori para calcular la mediana corregida. 


POPS=c("c_ll_ki_n013","c_ll_no_n008","c_ll_po_n008", "c_lp_sm_n019","c_lp_do_n012")

for (POP in POPS)
{
  print (POP)

  # 1.- Media de intergénico por poblacion.
  
  ## autosomes
  
  autosomes_pairwise_average_intergenic_per_unit <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP)) %>% select (mean_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP)) %>% select (mean_watterson_ave_intergenic))
  

   dataframe_autosomes <-  data_diversity_filtered_autosomes %>%  filter (pop==as.character(POP)) %>% 
  mutate(pairwise_ave_corrected = pairwise_ave/autosomes_pairwise_average_intergenic_per_unit) %>%  
  mutate(watterson_ave_corrected= watterson_ave/autosomes_watterson_average_intergenic_per_unit) #%>% 
  # mutate(corrected_by_pairwise_average_intergenic_weighted = pairwise_ave/pairwise_average_intergenic_weighted) %>%  
  # mutate(corrected_by_watterson_average_intergenic_weighted = watterson_ave/watterson_average_intergenic_weighted)
  
  
  assign(paste(POP,"_autosomes_diversity_pre", sep=""), dataframe_autosomes)
  rm (dataframe_autosomes)
  
  
  ## chrX

  chrX_pairwise_average_intergenic_per_unit <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP)) %>% select (mean_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP)) %>% select (mean_watterson_ave_intergenic))
  

   dataframe_chrX <-  data_diversity_filtered_chrX %>%  filter (pop==as.character(POP)) %>% 
  mutate(pairwise_ave_corrected = pairwise_ave/chrX_pairwise_average_intergenic_per_unit) %>%  
  mutate(watterson_ave_corrected = watterson_ave/chrX_watterson_average_intergenic_per_unit) #%>% 
  # mutate(corrected_by_pairwise_average_intergenic_weighted = pairwise_ave/pairwise_average_intergenic_weighted) %>%  
  # mutate(corrected_by_watterson_average_intergenic_weighted = watterson_ave/watterson_average_intergenic_weighted)
  
  
  assign(paste(POP,"_chrX_diversity_pre", sep=""), dataframe_chrX)
  rm (dataframe_chrX)
}

```


## Recombination categories

```{r}

# Primero hacemos un plot para ver la distribución de los valores, cogemos por ejemplo la población de kirov.

ggplot(filter(c_ll_ki_n013_autosomes_diversity_pre), aes(x=recombination_rate)) + 
  geom_histogram(binwidth=1, color="black", fill="white") +
  ggsave(paste (wd_output, "historgram_recombination_rate.pdf", sep=""))


# Viendo el gráfico, las categorías que hago son:

# <=3 
# >3 a <=7
# >7 a <=10
# >10 a <=20
# >20


DATAFRAMES=c("c_ll_ki_n013_autosomes_diversity_pre", "c_ll_no_n008_autosomes_diversity_pre", "c_ll_po_n008_autosomes_diversity_pre", "c_lp_sm_n019_autosomes_diversity_pre","c_lp_do_n012_autosomes_diversity_pre", "c_ll_ki_n013_chrX_diversity_pre", "c_ll_no_n008_chrX_diversity_pre", "c_ll_po_n008_chrX_diversity_pre", "c_lp_sm_n019_chrX_diversity_pre", "c_lp_do_n012_chrX_diversity_pre")


    for (DATAFRAME in DATAFRAMES)
      
    {
      

tabla_data_temporal_diversity_pre  <- get(DATAFRAME) %>% 
  mutate (recombination_category = ifelse (recombination_rate <=1, "<=1",
                                   ifelse (recombination_rate <=2, "<=2",
                                   ifelse (recombination_rate <= 3, "<=3", 
                                   ifelse (recombination_rate <=7, "<=7",
                                   ifelse (recombination_rate > 7, ">7", NA))))))

# & recombination_rate <=10, ">7&<=10",
#  ifelse (recombination_rate > 10 & recombination_rate <=20,  ">10&<=20",
#  ifelse (recombination_rate > 20, ">20", NA))))))


POP=as.character(get(DATAFRAME) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1])     
TYPE_OF_DATA=as.character(get(DATAFRAME) %>% select (type_chr) %>% mutate(type_chr=as.character(type_chr)) %>% .[1,1])

tabla_data_temporal_diversity_pre$recombination_category <- factor(tabla_data_temporal_diversity_pre$recombination_category,levels=c("<=0.5", "<=1", "<=2", "<=3",">3&<=7", ">7", ">7&<=10",">10&<=20",">20"))

tabla_data_temporal_diversity_pre_name <- paste (POP,TYPE_OF_DATA, "diversity", sep="_")
assign (tabla_data_temporal_diversity_pre_name, tabla_data_temporal_diversity_pre,.GlobalEnv)  
    
    }


```

# Fusiono tablas

```{r}

c_ll_ki_n013_diversity <- rbind (c_ll_ki_n013_autosomes_diversity, c_ll_ki_n013_chrX_diversity )
c_ll_no_n008_diversity <- rbind (c_ll_no_n008_autosomes_diversity, c_ll_no_n008_chrX_diversity )
c_ll_po_n008_diversity <- rbind (c_ll_po_n008_autosomes_diversity, c_ll_po_n008_chrX_diversity )
c_lp_sm_n019_diversity <- rbind (c_lp_sm_n019_autosomes_diversity, c_lp_sm_n019_chrX_diversity )
c_lp_do_n012_diversity <- rbind (c_lp_do_n012_autosomes_diversity, c_lp_do_n012_chrX_diversity )


# Hago una tabla con la media para cada grupo y para cada población. 

data_diversity_autosomes_filtered_ave_corrected <- rbind (c_ll_ki_n013_autosomes_diversity, c_ll_no_n008_autosomes_diversity, c_ll_po_n008_autosomes_diversity,  c_lp_sm_n019_autosomes_diversity, c_lp_do_n012_autosomes_diversity)

data_diversity_chrX_filtered_ave_corrected <- rbind (c_ll_ki_n013_chrX_diversity, c_ll_no_n008_chrX_diversity, c_ll_po_n008_chrX_diversity,  c_lp_sm_n019_chrX_diversity, c_lp_do_n012_chrX_diversity)

data_diversity_filtered_ave_corrected <- rbind (data_diversity_autosomes_filtered_ave_corrected, data_diversity_chrX_filtered_ave_corrected)


# rm (data_diversity_filtered)
# rm (data_diversity_filtered_autosomes)
# rm (data_diversity_filtered_chrX)
# rm (c_ll_ki_n013_autosomes_diversity_pre)
# rm (c_ll_no_n008_autosomes_diversity_pre) 
# rm (c_ll_po_n008_autosomes_diversity_pre)
# rm (c_lp_sm_n019_autosomes_diversity_pre) 
# rm (c_lp_do_n012_autosomes_diversity_pre)
# rm (c_ll_ki_n013_chrX_diversity_pre)
# rm (c_ll_no_n008_chrX_diversity_pre)
# rm (c_ll_po_n008_chrX_diversity_pre)
# rm (c_lp_sm_n019_chrX_diversity_pre)
# rm (c_lp_do_n012_chrX_diversity_pre)


```


# -----------------------------------------------------------------

## General stats: Per pop

### Empirical values per pop

Ahora, usando las tablas que acabo de crear saco los estadísticos de todos los valores que me interesan. 


```{r}

# Basic stats per unit per pop. 
library("Hmisc")

diversity_stats_pop <- function(diversity_df)
{
  diversity_stats_df <- 
             diversity_df %>% 
             dplyr::group_by(pop) %>%
             dplyr::summarise(
                       total_count=n(), 

                       # Distribución sin corregir
                       
                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),

                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),

                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       wmean_pairwise_ave=mean(pairwise_ave,w=informative_sites),
                       
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),

                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),

                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),

                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),

                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,

                       lowerw_watterson_ave = q25_watterson_ave - 1.5 * IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5 * IQR_pairwise_ave,

                       upperw_watterson_ave = q75_watterson_ave + 1.5 * IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5 * IQR_pairwise_ave,
                       
                       
                       # Valores corregidos
                       
                       mean_watterson_ave_corrected=mean(watterson_ave_corrected),
                       mean_pairwise_ave_corrected=mean(pairwise_ave_corrected),

                       median_watterson_ave_corrected=median(watterson_ave_corrected),
                       median_pairwise_ave_corrected=median(pairwise_ave_corrected),
                       
                       
                       wmean_watterson_ave_corrected=weighted.mean(watterson_ave_corrected,w=informative_sites),
                       wmean_pairwise_ave_corrected=mean(pairwise_ave_corrected,w=informative_sites),
                       
                       q25_watterson_ave_corrected=quantile(watterson_ave_corrected,0.25),
                       q25_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.25),

                       q75_watterson_ave_corrected=quantile(watterson_ave_corrected,0.75),
                       q75_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.75),

                       q05_watterson_ave_corrected=quantile(watterson_ave_corrected,0.05),
                       q05_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.05),

                       q95_watterson_ave_corrected=quantile(watterson_ave_corrected,0.95),
                       q95_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.95),

                       IQR_watterson_ave_corrected = q75_watterson_ave_corrected - q25_watterson_ave_corrected,
                       IQR_pairwise_ave_corrected  = q75_pairwise_ave_corrected  - q25_pairwise_ave_corrected,

                       lowerw_watterson_ave_corrected = q25_watterson_ave_corrected - 1.5 * IQR_watterson_ave_corrected,
                       lowerw_pairwise_ave_corrected  = q25_pairwise_ave_corrected  - 1.5 * IQR_pairwise_ave_corrected,

                       upperw_watterson_ave_corrected = q75_watterson_ave_corrected + 1.5 * IQR_watterson_ave_corrected,
                       upperw_pairwise_ave_corrected  = q75_pairwise_ave_corrected  + 1.5 * IQR_pairwise_ave_corrected) %>% 
  mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "Bialowieza",
                            ifelse (pop == "c_ll_ki_n013", "Kirov", 
                            ifelse (pop == "c_ll_no_n008", "Norway", 
                            ifelse (pop == "c_lp_sm_n019", "Andujar", 
                            ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
  mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                            ifelse (pop == "c_ll_ki_n013", "L.lynx",
                            ifelse (pop == "c_ll_no_n008", "L.lynx",  
                            ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
                            ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))



diversity_stats_df$Populations <- factor (diversity_stats_df$Populations, levels=c("Kirov","Bialowieza","Norway", "Andujar", "Donana"))
  
return(diversity_stats_df)
}

# Creo las tablas

stats_df_pop_autosomes <- diversity_stats_pop(data_diversity_autosomes_filtered_ave_corrected) %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX <- diversity_stats_pop(data_diversity_chrX_filtered_ave_corrected) %>%  mutate (type_chr="chrX")

# Las fusiono y las guardo

stats_df_pop <- rbind (stats_df_pop_autosomes, stats_df_pop_chrX)

write.table(stats_df_pop, paste(wd_output,"stats_diversity_per_pop.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

rm (stats_df_pop_autosomes)
rm (stats_df_pop_chrX)


```

### Empirical valuer per pop & different group (feature, chr, region) 

```{r}

diversity_stats_grouped <- function(DATAFRAME ,GROUP)
{ diversity_stats_df_grouped <- 
             DATAFRAME %>% 
             dplyr::group_by_("pop",GROUP) %>%
             dplyr::summarise(
                       total_count=n(), 

                       # Valores sin corregir
                       
                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),
                       mean_tajimaD=mean(tajimaD),
                       
                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),
                       median_tajimaD=median(tajimaD),
                       
                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       wmean_pairwise_ave=weighted.mean(pairwise_ave,w=informative_sites),
                       wmean_tajimaD=mean(tajimaD,w =informative_sites),
  
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),
                       q25_tajimaD=quantile(tajimaD,0.25),
                       
                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),
                       q75_tajimaD=quantile(tajimaD,0.75),
                       
                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),
                       q05_tajimaD=quantile(tajimaD,0.05),
                       
                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),
                       q95_tajimaD=quantile(tajimaD,0.95),
                       
                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,
                       IQR_tajimaD       = q75_tajimaD       - q25_tajimaD ,
                       
                       lowerw_watterson_ave = q25_watterson_ave - 1.5* IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5* IQR_pairwise_ave,
                       lowerw_tajimaD       = q25_tajimaD       - 1.5* IQR_tajimaD,
                       
                       upperw_watterson_ave = q75_watterson_ave + 1.5* IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5* IQR_pairwise_ave,
                       
                       # Valores corregidos
                       
                       mean_watterson_ave_corrected=mean(watterson_ave_corrected),
                       mean_pairwise_ave_corrected=mean(pairwise_ave_corrected),

                       median_watterson_ave_corrected=median(watterson_ave_corrected),
                       median_pairwise_ave_corrected=median(pairwise_ave_corrected),
                       
                       
                       wmean_watterson_ave_corrected=weighted.mean(watterson_ave_corrected,w=informative_sites),
                       wmean_pairwise_ave_corrected=mean(pairwise_ave_corrected,w=informative_sites),
                       
                       q25_watterson_ave_corrected=quantile(watterson_ave_corrected,0.25),
                       q25_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.25),

                       q75_watterson_ave_corrected=quantile(watterson_ave_corrected,0.75),
                       q75_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.75),

                       q05_watterson_ave_corrected=quantile(watterson_ave_corrected,0.05),
                       q05_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.05),

                       q95_watterson_ave_corrected=quantile(watterson_ave_corrected,0.95),
                       q95_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.95),

                       IQR_watterson_ave_corrected = q75_watterson_ave_corrected - q25_watterson_ave_corrected,
                       IQR_pairwise_ave_corrected  = q75_pairwise_ave_corrected  - q25_pairwise_ave_corrected,

                       lowerw_watterson_ave_corrected = q25_watterson_ave_corrected - 1.5 * IQR_watterson_ave_corrected,
                       lowerw_pairwise_ave_corrected  = q25_pairwise_ave_corrected  - 1.5 * IQR_pairwise_ave_corrected,

                       upperw_watterson_ave_corrected = q75_watterson_ave_corrected + 1.5 * IQR_watterson_ave_corrected,
                       upperw_pairwise_ave_corrected  = q75_pairwise_ave_corrected  + 1.5 * IQR_pairwise_ave_corrected,
                       
                       # Valores recombinación
                       
                       mean_recombination_rate=mean(recombination_rate, na.rm=TRUE),
                       wmean_recombination_rate=weighted.mean(recombination_rate,w=informative_sites, na.rm=TRUE),
                       
                       # Valores divergencia
                       
                       mean_divergence_rate=mean(divergence, na.rm=TRUE),
                       wmean_divergence_rate=weighted.mean(divergence,w=informative_sites_substitutions, na.rm=TRUE)
                      
                     ) %>% 
  mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "Bialowieza",
                            ifelse (pop == "c_ll_ki_n013", "Kirov", 
                            ifelse (pop == "c_ll_no_n008", "Norway", 
                            ifelse (pop == "c_lp_sm_n019", "Andujar",  
                            ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
  mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                            ifelse (pop == "c_ll_ki_n013", "L.lynx", 
                            ifelse (pop == "c_ll_no_n008", "L.lynx", 
                            ifelse (pop == "c_lp_sm_n019", "L.pardinus",
                            ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))



diversity_stats_df_grouped$Populations <- factor (diversity_stats_df_grouped$Populations, levels=c("Kirov","Bialowieza","Norway", "Andujar","Donana"))

if("chr" %in% colnames(diversity_stats_df_grouped))
{diversity_stats_df_grouped$chr <- factor(diversity_stats_df_grouped$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}


return (diversity_stats_df_grouped)

}


# Hacemos la tablas

stats_df_pop_autosomes_feature <- diversity_stats_grouped(data_diversity_autosomes_filtered_ave_corrected, "feature") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_feature <- diversity_stats_grouped(data_diversity_chrX_filtered_ave_corrected, "feature") %>%  mutate (type_chr="chrX")

stats_df_pop_autosomes_region  <- diversity_stats_grouped(data_diversity_autosomes_filtered_ave_corrected, "region") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_region  <- diversity_stats_grouped(data_diversity_chrX_filtered_ave_corrected, "region") %>%  mutate (type_chr="chrX")

stats_df_pop_chr     <- diversity_stats_grouped(data_diversity_filtered_ave_corrected, "chr")

# Fusiono y guardo

stats_df_pop_feature <- rbind (stats_df_pop_autosomes_feature, stats_df_pop_chrX_feature)
stats_df_pop_region <- rbind (stats_df_pop_autosomes_region, stats_df_pop_chrX_region)


write.table(stats_df_pop_feature, paste(wd_output,"stats_diversity_per_pop_per_feature.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region, paste(wd_output,"stats_diversity_per_pop_per_region.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_chr, paste(wd_output,"stats_diversity_per_pop_per_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


rm (stats_df_pop_autosomes_feature)
rm (stats_df_pop_chrX_feature)
rm (stats_df_pop_autosomes_region)
rm (stats_df_pop_chrX_region)


```


### Empirical valuer per pop & different group - group (feature-chr, feature-region, chr-region) 


```{r}

diversity_stats_doble_grouped <- function(DATAFRAME, GROUP1, GROUP2)
{ diversity_stats_df_doble_grouped <- 
             DATAFRAME %>% 
             dplyr::group_by_("pop",GROUP1, GROUP2) %>%
             dplyr::summarise(
                       total_count=n(), 

                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),
                       mean_tajimaD=mean(tajimaD),
                       
                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),
                       median_tajimaD=median(tajimaD),
                       
                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       wmean_pairwise_ave=weighted.mean(pairwise_ave,w=informative_sites),
                       wmean_tajimaD=mean(tajimaD,w =informative_sites),
  
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),
                       q25_tajimaD=quantile(tajimaD,0.25),
                       
                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),
                       q75_tajimaD=quantile(tajimaD,0.75),
                       
                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),
                       q05_tajimaD=quantile(tajimaD,0.05),
                       
                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),
                       q95_tajimaD=quantile(tajimaD,0.95),
                       
                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,
                       IQR_tajimaD       = q75_tajimaD       - q25_tajimaD ,
                       
                       lowerw_watterson_ave = q25_watterson_ave - 1.5* IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5* IQR_pairwise_ave,
                       lowerw_tajimaD       = q25_tajimaD       - 1.5* IQR_tajimaD,
                       
                       upperw_watterson_ave = q75_watterson_ave + 1.5* IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5* IQR_pairwise_ave,
                       
                         # Valores corregidos
                       
                       mean_watterson_ave_corrected=mean(watterson_ave_corrected),
                       mean_pairwise_ave_corrected=mean(pairwise_ave_corrected),

                       median_watterson_ave_corrected=median(watterson_ave_corrected),
                       median_pairwise_ave_corrected=median(pairwise_ave_corrected),
                       
                       
                       wmean_watterson_ave_corrected=weighted.mean(watterson_ave_corrected,w=informative_sites),
                       wmean_pairwise_ave_corrected=mean(pairwise_ave_corrected,w=informative_sites),
                       
                       q25_watterson_ave_corrected=quantile(watterson_ave_corrected,0.25),
                       q25_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.25),

                       q75_watterson_ave_corrected=quantile(watterson_ave_corrected,0.75),
                       q75_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.75),

                       q05_watterson_ave_corrected=quantile(watterson_ave_corrected,0.05),
                       q05_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.05),

                       q95_watterson_ave_corrected=quantile(watterson_ave_corrected,0.95),
                       q95_pairwise_ave_corrected=quantile(pairwise_ave_corrected,0.95),

                       IQR_watterson_ave_corrected = q75_watterson_ave_corrected - q25_watterson_ave_corrected,
                       IQR_pairwise_ave_corrected  = q75_pairwise_ave_corrected  - q25_pairwise_ave_corrected,

                       lowerw_watterson_ave_corrected = q25_watterson_ave_corrected - 1.5 * IQR_watterson_ave_corrected,
                       lowerw_pairwise_ave_corrected  = q25_pairwise_ave_corrected  - 1.5 * IQR_pairwise_ave_corrected,

                       upperw_watterson_ave_corrected = q75_watterson_ave_corrected + 1.5 * IQR_watterson_ave_corrected,
                       upperw_pairwise_ave_corrected  = q75_pairwise_ave_corrected  + 1.5 * IQR_pairwise_ave_corrected,
                       
                       # Valores recombinación
                       
                       mean_recombination_rate=mean(recombination_rate, na.rm=TRUE),
                       wmean_recombination_rate=weighted.mean(recombination_rate,w=informative_sites, na.rm=TRUE),
                       
                       # Valores divergencia
                       
                       mean_divergence_rate=mean(divergence, na.rm=TRUE),
                       wmean_divergence_rate=weighted.mean(divergence,w=informative_sites_substitutions, na.rm=TRUE)
                      
                       

                       ) %>% 
  mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "Bialowieza",
                            ifelse (pop == "c_ll_ki_n013", "Kirov", 
                            ifelse (pop == "c_ll_no_n008", "Norway", 
                            ifelse (pop == "c_lp_sm_n019", "Andujar", 
                            ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
  mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                            ifelse (pop == "c_ll_ki_n013", "L.lynx",
                            ifelse (pop == "c_ll_no_n008", "L.lynx", 
                            ifelse (pop == "c_lp_sm_n019", "L.pardinus",
                            ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))



diversity_stats_df_doble_grouped$Populations <- factor (diversity_stats_df_doble_grouped$Populations, levels=c("Kirov","Bialowieza","Norway", "Andujar", "Donana"))


 if("chr" %in% colnames(diversity_stats_df_doble_grouped)){diversity_stats_df_doble_grouped$chr <- factor(diversity_stats_df_doble_grouped$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}

return (diversity_stats_df_doble_grouped)


}


# Hacemos la tablas

stats_df_pop_feature_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected, "feature", "chr")

stats_df_pop_autosomes_feature_region <- diversity_stats_doble_grouped(data_diversity_autosomes_filtered_ave_corrected, "feature", "region") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_feature_region <- diversity_stats_doble_grouped(data_diversity_chrX_filtered_ave_corrected, "feature", "region") %>%  mutate (type_chr="chrX")

stats_df_pop_region_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected, "region", "chr")

# Fusiono y guardo

stats_df_pop_feature_region <- rbind (stats_df_pop_autosomes_feature_region, stats_df_pop_chrX_feature_region)

write.table(stats_df_pop_feature_chr, paste(wd_output,"stats_diversity_per_pop_per_feature_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_feature_region, paste(wd_output,"stats_diversity_per_pop_per_feature_region.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region_chr, paste(wd_output,"stats_diversity_per_pop_per_region_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

rm (stats_df_pop_autosomes_feature_region)
rm (stats_df_pop_chrX_feature_region)

```



# ----------

## Plot basic stats

### Recombination

```{r}
ggplot(data_diversity_autosomes_filtered_ave_corrected %>% dplyr::filter(pop %in% c("c_ll_ki_n013", "c_lp_sm_n019")),aes(feature, recombination_rate, fill=pop, colour=pop))+
  geom_violin() +
  facet_grid(~pop) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_rate_vs_feature.pdf",sep=""))

```

### Divergence 

```{r}
ggplot(data_diversity_autosomes_filtered_ave_corrected %>% dplyr::filter(pop %in% c("c_ll_ki_n013", "c_lp_sm_n019")),aes(feature, divergence, fill=pop, colour=pop))+
  geom_violin() +
  facet_grid(~pop) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  coord_cartesian(ylim = c(0,0.1))
  ggsave(paste(wd_output,"divergence_vs_feature.pdf",sep=""))

```

### Recombination and diversity

```{r}

# Con este plot vemos q efectivamente, cuanto menos recombinación, menos diversidad

ggplot(data=subset(data_diversity_autosomes_filtered_ave_corrected, !is.na(recombination_category)),aes(recombination_category,pairwise_ave, fill=pop, colour=pop))+
  geom_boxplot() +
  facet_grid(~pop)+
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise.pdf",sep=""))

ggplot(data=subset(data_diversity_autosomes_filtered_ave_corrected, !is.na(recombination_category)),aes(recombination_category,pairwise_ave, fill=pop, colour=pop))+
  geom_boxplot() +
  facet_grid(~pop) +
  ggsave(paste(wd_output,"recombination_categories_vs_watterson.pdf",sep=""))

ggplot(data_diversity_autosomes_filtered_ave_corrected,aes(recombination_rate,watterson_ave))+
  geom_point() +
  facet_grid(~pop)

ggplot(data_diversity_autosomes_filtered_ave_corrected,aes(recombination_rate,pairwise_ave, fill=pop, colour=pop))+
  geom_point() +
  facet_grid(~pop)

```


### Recombination and regions

```{r}

ggplot(data_diversity_autosomes_filtered_ave_corrected,aes(region,recombination_rate))+
  geom_boxplot() 
 ggsave(paste (wd_output, "boxplot_violin_plot/","recombination_rate_per_region.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")

```


### Empirical boxplot & violin plot 

```{r}
library(rlang)

# Diversidad por población para cada especie y para cada indice
## BOXPLOT

# Feature and region in autosomes

INDICES=c("watterson_ave", "pairwise_ave")
GROUPS=c("feature", "region")

for (SPECIE in unique(data_diversity_autosomes_filtered_ave_corrected$specie))
{print (SPECIE)
  for (INDEX in INDICES)
  {print (INDEX)
    for (GROUP in GROUPS)
    {print (GROUP)
      # BOXPLOT
      ggplot(data=filter(data_diversity_autosomes_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
        geom_boxplot(outlier.shape=NA, color="black") +
        facet_grid(reformulate(GROUP), scales="free", switch="x") +
        scale_y_continuous(trans = 'log10') +
        scale_x_discrete(GROUP) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        theme_bw() +  #theme selection for background and lines
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(axis.line.x = element_line(color="black", size = 0.5),
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
             # panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output, "boxplot_violin_plot/",INDEX,"_per_",GROUP,"_",SPECIE,"_autosomes_boxplot.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      
      # VIOLIN
      
      ggplot(data=filter(data_diversity_autosomes_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
        geom_violin() +
        facet_grid(reformulate(GROUP), scales="free", switch="x") +
        scale_y_continuous(trans = 'log10') +
        scale_x_discrete(GROUP) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        theme_bw() +  #theme selection for background and lines
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(axis.line.x = element_line(color="black", size = 0.5),
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
            #  panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output,"boxplot_violin_plot/", INDEX,"_per_",GROUP,"_",SPECIE,"_autosomes_violin.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      
    }
  }
}

# Para cromosomas (teniendo en cuenta la tabla con autosomas + chr chrXes)

INDICES=c("watterson_ave", "pairwise_ave")
GROUPS=c("chr")

for (SPECIE in unique(data_diversity_filtered_ave_corrected$specie))
{print (SPECIE)
  for (INDEX in INDICES)
  {print (INDEX)
    for (GROUP in GROUPS)
    {print (GROUP)
      # BOXPLOT
      ggplot(data=filter(data_diversity_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
        geom_boxplot(outlier.shape=NA, color="black") +
        facet_grid(reformulate(GROUP), scales="free", switch="x") +
        scale_y_continuous(trans = 'log10') +
        scale_x_discrete(GROUP) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        theme_bw() +  #theme selection for background and lines
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(axis.line.x = element_line(color="black", size = 0.5),
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
             # panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output, "boxplot_violin_plot/",INDEX,"_per_",GROUP,"_",SPECIE,"_boxplot.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      
      # VIOLIN
      
      ggplot(data=filter(data_diversity_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
        geom_violin() +
        facet_grid(reformulate(GROUP), scales="free", switch="x") +
        scale_y_continuous(trans = 'log10') +
        scale_x_discrete(GROUP) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        theme_bw() +  #theme selection for background and lines
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(axis.line.x = element_line(color="black", size = 0.5),
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
            #  panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output,"boxplot_violin_plot/", INDEX,"_per_",GROUP,"_",SPECIE,"_violin.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      
    }
  }
}

```

### Empirical weighted average --> No lo corro

No lo corro.

```{r}

DATAFRAMES=c("stats_df_chr", "stats_df_feature","stats_df_region")
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="wmean_pairwise_ave", fill="Populations", color="Populations")) +
      geom_point() +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]), scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme_bw() +  #theme selection for background and lines
      theme(axis.line.x = element_line(color="black", size = 0.5),
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"wmean_pairwise_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="wmean_watterson_ave", fill="Populations", color="Populations")) +
      geom_point() +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]), scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme_bw() +  #theme selection for background and lines
      theme(axis.line.x = element_line(color="black", size = 0.5),
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"wmean_watterson_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="wmean_tajimaD", fill="Populations", color="Populations")) +
      geom_point() +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]), scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme_bw() +  #theme selection for background and lines
      theme(axis.line.x = element_line(color="black", size = 0.5),
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"wmean_tajimaD_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
   }
}

  
```


### Empirical corrected value per pop --> No lo corro. 

No corro esto pq el dibujo es el mismo, y por tanto no tiene mucho sentido. 
Opcionalmente también boxplot y violin plot.

```{r}

library(rlang)
# Diversidad por población para cada especie y para cada indice
## BOXPLOT

INDICES=c("corrected_by_pairwise_average_intergenic_per_unit", "corrected_by_watterson_average_intergenic_per_unit")
GROUPS=c("feature")

for (SPECIE in unique(diversity_stats_df_feature_corrected$specie))
{print (SPECIE)
  for (INDEX in INDICES)
  {print (INDEX)
    for (GROUP in GROUPS)
    {print (GROUP)
      
      ggplot(data=filter(diversity_stats_df_feature_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations", color="Populations")) +
        geom_point() +
        facet_grid(~feature, scales="free", switch="x") +
        scale_x_discrete(GROUP) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        theme_bw() +  #theme selection for background and lines
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(axis.line.x = element_line(color="black", size = 0.5),
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              #panel.grid.major = element_blank(),
              #panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
              #panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output, INDEX,"_per_",GROUP,"_",SPECIE,".pdf", sep="" ),  device="pdf")
      
      
      # BOXPLOT
      # ggplot() +
      #   geom_boxplot(data=filter(data_diversity_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations"), color="black") +
      #   facet_grid(reformulate(GROUP), scales="free", switch="x") +
      #   scale_y_continuous(trans = 'log10') +
      #   scale_x_discrete(GROUP) +
      #   xlab(label = "Genomic region") + #x title
      #   ylab(label = paste(INDEX)) + # y title
      #   theme_bw() +  #theme selection for background and lines
      #   # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
      #   theme(axis.line.x = element_line(color="black", size = 0.5),
      #         axis.line.y = element_line(color="black", size = 0.5),
      #         # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
      #         axis.text.x = element_blank(),
      #         axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
      #         axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
      #         axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
      #         panel.grid.major = element_blank(),
      #         panel.grid.minor = element_blank(),
      #         panel.border = element_blank(),
      #         panel.background = element_blank(),
      #         strip.background = element_blank(),
      #         strip.text = element_text(angle = 90),
      #         panel.spacing = unit(1.5, "lines"))
      # ggsave(paste (wd_output, INDEX,"_per_",GROUP,"_",SPECIE,"_boxplot.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      # 
      # # VIOLIN
      # 
      # ggplot(data=filter(data_diversity_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
      #   geom_violin(color="black") +
      #   facet_grid(reformulate(GROUP), scales="free", switch="x") +
      #   scale_y_continuous(trans = 'log10') +
      #   scale_x_discrete(GROUP) +
      #   xlab(label = "Genomic region") + #x title
      #   ylab(label = paste(INDEX)) + # y title
      #   theme_bw() +  #theme selection for background and lines
      #   # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
      #   theme(axis.line.x = element_line(color="black", size = 0.5),
      #         axis.line.y = element_line(color="black", size = 0.5),
      #         # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
      #         axis.text.x = element_blank(),
      #         axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
      #         axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
      #         axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
      #         panel.grid.major = element_blank(),
      #         panel.grid.minor = element_blank(),
      #         panel.border = element_blank(),
      #         panel.background = element_blank(),
      #         strip.background = element_blank(),
      #         strip.text = element_text(angle = 90),
      #         panel.spacing = unit(1.5, "lines"))
      # ggsave(paste (wd_output, INDEX,"_per_",GROUP,"_",SPECIE,"_violin.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      # 
      
      
      
    }
  }
}



```

# ---------------------------------------

## Cat info join

A nivel de chr podemos sacar muchas cosillas. Vamos a hacer un join de las tablas de información con las de diversidad y vamos a plotear algunas cosillas básicas.

```{r}

# Cargo la tabla con la información de gato.
cat_chr_info <- read.table("/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/cat_chr_gene_content_recombination_all_information.txt", header=T, na.strings = c("NA", "na"), dec=",")


# Creo tablas con la información de diversidad y de cromosomas. 
stas_df_pop_chr_plus_cat_info <- right_join(x = cat_chr_info, y = stats_df_pop_chr, by="chr") 
stas_df_pop_chr_plus_cat_info$pop <- factor (stas_df_pop_chr_plus_cat_info$Populations, levels=c("Kirov","Bialowieza","Norway", "Andujar", "Donana"))

```

#### Chromosome divergence

Voy a sacar la divergencia por cromosoma porque no la tengo

```{r}

average_divergence_per_pop <- data_diversity_filtered_ave_corrected %>% 
             dplyr::group_by_("Species","chr") %>%
             dplyr::summarise(mean_divergence=mean(divergence,na.rm=TRUE)) 


  
  if("chr" %in% colnames(average_divergence_per_pop)){average_divergence_per_pop$chr <- factor(average_divergence_per_pop$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}


ggplot (average_divergence_per_pop, aes(chr, mean_divergence, fill=Species, color=Species)) +
  geom_point()

# Hacemos la tablas

average_divergence_per_pop_spread <- average_divergence_per_pop %>% tidyr::spread(., Species, mean_divergence ) %>% as.data.frame(.) %>% dplyr::rename(., "L.lynx_divergence"="L.lynx") %>% dplyr::rename(.,"L.pardinus_divergence"="L.pardinus")

# Lo uno a los datos de gato

cat_chr_info_divergence <- right_join(x = cat_chr_info, y = average_divergence_per_pop_spread, by="chr") 

# Lo uno también con los datos de diversidad
stas_df_pop_chr_plus_extra_info <- right_join(stas_df_pop_chr_plus_cat_info, average_divergence_per_pop, by=c("chr", "Species") )

```


### General plots cat info

```{r}

# La filtro para hacer plots

cat_chr_info_filtered <- cat_chr_info_divergence %>% filter(., chr!="chrX") %>% select (SizeMb_v8, GC_content, percentage_genes, cM.Mb, L.lynx_divergence, L.pardinus_divergence)


# Hago una matriz de correlación entre las variables

res <- cor(cat_chr_info_filtered )
round(res, 2)
cor(cat_chr_info_filtered, use = "complete.obs")

# http://www.sthda.com/english/wiki/correlation-matrix-a-quick-start-guide-to-analyze-format-and-visualize-a-correlation-matrix-using-r-software
# library("PerformanceAnalytics")
# chart.Correlation(cat_chr_info_filtered, histogram=TRUE, pch=19)

library(GGally)
lowerFn <- function(data, mapping, method = "lm", ...) {
  p <- ggplot(data = data, mapping = mapping) +
    geom_point(colour = "black") +
    geom_smooth(method = method, color = "black", ...)
  p
}


pdf(paste(wd_output, "correlation_matrix_1.pdf", sep="")) 
ggpairs(cat_chr_info_filtered,  lower = list(continuous = wrap(lowerFn, method = "lm")))
dev.off()

# https://stackoverflow.com/questions/30858337/how-to-customize-lines-in-ggpairs-ggally
#  diag = list(continuous = wrap("barDiag", colour = "blue")),
#  upper = list(continuous = wrap("cor", size = 10))


# Primero unas cuantas cosillas básicas respecto a los chr.

# Cat chr version size comparison
# ggplot(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v5 ,y=SizeMb_v8)) +
#   geom_point(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v5 ,y=SizeMb_v8, fill=chr, colour=chr))+
#   geom_smooth() +
# ggtitle("Cat chr version size comparison")
# ggsave(paste(wd_output, "cat_chr_size_comparison.pdf", sep=""), device = pdf)
# 
# 
# ggplot(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v8 ,y=cM.Mb)) +
#   geom_point(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v8 ,y=cM.Mb, fill=chr, colour=chr)) +
#   geom_smooth()+
# ggtitle("Recombination_rate cat genome v8")
# ggsave(paste(wd_output, "cat_recombination_size_comparison.pdf", sep=""), device = pdf)
# 
# 
# ggplot(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v8, y=percentage_genes )) +
#   geom_point(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v8 ,y=percentage_genes , fill=chr, colour=chr)) +
#   geom_smooth()+
# ggtitle("Gene content vs size cat genome v8")
# ggsave(paste(wd_output, "cat_size_vs_gene_content_comparison.pdf", sep=""), device = pdf)

```


### Plot join with diversity data
# AQUI

```{r}
# Para todo esto quitamos el cromosoma X porque es un outlier!!!

#### SANITY CHECKS #### 

# Comprobamos que la tasa de recombinación que nosotros tenemos para cada cromosoma cuando hacemos la media es parecida a la de los cromosomas. 

# ggplot (stas_df_pop_chr_plus_extra_info, aes(cM.Mb, mean_recombination_rate))+
#   geom_point()+
#   coord_equal(xlim=c(0,6),ylim=c(0,6))
# 
# 
# ggplot (stas_df_pop_chr_plus_extra_info, aes(cM.Mb, wmean_recombination_rate))+
#   geom_point()+
#   coord_equal(xlim=c(0,6),ylim=c(0,6))
# 
# 
# ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes(mean_recombination_rate, SizeMb_v8))+
#   geom_point() +
#     geom_smooth()

# Coincide regulín. 

######################## 

lm_eqn <- function(df){
    m <- lm(y ~ x, df);
    eq <- substitute(italic(y) == a + b %.% italic(x)*","~~italic(r)^2~"="~r2, 
         list(a = format(coef(m)[1], digits = 2),
              b = format(coef(m)[2], digits = 2),
             r2 = format(summary(m)$r.squared, digits = 3)))
    as.character(as.expression(eq));
}

p1 <- p + geom_text(x = 25, y = 300, label = lm_eqn(df), parse = TRUE)
INDEXES=c("mean_watterson_ave", "mean_pairwise_ave", "median_watterson_ave", "median_pairwise_ave") 




# Diversidad vs tamaño

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("SizeMb_v8", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_grid(~pop) +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "cat_size_vs_",INDEX,".pdf", sep=""))

}
    
# Diversidad vs tamaño


for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("percentage_genes", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_grid(~pop) +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "cat_gene-content_vs_",INDEX,".pdf", sep=""))

}
    
# Diversidad vs chr recombination

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("cM.Mb", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_grid(~pop) +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "cat_chr-recomb_vs_",INDEX,".pdf", sep=""))

}

# Diversidad vs calculated recombination

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("mean_recombination_rate", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_grid(~pop) +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "cat_calculated-recomb_vs_",INDEX,".pdf", sep=""))

}


# Diversidad vs divergence

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("mean_divergence", INDEX, fill="Species" , colour="Species")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_grid(~pop) +
  theme(axis.text.x = element_text(angle = 90))+
  theme_bw() +  #theme selection for background and lines
  ggsave(paste(wd_output, "divergence_vs_",INDEX,".pdf", sep=""))

}

```

# ---------------------------------------


## Bootstraped mean 


```{r}

library(boot)
library(broom)

# Cargo la funcion de bootstrap
boot_mean <- function(original_vector, resample_vector) {
   mean(original_vector[resample_vector])
}

# Cargo la función global
diversity_stats_grouped_boot <- function(DATAFRAME ,GROUP)
{ 
  
    DATAFRAME_nested <- DATAFRAME %>% dplyr::group_by_("pop", GROUP) %>% tidyr::nest()
  pairwise_average <- DATAFRAME_nested %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$pairwise_ave), statistic = boot_mean, R = ITERATION))) %>% 
    dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
  names(pairwise_average)[3] <- "values"
  pairwise_average_summary <- pairwise_average  %>% 
    group_by_(.dots=c("pop", GROUP)) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values)) %>% 
    mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "Bialowieza",
                              ifelse (pop == "c_ll_ki_n013", "Kirov",
                              ifelse (pop == "c_ll_no_n008", "Norway", 
                              ifelse (pop == "c_lp_sm_n019", "Andujar",
                              ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
    mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                              ifelse (pop == "c_ll_ki_n013", "L.lynx", 
                              ifelse (pop == "c_ll_no_n008", "L.lynx", 
                              ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
                              ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))
  names(pairwise_average_summary)[3] <- "mean_pairwise_boot"
  names(pairwise_average_summary)[4] <- "sd_pairwise_boot"
  
  
        DATAFRAME_nested <- DATAFRAME %>% dplyr::group_by_("pop", GROUP) %>% tidyr::nest()
  watterson_average <- DATAFRAME_nested %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$watterson_ave), statistic = boot_mean, R = ITERATION))) %>% 
    dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
  names(watterson_average)[3] <- "values"
  watterson_average_summary <- watterson_average  %>% 
    group_by_(.dots=c("pop", GROUP)) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values)) %>%     
    mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "Bialowieza",
                              ifelse (pop == "c_ll_ki_n013", "Kirov",
                              ifelse (pop == "c_ll_no_n008", "Norway", 
                              ifelse (pop == "c_lp_sm_n019", "Andujar", 
                              ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
    mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                              ifelse (pop == "c_ll_ki_n013", "L.lynx",  
                              ifelse (pop == "c_ll_no_n008", "L.lynx", 
                              ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
                              ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))
  names(watterson_average_summary)[3] <- "mean_watterson_boot"
  names(watterson_average_summary)[4] <- "sd_watterson_boot"
  
  
  
  # DATAFRAME_nested <- DATAFRAME %>% dplyr::group_by_("pop", GROUP) %>% tidyr::nest()
  # tajimaD <- DATAFRAME_nested %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$tajimaD), statistic = boot_mean, R = ITERATION))) %>% 
  #   dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
  #   dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
  # names(tajimaD)[3] <- "values"
  # tajimaD_summary <- tajimaD  %>% 
  #   group_by_(.dots=c("pop", GROUP)) %>%
  #   dplyr::summarise(mean=mean(values),sd=sd(values)) %>% 
  #       mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "Bialowieza",
  #                             ifelse (pop == "c_ll_ki_n013", "Kirov",
  #                             ifelse (pop == "c_ll_no_n008", "Norway", 
  #                             ifelse (pop == "c_lp_sm_n019", "Andujar",
  #                             ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
  #   mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
  #                             ifelse (pop == "c_ll_ki_n013", "L.lynx",  
  #                             ifelse (pop == "c_ll_no_n008", "L.lynx", 
  #                             ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
  #                             ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))
  # names(tajimaD_summary)[3] <- "mean_tajimaD_boot"
  # names(tajimaD_summary)[4] <- "sd_tajimaD_boot"
  
  tmp_group <- full_join (watterson_average_summary, pairwise_average_summary, by = c("pop", GROUP, "Populations", "Species")) 
  tmp_group$Populations <- factor (tmp_group$Populations, levels=c("Kirov","Bialowieza","Norway", "Andujar", "Donana"))
  
  if("chr" %in% colnames(tmp_group))
{tmp_group$chr <- factor(tmp_group$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}
  
  
return (tmp_group)
 
  rm (tmp_group)
  rm (watterson_average)
  rm (watterson_average_summary)
  rm (pairwise_average)
  rm (pairwise_average_summary)
  rm (tajimaD)
  rm (tajimaD_summary)
  rm (DATAFRAME_nested)
  
}


ITERATION=100


# Genero las tablas

stats_df_pop_autosomes_feature_boostrapped <- diversity_stats_grouped_boot(data_diversity_autosomes_filtered_ave_corrected, "feature") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_feature_boostrapped <- diversity_stats_grouped_boot(data_diversity_chrX_filtered_ave_corrected, "feature") %>%  mutate (type_chr="chrX")

stats_df_pop_autosomes_region_boostrapped <- diversity_stats_grouped_boot(data_diversity_autosomes_filtered_ave_corrected, "region") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_region_boostrapped <- diversity_stats_grouped_boot(data_diversity_chrX_filtered_ave_corrected, "region") %>%  mutate (type_chr="chrX")

stats_df_pop_chr_boostrapped <- diversity_stats_grouped_boot(data_diversity_filtered_ave_corrected, "chr") 

# Fusiono y guardo

stats_df_pop_feature_boostrapped <- rbind (stats_df_pop_autosomes_feature_boostrapped, stats_df_pop_chrX_feature_boostrapped)
stats_df_pop_region_boostrapped <- rbind(stats_df_pop_autosomes_region_boostrapped,stats_df_pop_chrX_region_boostrapped)

rm(stats_df_pop_autosomes_feature_boostrapped)
rm(stats_df_pop_chrX_feature_boostrapped)
rm(stats_df_pop_autosomes_region_boostrapped)
rm(stats_df_pop_chrX_region_boostrapped)

write.table(stats_df_pop_feature_boostrapped, paste(wd_output,"stats_diversity_per_pop_per_feature_boostrapped.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region_boostrapped, paste(wd_output,"stats_diversity_per_pop_per_region_boostrapped.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_chr_boostrapped, paste(wd_output,"stats_diversity_per_pop_per_chr_boostrapped.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )


```

Nota:
He comprobado la normalidad en un caso concreto, pero creo que puede ser aplicable a todo.

Para el caso:
kk <- DATAFRAME_nested %>%  filter(pop=="c_ll_ki_n013") %>% filter(feature=="CDS")
shapiro.test(kk$boot_matrix)

Shapiro-Wilk normality test

data:  kk$boot_matrix
W = 0.99973, p-value = 0.8071

From the output, the p-value > 0.05 implying that the distribution of the data are not significantly different from normal distribution. In other words, we can assume the normality.

Así que perfecto!


## Plot Bootstrapped data

```{r}

# Ploteo los datos de bootstraping  

DATAFRAMES=c("stats_df_pop_feature_boostrapped","stats_df_pop_region_boostrapped")
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(type_chr~get(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme_bw() +  #theme selection for background and lines
      theme(axis.line.x = element_line(color="black", size = 0.5),
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_pairwise_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_pairwise_boot), ymax=(mean_watterson_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(type_chr~get(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme_bw() +  #theme selection for background and lines
      theme(axis.line.x = element_line(color="black", size = 0.5),
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_watterson_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
   }
}

# Corro lo mismo xa la tabla con chr que no tengo que separar entre autosomas y chrXes

DATAFRAMES=c("stats_df_pop_chr_boostrapped") 
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme_bw() +  #theme selection for background and lines
      theme(axis.line.x = element_line(color="black", size = 0.5),
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_pairwise_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,"_autosomes.pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_pairwise_boot), ymax=(mean_watterson_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme_bw() +  #theme selection for background and lines
      theme(axis.line.x = element_line(color="black", size = 0.5),
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_watterson_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")


   }
}

  
```


# ----------------------------------------------------------------

## Tablas interacción non-bootleneck vs bootleneck

# ------------------

### Ratio per unit

Aquí tengo los ratios de las unidades particulares.

```{r}

# Dataframe Kirov-Norway

# Function:

# Cuidado porque aquí estoy asumiendo que la region es igual, y esto parece que es asi, pero no estoy 100% segura de que no haya podido pasar que en una población se haya definido como telomérico y en otra no por falta de bases. 

calculus_data_diversity_bootleneck_vs_non_bootleneck <- function(POP1, POP2, name_POP1, name_POP2){
  data_diversity_POP1_POP2 <- dplyr::inner_join (POP1, POP2, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id", "recombination_rate", "recombination_category", "type_chr", "divergence", "informative_sites_substitutions", "substitutions")) %>%  
    mutate (ratio_pairwise_average = pairwise_ave.y/pairwise_ave.x) %>% 
    mutate (ratio_watterson_average = watterson_ave.y/watterson_ave.x) %>% 
    mutate (ratio_pairwise_average_corrected = pairwise_ave_corrected.y/pairwise_ave_corrected.x) %>%
    mutate (ratio_watterson_average_corrected = watterson_ave_corrected.y/watterson_ave_corrected.x) #%>% 
  
  dataframename <- paste ("data_diversity", name_POP1, name_POP2, sep="_")
  assign (dataframename, data_diversity_POP1_POP2,.GlobalEnv)
}

# Create data frame

# Dataframe Kirov-Norway
calculus_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n013_diversity,c_ll_no_n008_diversity, deparse(substitute(c_ll_ki_n013_diversity)),deparse(substitute(c_ll_no_n008_diversity)))

calculus_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n013_autosomes_diversity,c_ll_no_n008_autosomes_diversity, deparse(substitute(c_ll_ki_n013_autosomes_diversity)),deparse(substitute(c_ll_no_n008_autosomes_diversity)))

calculus_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n013_chrX_diversity,c_ll_no_n008_chrX_diversity, deparse(substitute(c_ll_ki_n013_chrX_diversity)),deparse(substitute(c_ll_no_n008_chrX_diversity)))

# Dataframe Kirov-Poland
calculus_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n013_diversity,c_ll_po_n008_diversity, deparse(substitute(c_ll_ki_n013_diversity)),deparse(substitute(c_ll_po_n008_diversity)))

calculus_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n013_autosomes_diversity,c_ll_po_n008_autosomes_diversity, deparse(substitute(c_ll_ki_n013_autosomes_diversity)),deparse(substitute(c_ll_po_n008_autosomes_diversity)))

calculus_data_diversity_bootleneck_vs_non_bootleneck(c_ll_ki_n013_chrX_diversity,c_ll_po_n008_chrX_diversity, deparse(substitute(c_ll_ki_n013_chrX_diversity)),deparse(substitute(c_ll_po_n008_chrX_diversity)))


# Dataframe Sierra_Morena-Doñana
calculus_data_diversity_bootleneck_vs_non_bootleneck(c_lp_sm_n019_diversity,c_lp_do_n012_diversity, deparse(substitute(c_lp_sm_n019_diversity)),deparse(substitute(c_lp_do_n012_diversity)))

calculus_data_diversity_bootleneck_vs_non_bootleneck(c_lp_sm_n019_autosomes_diversity,c_lp_do_n012_autosomes_diversity, deparse(substitute(c_lp_sm_n019_autosomes_diversity)),deparse(substitute(c_lp_do_n012_autosomes_diversity)))

calculus_data_diversity_bootleneck_vs_non_bootleneck(c_lp_sm_n019_chrX_diversity,c_lp_do_n012_chrX_diversity, deparse(substitute(c_lp_sm_n019_chrX_diversity)),deparse(substitute(c_lp_do_n012_chrX_diversity)))


# write.table(data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity, paste(wd_output,"data_diversity_c_ll_ki_n013_c_ll_no_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
# write.table(data_diversity_c_ll_ki_n013_diversity_c_ll_po_n008_diversity, paste(wd_output,"data_diversity_c_ll_ki_n013_c_ll_po_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
# write.table(data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity, paste(wd_output,"data_diversity_c_lp_sm_n019_c_lp_do_n012.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )



# También las creo a lo largo para poder lanzar modelos
# c_ll_ki_n013_diversity_c_ll_po_n008_diversity_for_model <- rbind(c_ll_ki_n013_diversity, c_ll_po_n008_diversity)
# rm(data_diversity)
# rm(c_ll_ki_n013_diversity)
# rm(c_ll_po_n008_diversity)
# rm(c_ll_no_n008_diversity)
# rm(c_lp_sm_n019_diversity)
# rm(c_lp_do_n012_diversity)

```



### Stats de los ratios.

No lo corro pq no tiene mucho sentido hacer la media de los ratios per unit, más que por curiosidad de ver su distribución, y eso ya lo vamos a ver con el boot. 

```{r}
library("Hmisc")
library(modeest)



diversity_stats_pop <- function(diversity_df)
{
  diversity_stats_df <- 
    diversity_df %>% 
    dplyr::group_by(feature) %>% 
    dplyr::summarise(mode_ratio_pairwise_average=mlv(ratio_pairwise_average, method="mfv")[['M']],
                     mean_ratio_pairwise_average=mean(ratio_pairwise_average),
                     median_ratio_pairwise_average=median(ratio_pairwise_average),
                     q25_ratio_pairwise_average=quantile(ratio_pairwise_average,0.25),
                     q75_ratio_pairwise_average=quantile(ratio_pairwise_average,0.75),
                     q05_ratio_pairwise_average=quantile(ratio_pairwise_average,0.05),
                     q95_ratio_pairwise_average=quantile(ratio_pairwise_average,0.95),
                     IQR_ratio_pairwise_average = q75_ratio_pairwise_average - q25_ratio_pairwise_average,
                     lowerw_ratio_pairwise_average = q25_ratio_pairwise_average - 1.5* IQR_ratio_pairwise_average,
                     upperw_ratio_pairwise_average = q75_ratio_pairwise_average + 1.5* IQR_ratio_pairwise_average, 
                     
                     mean_ratio_watterson_average=mean(ratio_watterson_average),
                     mean_ratio_corrected_by_pairwise_average_intergenic_per_unit=mean(ratio_pairwise_average_corrected),
                     mean_ratio_corrected_by_watterson_average_intergenic_per_unit=mean(ratio_watterson_average_corrected)) 
  
  return(diversity_stats_df)
}

stats_data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity <- diversity_stats_pop(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity)

stats_data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity <- diversity_stats_pop(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity)

stats_data_diversity_c_lp_sm_n019_autosomes_diversity_c_lp_do_n012_autosomes_diversity <- diversity_stats_pop(data_diversity_c_lp_sm_n019_autosomes_diversity_c_lp_do_n012_autosomes_diversity)

```


### Bootstraping

Hago un boot de la media de los ratios per unit. 

```{r}

library(plyr)
library(boot)
library(broom)
library(magrittr)
library(dplyr)

#wd_output <- "/Users/marialucenaperez/Owncloud/publico/WG_diversity/ANGSD/sfs/"

# https://uoftcoders.github.io/studyGroup/lessons/r/resampling/lesson/
# Explicación del paquete boot y boot_mean
# https://www.painblogr.org/2017-10-18-purrring-through-bootstraps.html
# Explicación interesantisima sobre la integración de boot con dplyr group by. 


# Cargo la funcion de bootstrap
boot_mean <- function(original_vector, resample_vector) {
   mean(original_vector[resample_vector])
}



# Defino variables para iterar

# Primero para autosomes para feature y region

DATAFRAMES=c("data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity", "data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity", "data_diversity_c_lp_sm_n019_autosomes_diversity_c_lp_do_n012_autosomes_diversity", "data_diversity_c_ll_ki_n013_chrX_diversity_c_ll_no_n008_chrX_diversity", "data_diversity_c_ll_ki_n013_chrX_diversity_c_ll_po_n008_chrX_diversity", "data_diversity_c_lp_sm_n019_chrX_diversity_c_lp_do_n012_chrX_diversity")

GROUPS=c("feature", "region")
ITERATION=100

for (DATAFRAME in DATAFRAMES)
{
  print (DATAFRAME)
  for (GROUP in GROUPS)
  {
    print(GROUP)
    
    # Hacemos un group_by y despues un nest que nos devuelve para cada GROUP una variable en la que está condensada la dataframe.
    
    ###################
    #1.  ratio_watterson_average
    DATAFRAME_filtered <- get(DATAFRAME) %>%
      # First I group the data by species 
      dplyr::group_by_(GROUP) %>%
      # Then I nest the dataframe
      tidyr::nest()
    
      ratio_watterson_average <- DATAFRAME_filtered %<>%
      # Aquí aplicamos el bootstrapping sobre la columna de data (la que tiene la dataframe condensada) concretamente sobre el subset del ratio X.  
      dplyr::mutate(booted = purrr::map(.x = data, # The list-column containing <S3: tibble>
                                        ~ boot::boot(data = as.numeric(.x$ratio_watterson_average), # The <S3 tibble> column being sampled
                                                     statistic = boot_mean, # The user-defined function
                                                     R = ITERATION))) %>% 
      # Del resultado de boot creamos una nueva variable con el valor t, que tiene la matriz de longitud igual al numero de iteraciones. 
      dplyr::mutate(boot_matrix = purrr::map(.x = booted, # The list-column containing <S3 bootci> objects
                                             ~ .x$t)) %>% 
      # Eliminamos la columna data (el dataframe original), y también los valores booted (que tienen todos los resultados del bootstraping). Despues desagregamos por el valor de la matriz. 
      dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    # Cambiamos el nombre de la matriz. 
    names(ratio_watterson_average)[2] <- "values"
ratio_watterson_average_summary <- ratio_watterson_average  %>% 
    group_by_(.dots=GROUP) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values))
    names(ratio_watterson_average_summary)[2] <- "mean_ratio_watterson_boot"
    names(ratio_watterson_average_summary)[3] <- "sd_ratio_watterson_boot"
    
    # Hago lo mismo para cada indice.
    ###################
    #2.  ratio_pairwise_average
    
    DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    ratio_pairwise_average <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_pairwise_average), statistic = boot_mean, R = ITERATION))) %>% 
      dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
      dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    names(ratio_pairwise_average)[2] <- "values"
    ratio_pairwise_average_summary <- ratio_pairwise_average  %>% 
    group_by_(.dots=GROUP) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values))
    names(ratio_pairwise_average_summary)[2] <- "mean_ratio_pairwise_boot"
    names(ratio_pairwise_average_summary)[3] <- "sd_ratio_pairwise_boot"
    
    ###################
    #3.  ratio_pairwise_average_corrected
    
    DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    ratio_pairwise_average_corrected <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_pairwise_average_corrected), statistic = boot_mean, R = ITERATION))) %>% 
      dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
      dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    names(ratio_pairwise_average_corrected)[2] <- "values"
     ratio_pairwise_average_corrected_summary <- ratio_pairwise_average_corrected  %>% 
    group_by_(.dots=GROUP) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values))    
     names(ratio_pairwise_average_corrected_summary)[2] <- "mean_ratio_corrected_by_pairwise_average_intergenic_per_unit_boot"
    names(ratio_pairwise_average_corrected_summary)[3] <- "sd_ratio_corrected_by_pairwise_average_intergenic_per_unit_boot"
    
    ###################
    #4.  ratio_watterson_average_corrected
    
    DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    ratio_watterson_average_corrected <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_watterson_average_corrected), statistic = boot_mean, R = ITERATION))) %>% 
      dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
      dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    names(ratio_watterson_average_corrected)[2] <- "values"
    ratio_watterson_average_corrected_summary <- ratio_watterson_average_corrected  %>% 
    group_by_(.dots=GROUP) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values))  
    names(ratio_watterson_average_corrected_summary)[2] <- "mean_ratio_corrected_by_watterson_average_intergenic_per_unit_boot"
    names(ratio_watterson_average_corrected_summary)[3] <- "sd_ratio_corrected_by_watterson_average_intergenic_per_unit_boot"

    ###################
    #5.  ratio_corrected_by_pairwise_average_intergenic_weighted
    # 
    # DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    # ratio_corrected_by_pairwise_average_intergenic_weighted <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_corrected_by_pairwise_average_intergenic_weighted), statistic = boot_mean, R = ITERATION))) %>% 
    #   dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    #   dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    # names(ratio_corrected_by_pairwise_average_intergenic_weighted)[2] <- "values"
    # ratio_corrected_by_pairwise_average_intergenic_weighted_summary <- ratio_corrected_by_pairwise_average_intergenic_weighted  %>% 
    # group_by_(.dots=GROUP) %>%
    # dplyr::summarise(mean=mean(values),sd=sd(values))  
    # names(ratio_corrected_by_pairwise_average_intergenic_weighted_summary)[2] <- "mean_ratio_corrected_by_pairwise_average_intergenic_weighted_boot"
    # names(ratio_corrected_by_pairwise_average_intergenic_weighted_summary)[3] <- "sd_ratio_corrected_by_pairwise_average_intergenic_weighted_boot"
    # 
    # ###################
    # #6.  ratio_corrected_by_watterson_average_intergenic_weighted
    # 
    # DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    # ratio_corrected_by_watterson_average_intergenic_weighted <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_corrected_by_watterson_average_intergenic_weighted), statistic = boot_mean, R = ITERATION))) %>% 
    #   dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    #   dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    # names(ratio_corrected_by_watterson_average_intergenic_weighted)[2] <- "values"
    # ratio_corrected_by_watterson_average_intergenic_weighted_summary <- ratio_corrected_by_watterson_average_intergenic_weighted  %>% 
    # group_by_(.dots=GROUP) %>%
    # dplyr::summarise(mean=mean(values),sd=sd(values))  
    # names(ratio_corrected_by_watterson_average_intergenic_weighted_summary)[2] <- "mean_ratio_corrected_by_watterson_average_intergenic_weighted_boot"
    # names(ratio_corrected_by_watterson_average_intergenic_weighted_summary)[3] <- "sd_ratio_corrected_by_watterson_average_intergenic_weighted_boot"
    # 
    ###################
    # Agrego los datos
    
    tmp_group <- purrr::reduce(list(ratio_watterson_average_summary, ratio_pairwise_average_summary,
                                    ratio_pairwise_average_corrected_summary,
                                    ratio_watterson_average_corrected_summary), #,
                                    #ratio_corrected_by_pairwise_average_intergenic_weighted_summary,
                                    #ratio_corrected_by_watterson_average_intergenic_weighted_summary), 
                                    full_join, by = GROUP)
    
    POP1=as.character(get(DATAFRAME) %>% select (pop.x) %>% .[1,1])
    POP2=as.character(get(DATAFRAME) %>% select (pop.y) %>% .[1,1])
    chr_type=ifelse((as.character(get(DATAFRAME) %>% select (chr) %>% .[1,1])) == "chrX","chrX","autosomes")
    
    tmp_group <- tmp_group %>% mutate (chr_type=chr_type)
    
    tmp_group_name <- paste ("ratio_boot",chr_type, POP1,POP2, GROUP, sep="_")
    
    assign (tmp_group_name, tmp_group,.GlobalEnv)    
    
    ###################
    # Borro tablas antiguas para que no haya confusión 
    
    rm (tmp_group)
    rm (tmp_group_name)
    rm (ratio_watterson_average)
    rm (ratio_pairwise_average)
    rm (ratio_pairwise_average_corrected)
    rm (ratio_watterson_average_corrected)
    #rm (ratio_corrected_by_pairwise_average_intergenic_weighted)
    #rm (ratio_corrected_by_watterson_average_intergenic_weighted)
    rm (ratio_watterson_average_summary)
    rm (ratio_pairwise_average_summary)
    rm (ratio_pairwise_average_corrected_summary)
    rm (ratio_watterson_average_corrected_summary)
    #rm (ratio_corrected_by_pairwise_average_intergenic_weighted_summary)
    #rm (ratio_corrected_by_watterson_average_intergenic_weighted_summary)
    
  }
}


# Ahora fusiono las tablas

ratio_boot_c_ll_ki_n013_c_ll_no_n008_feature <- rbind (ratio_boot_autosomes_c_ll_ki_n013_c_ll_no_n008_feature, ratio_boot_chrX_c_ll_ki_n013_c_ll_no_n008_feature)
ratio_boot_c_ll_ki_n013_c_ll_po_n008_feature <- rbind (ratio_boot_autosomes_c_ll_ki_n013_c_ll_po_n008_feature, ratio_boot_chrX_c_ll_ki_n013_c_ll_po_n008_feature)
ratio_boot_c_lp_sm_n019_c_lp_do_n012_feature <- rbind (ratio_boot_autosomes_c_lp_sm_n019_c_lp_do_n012_feature, ratio_boot_chrX_c_lp_sm_n019_c_lp_do_n012_feature)

##############################################################################################################
# Chr

DATAFRAMES=c("data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity", "data_diversity_c_ll_ki_n013_diversity_c_ll_po_n008_diversity", "data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity")
GROUPS=c("chr")
ITERATION=100

for (DATAFRAME in DATAFRAMES)
{
  print (DATAFRAME)
  for (GROUP in GROUPS)
  {
    print(GROUP)
    
    # Hacemos un group_by y despues un nest que nos devuelve para cada GROUP una variable en la que está condensada la dataframe.
    
    ###################
    #1.  ratio_watterson_average
    DATAFRAME_filtered <- get(DATAFRAME) %>%
      # First I group the data by species 
      dplyr::group_by_(GROUP) %>%
      # Then I nest the dataframe
      tidyr::nest()
    
      ratio_watterson_average <- DATAFRAME_filtered %<>%
      # Aquí aplicamos el bootstrapping sobre la columna de data (la que tiene la dataframe condensada) concretamente sobre el subset del ratio X.  
      dplyr::mutate(booted = purrr::map(.x = data, # The list-column containing <S3: tibble>
                                        ~ boot::boot(data = as.numeric(.x$ratio_watterson_average), # The <S3 tibble> column being sampled
                                                     statistic = boot_mean, # The user-defined function
                                                     R = ITERATION))) %>% 
      # Del resultado de boot creamos una nueva variable con el valor t, que tiene la matriz de longitud igual al numero de iteraciones. 
      dplyr::mutate(boot_matrix = purrr::map(.x = booted, # The list-column containing <S3 bootci> objects
                                             ~ .x$t)) %>% 
      # Eliminamos la columna data (el dataframe original), y también los valores booted (que tienen todos los resultados del bootstraping). Despues desagregamos por el valor de la matriz. 
      dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    # Cambiamos el nombre de la matriz. 
    names(ratio_watterson_average)[2] <- "values"
ratio_watterson_average_summary <- ratio_watterson_average  %>% 
    group_by_(.dots=GROUP) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values))
    names(ratio_watterson_average_summary)[2] <- "mean_ratio_watterson_boot"
    names(ratio_watterson_average_summary)[3] <- "sd_ratio_watterson_boot"
    
    # Hago lo mismo para cada indice.
    ###################
    #2.  ratio_pairwise_average
    
    DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    ratio_pairwise_average <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_pairwise_average), statistic = boot_mean, R = ITERATION))) %>% 
      dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
      dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    names(ratio_pairwise_average)[2] <- "values"
    ratio_pairwise_average_summary <- ratio_pairwise_average  %>% 
    group_by_(.dots=GROUP) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values))
    names(ratio_pairwise_average_summary)[2] <- "mean_ratio_pairwise_boot"
    names(ratio_pairwise_average_summary)[3] <- "sd_ratio_pairwise_boot"
    
    ###################
    #3.  ratio_pairwise_average_corrected
    
    DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    ratio_pairwise_average_corrected <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_pairwise_average_corrected), statistic = boot_mean, R = ITERATION))) %>% 
      dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
      dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    names(ratio_pairwise_average_corrected)[2] <- "values"
     ratio_pairwise_average_corrected_summary <- ratio_pairwise_average_corrected  %>% 
    group_by_(.dots=GROUP) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values))    
     names(ratio_pairwise_average_corrected_summary)[2] <- "mean_ratio_corrected_by_pairwise_average_intergenic_per_unit_boot"
    names(ratio_pairwise_average_corrected_summary)[3] <- "sd_ratio_corrected_by_pairwise_average_intergenic_per_unit_boot"
    
    ###################
    #4.  ratio_watterson_average_corrected
    
    DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    ratio_watterson_average_corrected <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_watterson_average_corrected), statistic = boot_mean, R = ITERATION))) %>% 
      dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
      dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    names(ratio_watterson_average_corrected)[2] <- "values"
    ratio_watterson_average_corrected_summary <- ratio_watterson_average_corrected  %>% 
    group_by_(.dots=GROUP) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values))  
    names(ratio_watterson_average_corrected_summary)[2] <- "mean_ratio_corrected_by_watterson_average_intergenic_per_unit_boot"
    names(ratio_watterson_average_corrected_summary)[3] <- "sd_ratio_corrected_by_watterson_average_intergenic_per_unit_boot"

    ###################
    #5.  ratio_corrected_by_pairwise_average_intergenic_weighted
    # 
    # DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    # ratio_corrected_by_pairwise_average_intergenic_weighted <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_corrected_by_pairwise_average_intergenic_weighted), statistic = boot_mean, R = ITERATION))) %>% 
    #   dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    #   dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    # names(ratio_corrected_by_pairwise_average_intergenic_weighted)[2] <- "values"
    # ratio_corrected_by_pairwise_average_intergenic_weighted_summary <- ratio_corrected_by_pairwise_average_intergenic_weighted  %>% 
    # group_by_(.dots=GROUP) %>%
    # dplyr::summarise(mean=mean(values),sd=sd(values))  
    # names(ratio_corrected_by_pairwise_average_intergenic_weighted_summary)[2] <- "mean_ratio_corrected_by_pairwise_average_intergenic_weighted_boot"
    # names(ratio_corrected_by_pairwise_average_intergenic_weighted_summary)[3] <- "sd_ratio_corrected_by_pairwise_average_intergenic_weighted_boot"
    # 
    # ###################
    # #6.  ratio_corrected_by_watterson_average_intergenic_weighted
    # 
    # DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP) %>% tidyr::nest()
    # ratio_corrected_by_watterson_average_intergenic_weighted <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_corrected_by_watterson_average_intergenic_weighted), statistic = boot_mean, R = ITERATION))) %>% 
    #   dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    #   dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
    # names(ratio_corrected_by_watterson_average_intergenic_weighted)[2] <- "values"
    # ratio_corrected_by_watterson_average_intergenic_weighted_summary <- ratio_corrected_by_watterson_average_intergenic_weighted  %>% 
    # group_by_(.dots=GROUP) %>%
    # dplyr::summarise(mean=mean(values),sd=sd(values))  
    # names(ratio_corrected_by_watterson_average_intergenic_weighted_summary)[2] <- "mean_ratio_corrected_by_watterson_average_intergenic_weighted_boot"
    # names(ratio_corrected_by_watterson_average_intergenic_weighted_summary)[3] <- "sd_ratio_corrected_by_watterson_average_intergenic_weighted_boot"
    # 
    ###################
    # Agrego los datos
    
    tmp_group <- purrr::reduce(list(ratio_watterson_average_summary, ratio_pairwise_average_summary,
                                    ratio_pairwise_average_corrected_summary,
                                    ratio_watterson_average_corrected_summary), #,
                                    #ratio_corrected_by_pairwise_average_intergenic_weighted_summary,
                                    #ratio_corrected_by_watterson_average_intergenic_weighted_summary), 
                                    full_join, by = GROUP)
    
    POP1=as.character(get(DATAFRAME) %>% select (pop.x) %>% .[1,1])
    POP2=as.character(get(DATAFRAME) %>% select (pop.y) %>% .[1,1])

    
    tmp_group_name <- paste ("ratio_boot",POP1,POP2, GROUP, sep="_")
    
    assign (tmp_group_name, tmp_group,.GlobalEnv)    
    
    ###################
    # Borro tablas antiguas para que no haya confusión 
    
    rm (tmp_group)
    rm (tmp_group_name)
    rm (ratio_watterson_average)
    rm (ratio_pairwise_average)
    rm (ratio_pairwise_average_corrected)
    rm (ratio_watterson_average_corrected)
    #rm (ratio_corrected_by_pairwise_average_intergenic_weighted)
    #rm (ratio_corrected_by_watterson_average_intergenic_weighted)
    rm (ratio_watterson_average_summary)
    rm (ratio_pairwise_average_summary)
    rm (ratio_pairwise_average_corrected_summary)
    rm (ratio_watterson_average_corrected_summary)
    #rm (ratio_corrected_by_pairwise_average_intergenic_weighted_summary)
    #rm (ratio_corrected_by_watterson_average_intergenic_weighted_summary)
    
  }
}



##############################################################################################################
# 
# # Ahora agrupamos por dos caracteristicas a la vez
# 
# all_combinations <- combn(GROUPS, 2)
# 
# 
# for (DATAFRAME in DATAFRAMES) 
# {
#   print (DATAFRAME)
#   for (ITERATION in 1:ncol(all_combinations))
#   { 
#     GROUP1=all_combinations[, ITERATION][1]
#     GROUP2=all_combinations[, ITERATION][2]
#     
#     print (GROUP1)
#     print (GROUP2)
#     # Hacemos un group_by y despues un nest que nos devuelve para cada GROUP una variable en la que está condensada la dataframe.
#     
#     ###################
#     #1.  ratio_watterson_average
#     DATAFRAME_filtered <- get(DATAFRAME) %>%
#       # First I group the data by species 
#       dplyr::group_by_(GROUP1,GROUP2) %>%
#       # Then I nest the dataframe
#       tidyr::nest()
#     
#     ratio_watterson_average <- DATAFRAME_filtered %<>%
#       # Aquí aplicamos el bootstrapping sobre la columna de data (la que tiene la dataframe condensada) concretamente sobre el subset del ratio X.  
#       dplyr::mutate(booted = purrr::map(.x = data, # The list-column containing <S3: tibble>
#                                         ~ boot::boot(data = as.numeric(.x$ratio_watterson_average), # The <S3 tibble> column being sampled
#                                                      statistic = boot_mean, # The user-defined function
#                                                      R = ITERATION))) %>% 
#       # Del resultado de boot creamos una nueva variable con el valor t, que tiene la matriz de longitud igual al numero de iteraciones. 
#       dplyr::mutate(boot_matrix = purrr::map(.x = booted, # The list-column containing <S3 bootci> objects
#                                              ~ .x$t)) %>% 
#       # Eliminamos la columna data (el dataframe original), y también los valores booted (que tienen todos los resultados del bootstraping). Despues desagregamos por el valor de la matriz. 
#       dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix) 
#     # Cambiamos el nombre de la matriz. 
#     names(ratio_watterson_average)[3] <- "values"
#     ratio_watterson_summary <- ratio_watterson_average  %>% 
#       group_by_(.dots=c(GROUP1,GROUP2)) %>%
#       dplyr::summarise(mean=mean(as.numeric(values)),sd=sd(as.numeric(values)))
#     names(ratio_watterson_summary)[3] <- "mean_ratio_watterson_boot"
#     names(ratio_watterson_summary)[4] <- "sd_ratio_watterson_boot"
#     
#     # Hago lo mismo para cada indice.
#     ###################
#     #2.  ratio_pairwise_average
#     
#     DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP1, GROUP2) %>% tidyr::nest()
#     ratio_pairwise_average <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_pairwise_average), statistic = boot_mean, R = ITERATION))) %>% 
#       dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
#       dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
#     names(ratio_pairwise_average)[3] <- "values"
#     ratio_pairwise_average_summary <- ratio_pairwise_average  %>% 
#       group_by_(.dots=c(GROUP1,GROUP2)) %>%
#       dplyr::summarise(mean=mean(values),sd=sd(values))
#     names(ratio_pairwise_average_summary)[3] <- "mean_ratio_pairwise_boot"
#     names(ratio_pairwise_average_summary)[4] <- "sd_ratio_pairwise_boot"
#     
#     ###################
#     #3.  ratio_corrected_by_pairwise_average_intergenic_per_unit
#     
#     DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP1, GROUP2) %>% tidyr::nest()
#     ratio_corrected_by_pairwise_average_intergenic_per_unit <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_corrected_by_pairwise_average_intergenic_per_unit), statistic = boot_mean, R = ITERATION))) %>% 
#       dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
#       dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
#     names(ratio_corrected_by_pairwise_average_intergenic_per_unit)[3] <- "values"
#     ratio_corrected_by_pairwise_average_intergenic_per_unit_summary <- ratio_corrected_by_pairwise_average_intergenic_per_unit  %>% 
#       group_by_(.dots=c(GROUP1,GROUP2)) %>%
#       dplyr::summarise(mean=mean(values),sd=sd(values))    
#     names(ratio_corrected_by_pairwise_average_intergenic_per_unit_summary)[3] <- "mean_ratio_corrected_by_pairwise_average_intergenic_per_unit_boot"
#     names(ratio_corrected_by_pairwise_average_intergenic_per_unit_summary)[4] <- "sd_ratio_corrected_by_pairwise_average_intergenic_per_unit_boot"
#     
#     ###################
#     #4.  ratio_corrected_by_watterson_average_intergenic_per_unit
#     
#     DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP1, GROUP2) %>% tidyr::nest()
#     ratio_corrected_by_watterson_average_intergenic_per_unit <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_corrected_by_watterson_average_intergenic_per_unit), statistic = boot_mean, R = ITERATION))) %>% 
#       dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
#       dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
#     names(ratio_corrected_by_watterson_average_intergenic_per_unit)[3] <- "values"
#     ratio_corrected_by_watterson_average_intergenic_per_unit_summary <- ratio_corrected_by_watterson_average_intergenic_per_unit  %>% 
#       group_by_(.dots=c(GROUP1,GROUP2)) %>%
#       dplyr::summarise(mean=mean(values),sd=sd(values))  
#     names(ratio_corrected_by_watterson_average_intergenic_per_unit_summary)[3] <- "mean_ratio_corrected_by_watterson_average_intergenic_per_unit_boot"
#     names(ratio_corrected_by_watterson_average_intergenic_per_unit_summary)[4] <- "sd_ratio_corrected_by_watterson_average_intergenic_per_unit_boot"
#     
#     # ###################
#     # #5.  ratio_corrected_by_pairwise_average_intergenic_weighted
#     # 
#     # DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP1, GROUP2) %>% tidyr::nest()
#     # ratio_corrected_by_pairwise_average_intergenic_weighted <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_corrected_by_pairwise_average_intergenic_weighted), statistic = boot_mean, R = ITERATION))) %>% 
#     #   dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
#     #   dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
#     # names(ratio_corrected_by_pairwise_average_intergenic_weighted)[3] <- "values"
#     # ratio_corrected_by_pairwise_average_intergenic_weighted_summary <- ratio_corrected_by_pairwise_average_intergenic_weighted  %>% 
#     #   group_by_(.dots=c(GROUP1,GROUP2)) %>%
#     #   dplyr::summarise(mean=mean(values),sd=sd(values))  
#     # names(ratio_corrected_by_pairwise_average_intergenic_weighted_summary)[3] <- "mean_ratio_corrected_by_pairwise_average_intergenic_weighted_boot"
#     # names(ratio_corrected_by_pairwise_average_intergenic_weighted_summary)[4] <- "sd_ratio_corrected_by_pairwise_average_intergenic_weighted_boot"
#     # 
#     # ###################
#     # #6.  ratio_corrected_by_watterson_average_intergenic_weighted
#     # 
#     # DATAFRAME_filtered <- get(DATAFRAME) %>% dplyr::group_by_(GROUP1, GROUP2) %>% tidyr::nest()
#     # ratio_corrected_by_watterson_average_intergenic_weighted <- DATAFRAME_filtered %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$ratio_corrected_by_watterson_average_intergenic_weighted), statistic = boot_mean, R = ITERATION))) %>% 
#     #   dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
#     #   dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
#     # names(ratio_corrected_by_watterson_average_intergenic_weighted)[3] <- "values"
#     # ratio_corrected_by_watterson_average_intergenic_weighted_summary <- ratio_corrected_by_watterson_average_intergenic_weighted  %>% 
#     #   group_by_(.dots=c(GROUP1,GROUP2)) %>%
#     #   dplyr::summarise(mean=mean(values),sd=sd(values))  
#     # names(ratio_corrected_by_watterson_average_intergenic_weighted_summary)[3] <- "mean_ratio_corrected_by_watterson_average_intergenic_weighted_boot"
#     # names(ratio_corrected_by_watterson_average_intergenic_weighted_summary)[4] <- "sd_ratio_corrected_by_watterson_average_intergenic_weighted_boot"
#     # 
#     # ###################
#     # Agrego los datos
#     
#     tmp_group <- purrr::reduce(list(ratio_watterson_summary, 
#                                     ratio_pairwise_average_summary, 
#                                     ratio_corrected_by_pairwise_average_intergenic_per_unit_summary, 
#                                     ratio_corrected_by_watterson_average_intergenic_per_unit_summary),#, 
#                                     #ratio_corrected_by_pairwise_average_intergenic_weighted_summary, 
#                                     #ratio_corrected_by_watterson_average_intergenic_weighted_summary), 
#                                full_join, by = c(GROUP1,GROUP2))
#     
#     tmp_group_name <- paste (DATAFRAME, GROUP1, GROUP2, sep="_")
#     
#     assign (tmp_group_name, tmp_group,.GlobalEnv)    
#     
#     ###################
#     # Borro tablas antiguas para que no haya confusión 
#     
#     rm (tmp_group)
#     rm (tmp_group_name)
#     rm (ratio_watterson_average)
#     rm (ratio_pairwise_average)
#     rm (ratio_corrected_by_pairwise_average_intergenic_per_unit)
#     rm (ratio_corrected_by_watterson_average_intergenic_per_unit)
#     #rm (ratio_corrected_by_pairwise_average_intergenic_weighted)
#     #rm (ratio_corrected_by_watterson_average_intergenic_weighted)
#     rm (ratio_watterson_summary)
#     rm (ratio_pairwise_average_summary)
#     rm (ratio_corrected_by_pairwise_average_intergenic_per_unit_summary)
#     rm (ratio_corrected_by_watterson_average_intergenic_per_unit_summary)
#     #rm (ratio_corrected_by_pairwise_average_intergenic_weighted_summary)
#     #rm (ratio_corrected_by_watterson_average_intergenic_weighted_summary)
#     
#     
#   }
# }



   
```



# ---------------------------------

#### Diversity pop1 vs pop2

```{r}

library(data.table)
library(ggplot2)

# En primer lugar hacemos los density plot de las diversidades para cada población. Como ya los habíamos explorado, vemos que eran bimodales, así que con este código fabrico una tablita que recoge el punto más bajo en ese density plot y lo guarda para usarlo despues como punto de corte. 

# Vamos a intentar sacar el punto más bajo en la distribución de los density plot. 

# Todo esta hecho para watterson

DATAFRAMES=c("c_ll_ki_n013_diversity","c_ll_no_n008_diversity", "c_ll_po_n008_diversity", "c_lp_sm_n019_diversity", "c_lp_do_n012_diversity")

for (DATAFRAME in DATAFRAMES)
{
  
  
POP=get(DATAFRAME) %>% select(pop) %>% mutate(pop=as.character(pop)) %>% .[1,1] 
  
maxY1_position <- which.max(density(log(get(DATAFRAME)$watterson_ave))$y)
maxX1_value <- density(log(get(DATAFRAME)$watterson_ave))$x[maxY1_position] 

maxY_value <- max(density(log(get(DATAFRAME)$watterson_ave))$y[density(log(get(DATAFRAME)$watterson_ave))$x>(maxX1_value+3)])

maxY2_position <- which(density(log(get(DATAFRAME)$watterson_ave))$y == maxY_value)
maxX2_value <- density(log(get(DATAFRAME)$watterson_ave))$x[maxY2_position] 

DensityWatterson.Y <- density(log(get(DATAFRAME)$watterson_ave))$y
DensityWatterson.X <- density(log(get(DATAFRAME)$watterson_ave))$x

minY_value <- min(DensityWatterson.Y[DensityWatterson.X < maxX2_value & DensityWatterson.X > maxX1_value])
minY_position <- which(DensityWatterson.Y == minY_value)
minX_value <- density(log(get(DATAFRAME)$watterson_ave))$x[minY_position] 


ggplot(get(DATAFRAME), aes(log(watterson_ave))) + 
   geom_density() + 
  geom_vline(xintercept = density(log(get(DATAFRAME)$watterson_ave))$x[minY_position]) +
  ggsave(paste0(wd_output, POP,"_density_watterson.pdf"))


assign(paste0(POP,"_density_min_value"), c(POP,minX_value))

}

# Uno las distintas tablas de puntos de corte. 

density_min_values <- as.data.frame(rbind (c_lp_sm_n019_density_min_value,c_lp_do_n012_density_min_value, c_ll_ki_n013_density_min_value, c_ll_po_n008_density_min_value, c_ll_no_n008_density_min_value)) 
names(density_min_values) <- c("pop", "min_density_value")
density_min_values$min_density_value <- as.numeric(as.character(density_min_values$min_density_value))


rm (c_lp_sm_n019_density_min_value)
rm (c_lp_do_n012_density_min_value)
rm (c_ll_ki_n013_density_min_value)
rm (c_ll_po_n008_density_min_value)
rm (c_ll_no_n008_density_min_value) 

```

#####  GOterm enrichment & dataset prep

```{r}


# Ahora vamos a intentar sacar las unidades que quedan por encima de ese minimo en la distribución para ambas poblaciones: serían valores que con alta diversidad en las dos poblaciones. Además queremos que esos valores tengan un ratio similar a uno: tienen alta diveridad y en las dos poblaciones, muy parecida. 

DATAFRAMES=c("data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity", "data_diversity_c_ll_ki_n013_diversity_c_ll_po_n008_diversity", "data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity")

for (DATAFRAME in DATAFRAMES) 
{
  
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  
  min_non_bootleneck_pop_value <- as.numeric(density_min_values %>% filter(pop==POP1) %>% .[1,2] )
  min_bootleneck_pop_value <- as.numeric(density_min_values %>% filter(pop==POP2) %>% .[1,2] )

  ## DATASET GO term enrichment and pathway enrichment
  
  list_of_genes_GOterm <- get(DATAFRAME) %>% filter(., log(watterson_ave.x)>min_non_bootleneck_pop_value & log(watterson_ave.y)>min_bootleneck_pop_value & ratio_watterson_average>0.6 & ratio_watterson_average<1.4 & feature=="CDS") %>% select ( unique_id)
  assign(paste0(POP1, "_", POP2,"_list_of_genes_of_interest_high_diversity_ratio_1_CDS"), list_of_genes_GOterm)
  
  ## DATASET HD  
  
  list_of_genes_HD <- get(DATAFRAME) %>% filter(., log(watterson_ave.x)>min_non_bootleneck_pop_value & log(watterson_ave.y)>min_bootleneck_pop_value) %>% select ( unique_id)
  assign(paste0(POP1, "_", POP2,"_list_of_units_of_interest_HD"), list_of_genes_HD)
  
  ## DATASET LD_W
      
  list_of_genes_LD_W <- get(DATAFRAME) %>% filter(., log(watterson_ave.x)>min_non_bootleneck_pop_value & log(watterson_ave.y)<min_bootleneck_pop_value) %>% select ( unique_id)
  assign(paste0(POP1, "_", POP2,"_list_of_units_of_interest_LD_W"), list_of_genes_LD_W)

######
  # Aqui categorizo las unidades que tienen uan alta diversidad y ni pierden ni ganan diversidad (HD (high diversity)), las unidades que tiene baja diversidad en la non-bottleneck pero ganan en la bottleneck (LD_W (low diversity win)), las que tienen alta diversidad en la non bottleneck pero baja en la bottleneck (HD_L), y las que tienen baja diversidad en ambas (LD). 

  data_diversity_categories <- get(DATAFRAME) %>% 
  mutate (evolution_category=
            ifelse (log(watterson_ave.x)>min_non_bootleneck_pop_value & log(watterson_ave.y)>min_bootleneck_pop_value, "HD",
            ifelse (log(watterson_ave.x)>min_non_bootleneck_pop_value & log(watterson_ave.y)<min_bootleneck_pop_value, "LD_G",
            ifelse (log(watterson_ave.x)<min_non_bootleneck_pop_value & log(watterson_ave.y)<min_bootleneck_pop_value, "LD",
            ifelse (log(watterson_ave.x)<min_non_bootleneck_pop_value & log(watterson_ave.y)>min_bootleneck_pop_value, "HD_L",NA))))) %>% 
  mutate (diversity_category=
            ifelse (log(watterson_ave.y)>min_bootleneck_pop_value, "HD",
            ifelse (log(watterson_ave.y)<min_bootleneck_pop_value, "LD",NA)))

data_diversity_categories$evolution_category <- factor (data_diversity_categories$evolution_category, levels=c("HD_L", "HD", "LD", "LD_G"))
data_diversity_categories$diversity_category <- factor (data_diversity_categories$diversity_category, levels=c("HD", "LD"))

  assign(paste0("data_diversity_",POP1, "_diversity_", POP2,"_diversity_categories"), data_diversity_categories)

  }


# Los uno

# Los que van a servir para hacer GO termn.

list_genes_of_interest_lynx_lynx_high_diversity_ratio_1 <- inner_join(c_ll_ki_n013_c_ll_no_n008_list_of_genes_of_interest_high_diversity_ratio_1_CDS, c_ll_ki_n013_c_ll_po_n008_list_of_genes_of_interest_high_diversity_ratio_1_CDS)

list_genes_of_interest_lynx_lynx_lynx_pardinus_high_diversity_ratio_1 <- inner_join(c_ll_ki_n013_c_ll_no_n008_list_of_genes_of_interest_high_diversity_ratio_1_CDS, c_ll_ki_n013_c_ll_po_n008_list_of_genes_of_interest_high_diversity_ratio_1_CDS) %>% inner_join(., c_lp_sm_n019_c_lp_do_n012_list_of_genes_of_interest_high_diversity_ratio_1_CDS)

write.table(list_genes_of_interest_lynx_lynx_high_diversity_ratio_1, paste0(wd_output,"list_genes_of_interest_lynx_lynx_high_diversity_ratio_1.txt" ), quote = F, row.names = F)

write.table(list_genes_of_interest_lynx_lynx_lynx_pardinus_high_diversity_ratio_1, paste0(wd_output,"list_genes_of_interest_lynx_lynx_lynx_pardinus_high_diversity_ratio_1.txt" ), quote = F, row.names = F)

# Los que son HD en todas las poblaciones.

colnames(c_ll_ki_n013_c_ll_no_n008_list_of_units_of_interest_HD) <- "c_ll_ki_n013_c_ll_no_n008_HD"
colnames(c_ll_ki_n013_c_ll_po_n008_list_of_units_of_interest_HD) <- "c_ll_ki_n013_c_ll_po_n008_HD"
colnames(c_lp_sm_n019_c_lp_do_n012_list_of_units_of_interest_HD) <- "c_lp_sm_n019_c_lp_do_n012_HD"

colnames(c_ll_ki_n013_c_ll_no_n008_list_of_units_of_interest_LD_W) <- "c_ll_ki_n013_c_ll_no_n008_LD_G"
colnames(c_ll_ki_n013_c_ll_po_n008_list_of_units_of_interest_LD_W) <- "c_ll_ki_n013_c_ll_po_n008_LD_G"
colnames(c_lp_sm_n019_c_lp_do_n012_list_of_units_of_interest_LD_W) <- "c_lp_sm_n019_c_lp_do_n012_LD_G"


```


##### Diversity plot pop1 vs pop2

```{r}

# Plot de diversidad de una población frente a otra, con el corte de los valores más bajos en el density plot para ambos casos, y graficamente ploteados esos cortes. 

DATAFRAMES=c("data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity", "data_diversity_c_ll_ki_n013_diversity_c_ll_po_n008_diversity", "data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity")

for (DATAFRAME in DATAFRAMES) 
{
 
  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  
  min_non_bootleneck_pop_value <- as.numeric(density_min_values %>% filter(pop==POP1) %>% .[1,2] )
  min_bootleneck_pop_value <- as.numeric(density_min_values %>% filter(pop==POP2) %>% .[1,2] )

  DATAFRAME_modif <- get(DATAFRAME) %>% mutate (col=ifelse(log(watterson_ave.x)>min_non_bootleneck_pop_value & log(watterson_ave.y)>min_bootleneck_pop_value & ratio_watterson_average>0.6 & ratio_watterson_average<1.4 & feature=="CDS", "interesting_genes", "shit"))

  
   ggplot(data=DATAFRAME_modif, aes(x=log(watterson_ave.y) ,y=log(watterson_ave.x), fill=col, colour=col)) +
       geom_point(alpha = 1/100) +
    geom_abline(intercept = 0) +
    geom_hline(yintercept= min_non_bootleneck_pop_value) +
    geom_vline(xintercept = min_bootleneck_pop_value) +
   facet_wrap(~feature) +
     theme(legend.position="none") 
   # scale_color_manual(values=c("#999999", "#E69F00"))
   ggsave (paste(wd_output,DATAFRAME,"_relation_by_feature_watterson.pdf", sep=""))
   
    ggplot(data=DATAFRAME_modif, aes(x=log(watterson_ave.y) ,y=log(watterson_ave.x), fill=col, colour=col)) +
       geom_point(alpha = 1/100) +
    geom_abline(intercept = 0) +
    geom_hline(yintercept= min_non_bootleneck_pop_value) +
    geom_vline(xintercept = min_bootleneck_pop_value) +
    facet_wrap(~feature, scales = "free" ) +
     theme(legend.position="none") 
   ggsave (paste(wd_output,DATAFRAME,"_relation_by_feature_watterson_scalefree.pdf", sep=""))

} 


# Un pequeño codigo para plotear el density plot al lado de una nube de puntos. 
# #marginal density of x - plot on top
# plot_top <- ggplot(data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity, aes(watterson_ave.y)) + 
#   geom_density(alpha=.5) + 
#   theme(legend.position = "none")
# 
# #marginal density of y - plot on the right
# plot_right <-ggplot(data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity, aes(watterson_ave.x)) + 
#   geom_density(alpha=.5) + 
#   theme(legend.position = "none")
# 
# #arrange the plots together, with appropriate height and width for each row and column
# grid.arrange(plot_top, empty, scatter, plot_right, ncol=2, nrow=2, widths=c(4, 1), heights=c(1, 4))


```


# ---------------------------------

### Plots interacción per unit

#### Categories vs. recombination

```{r}

library(ggpubr)
library("cowplot")


DATAFRAMES=c("data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity_categories", "data_diversity_c_ll_ki_n013_diversity_c_ll_po_n008_diversity_categories", "data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity_categories")


for (DATAFRAME in DATAFRAMES) {

  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  
  sts_HD <- boxplot.stats((get(DATAFRAME)%>% filter (type_chr=="autosomes") %>% filter(diversity_category=="HD"))$divergence)$stats  # Compute lower and upper whisker limits

  HD <- ggboxplot((get(DATAFRAME) %>% filter (type_chr=="autosomes") %>% filter(diversity_category=="HD")) , x = "evolution_category", y = "divergence",
          palette = "jco", outlier.shape = NA) + facet_grid(rows = vars(feature) ) + coord_cartesian(ylim = c(0,max(sts_HD)*1.05)) + stat_compare_means(method="wilcox.test", label="p.signif", label.y = max(sts_HD)-(max(sts_HD)*0.075), label.x=1.5) + theme(strip.text.y = element_text(angle = 0))
 

  sts_LD <- boxplot.stats((get(DATAFRAME)%>% filter (type_chr=="autosomes") %>% filter(diversity_category=="LD"))$divergence)$stats  # Compute lower and upper whisker limits

  LD <- ggboxplot((get(DATAFRAME) %>% filter (type_chr=="autosomes") %>% filter(diversity_category=="LD")) , x = "evolution_category", y = "divergence",
          palette = "jco",  outlier.shape = NA) + facet_grid(rows = vars(feature) ) + coord_cartesian(ylim = c(0,max(sts_LD)*1.05)) + stat_compare_means(method="wilcox.test", label="p.signif", label.y = max(sts_LD)-(max(sts_LD)*0.075), label.x=1.5) +  scale_y_continuous(position = "right") + theme(strip.background = element_blank(),strip.text.y = element_blank())

HD_LD <- ggdraw() +
  draw_plot(LD, x = .6, y = 0, width = 0.4, height = 1) +
  draw_plot(HD, x = 0, y = 0, width = .55, height = 1)

save_plot(paste(wd_output,POP1,"_",POP2,"_diverg_by_category.pdf",sep=""), HD_LD, ncol=2, nrow=5)
}
   # # Los dos juntos
   #  my_comparisons <- list( c("HD_L", "HD"), c("LD", "LD_G"))
   # 
   # Significance_values_position <-ifelse ( max(sts_LD)>=max(sts_HD), max(sts_LD)-(max(sts_LD)*0.075) , max(sts_HD)-(max(sts_HD)*0.075))
   # 
   # ggboxplot((get(DATAFRAME) %>% filter (type_chr=="autosomes")) , x = "evolution_category", y = "divergence",
   #        palette = "jco",  outlier.shape = NA) + facet_grid(rows = vars(feature) ) + coord_cartesian(ylim = c(0,max(sts_LD)*1.05)) + stat_compare_means(comparisons = my_comparisons, method="wilcox.test", label="p.signif", label.y = Significance_values_position) +theme(panel.spacing = unit(0.5, 'lines'), 
   #       strip.text.y = element_text(angle = 0))
   # 
   # 
   #      ggboxplot((get(DATAFRAME) %>% filter (type_chr=="autosomes")) , x = "evolution_category", y = "divergence",
   #        palette = "jco",  outlier.shape = NA) + facet_wrap(~feature, strip.position="top", ncol=1 ) + coord_cartesian(ylim = c(0,max(sts_LD)*1.05)) + stat_compare_means(comparisons = my_comparisons, method="wilcox.test", label="p.signif", label.y = Significance_values_position) 

   
   


for (DATAFRAME in DATAFRAMES) {

  POP1=get(DATAFRAME) %>% select(pop.x) %>% mutate(pop.x=as.character(pop.x)) %>% .[1,1] 
  POP2=get(DATAFRAME) %>% select(pop.y) %>% mutate(pop.y=as.character(pop.y)) %>% .[1,1] 
  
  sts_HD <- boxplot.stats((get(DATAFRAME)%>% filter (type_chr=="autosomes") %>% filter(diversity_category=="HD"))$recombination_rate)$stats  # Compute lower and upper whisker limits

  HD <- ggboxplot((get(DATAFRAME) %>% filter (type_chr=="autosomes") %>% filter(diversity_category=="HD")) , x = "evolution_category", y = "recombination_rate",
          palette = "jco", outlier.shape = NA) + facet_grid(rows = vars(feature) ) + coord_cartesian(ylim = c(0,max(sts_HD)*1.05)) + stat_compare_means(method="wilcox.test", label="p.signif", label.y = max(sts_HD)-(max(sts_HD)*0.075), label.x=1.5) + theme(strip.text.y = element_text(angle = 0))
 

  sts_LD <- boxplot.stats((get(DATAFRAME)%>% filter (type_chr=="autosomes") %>% filter(diversity_category=="LD"))$recombination_rate)$stats  # Compute lower and upper whisker limits

  LD <- ggboxplot((get(DATAFRAME) %>% filter (type_chr=="autosomes") %>% filter(diversity_category=="LD")) , x = "evolution_category", y = "recombination_rate",
          palette = "jco",  outlier.shape = NA) + facet_grid(rows = vars(feature) ) + coord_cartesian(ylim = c(0,max(sts_LD)*1.05)) + stat_compare_means(method="wilcox.test", label="p.signif", label.y = max(sts_LD)-(max(sts_LD)*0.075), label.x=1.5) +  scale_y_continuous(position = "right") + theme(strip.background = element_blank(),strip.text.y = element_blank())

HD_LD <- ggdraw() +
  draw_plot(LD, x = .6, y = 0, width = 0.4, height = 1) +
  draw_plot(HD, x = 0, y = 0, width = .55, height = 1)

save_plot(paste(wd_output,POP1,"_",POP2,"_recomb_by_category.pdf",sep=""), HD_LD, ncol=2, nrow=5)
}
```







#### Ratio vs. divergence

Exploro el ratio de ganancia vs. la tasa de divergencia, para ver si las zonas con más divergencia ganan mas diversidad. 


```{r}

INDEXES=c("ratio_pairwise_average", "ratio_watterson_average")

DATAFRAMES=c("data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity", "data_diversity_c_ll_ki_n013_diversity_c_ll_po_n008_diversity", "data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity")

# Plot de los valores de divergencia con logaritmo frente a la diversidad. 

for (DATAFRAME in DATAFRAMES)
{
for (INDEX in INDEXES)
  {

  NAME_POP1 <- as.character(get(DATAFRAME) %>% select (pop.x) %>% .[1,1])
  NAME_POP2 <- as.character(get(DATAFRAME) %>% select (pop.y) %>% .[1,1])

ggplot(get(DATAFRAME) %>% filter(chr!="chrX"), aes_string("divergence", sprintf("log(%s)", INDEX))) + 
  geom_point() + 
  facet_grid(~feature)+
  geom_smooth(method = "lm")
    ggsave(paste (wd_output,NAME_POP1,"_",NAME_POP2,"_diverg_vs_",INDEX,".pdf", sep="" ))
}
  }
    
    

```

#### Ratio vs. recombination

Exploro el ratio de ganancia vs. la recombination rate, para ver si las zonas con más recombinación ganan menos diversidad que zonas con más baja recombinación. 

```{r}

INDEXES=c("ratio_pairwise_average", "ratio_watterson_average")

DATAFRAMES=c("data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity", "data_diversity_c_ll_ki_n013_diversity_c_ll_po_n008_diversity", "data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity")

# Plot de los valores de recombinación con logaritmo frente a la diversidad. 

for (DATAFRAME in DATAFRAMES)
{
for (INDEX in INDEXES)
  {

  NAME_POP1 <- as.character(get(DATAFRAME) %>% select (pop.x) %>% .[1,1])
  NAME_POP2 <- as.character(get(DATAFRAME) %>% select (pop.y) %>% .[1,1])

ggplot(get(DATAFRAME) %>% filter(chr!="chrX"), aes_string("recombination_rate", sprintf("log(%s)", INDEX))) + 
  geom_point() + 
  facet_grid(~feature)+
  geom_smooth(method = "lm")
    ggsave(paste (wd_output,NAME_POP1,"_",NAME_POP2,"_recomb_vs_",INDEX,".pdf", sep="" ), device="pdf")

ggplot(get(DATAFRAME) %>% filter(chr!="chrX"), aes_string("recombination_rate", sprintf("log(%s)", INDEX))) + 
  geom_point() + 
  facet_grid(~feature)+
  geom_smooth(method = "lm")
    ggsave(paste (wd_output,NAME_POP1,"_",NAME_POP2,"_recomb_vs_",INDEX,".pdf", sep="" ), device="pdf")
}
  }
    
    
# Boxplot de recombinación por categorías frente a diversidad.

for (DATAFRAME in DATAFRAMES)
  {
  
  NAME_POP1 <- as.character(get(DATAFRAME) %>% select (pop.x) %>% .[1,1])
  NAME_POP2 <- as.character(get(DATAFRAME) %>% select (pop.y) %>% .[1,1])

# Compute boxplot statistics to rm outliers
sts <- boxplot.stats(get(DATAFRAME)$ratio_pairwise_average)$stats  # Compute lower and upper whisker limits
# Now to achieve full expanded view of the multiple boxplots, it is useful to modify the y-axis limit of the plot inside coord_cartesian() function as below,

ggplot(get(DATAFRAME) %>% filter(!is.na(recombination_category)), aes_string("recombination_category", "ratio_pairwise_average"))+
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(ylim = c(sts[2]/2,max(sts)*1.05)) +
  facet_grid(~feature) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
ggsave(paste (wd_output,NAME_POP1,"_",NAME_POP2,"_recomb_vs_ratio_pairwise_average_boxplot.pdf", sep="" ), device="pdf")

# Compute boxplot statistics to rm outliers
sts <- boxplot.stats(get(DATAFRAME)$ratio_watterson_average)$stats  # Compute lower and upper whisker limits
# Now to achieve full expanded view of the multiple boxplots, it is useful to modify the y-axis limit of the plot inside coord_cartesian() function as below,

ggplot(get(DATAFRAME) %>% filter(!is.na(recombination_category)), aes_string("recombination_category", "ratio_watterson_average"))+
  geom_boxplot(outlier.shape = NA) +
  coord_cartesian(ylim = c(sts[2]/2,max(sts)*1.05)) +
  facet_grid(~feature)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggsave(paste (wd_output,NAME_POP1,"_",NAME_POP2,"_recomb_vs_ratio_watterson_average_boxplot.pdf", sep="" ), device="pdf")

}


# Voy a hacer un lm

library("lme4")


ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_ll_ki_n013_c_ll_po_n008_diversity <- lmList(log(ratio_pairwise_average_corrected) ~ recombination_rate | feature, data_diversity_c_ll_ki_n013_diversity_c_ll_po_n008_diversity)

sink(paste (wd_output,"lm_ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_per_feature_c_ll_ki_n013_c_ll_po_n008.txt"))
print(summary(ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_ll_ki_n013_c_ll_po_n008_diversity))
sink()

ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_ll_ki_n013_c_ll_no_n008_diversity <- lmList(log(ratio_pairwise_average_corrected) ~ recombination_rate | feature, data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity)

sink(paste (wd_output,"lm_ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_per_feature_c_ll_ki_n013_c_ll_no_n008.txt"))
print(summary(ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_ll_ki_n013_c_ll_no_n008_diversity))
sink()

ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_lp_sm_n019_c_lp_do_n012_diversity  <- lmList(log(ratio_pairwise_average_corrected) ~ recombination_rate | feature, data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity)

sink(paste (wd_output,"lm_ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_per_feature_c_lp_sm_n019_c_lp_do_n012.txt"))
print(summary(ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_lp_sm_n019_c_lp_do_n012_diversity))
sink()


```


#### Venh-diagram

Sobre estas tablas que acabo de crear donde están TODAS las unidades y el ratio entre par de poblaciones, voy a sacar todas las unidades con un ratio mayor que uno y voy a hacer un diagrama de Venh. 


Ojo!

Tengo que copiarlas a la terminal y de ahí guardarlas a mano. 


```{r}

# https://stackoverflow.com/questions/8713994/venn-diagram-proportional-and-color-shading-with-semi-transparency
# https://rstudio-pubs-static.s3.amazonaws.com/13301_6641d73cfac741a59c0a851feb99e98b.html
# Al final uso --> https://www.r-bloggers.com/working-with-venn-diagrams/

library(VennDiagram)

# All features:

c_ll_ki_n013_c_ll_no_n008list_of_units_of_interest_HD_list <- lapply(as.list(c_ll_ki_n013_c_ll_no_n008list_of_units_of_interest_HD), function(x) x[x != ""])
c_ll_ki_n013_c_ll_po_n008list_of_units_of_interest_HD_list <- lapply(as.list(c_ll_ki_n013_c_ll_po_n008list_of_units_of_interest_HD), function(x) x[x != ""])
c_lp_sm_n019_c_lp_do_n012list_of_units_of_interest_HD_list <- lapply(as.list(c_lp_sm_n019_c_lp_do_n012list_of_units_of_interest_HD), function(x) x[x != ""])

list_units_of_interest_lynx_lynx_lynx_pardinus_HD <- c(c_ll_ki_n013_c_ll_no_n008list_of_units_of_interest_HD_list, c_ll_ki_n013_c_ll_po_n008list_of_units_of_interest_HD_list, c_lp_sm_n019_c_lp_do_n012list_of_units_of_interest_HD_list)


c_ll_ki_n013_c_ll_no_n008list_of_units_of_interest_LD_W_list <- lapply(as.list(c_ll_ki_n013_c_ll_no_n008list_of_units_of_interest_LD_W), function(x) x[x != ""])
c_ll_ki_n013_c_ll_po_n008list_of_units_of_interest_LD_W_list <- lapply(as.list(c_ll_ki_n013_c_ll_po_n008list_of_units_of_interest_LD_W), function(x) x[x != ""])
c_lp_sm_n019_c_lp_do_n012list_of_units_of_interest_LD_W_list <- lapply(as.list(c_lp_sm_n019_c_lp_do_n012list_of_units_of_interest_LD_W), function(x) x[x != ""])

list_units_of_interest_lynx_lynx_lynx_pardinus_LD_W <- c(c_ll_ki_n013_c_ll_no_n008list_of_units_of_interest_LD_W_list, c_ll_ki_n013_c_ll_po_n008list_of_units_of_interest_LD_W_list, c_lp_sm_n019_c_lp_do_n012list_of_units_of_interest_LD_W_list)


# Now we can plot a Venn diagram with the VennDiagram R package, as follows:


VENN.LIST <- list_units_of_interest_lynx_lynx_lynx_pardinus_HD
venn.plot <- venn.diagram(VENN.LIST , 
                          filename = NULL,
                          scaled = TRUE,
                          fill=c("palegreen", "steelblue1", "pink"), 
                          lty = "blank", 
                          cex = 1,
                          alpha=c(0.3,0.3, 0.3), 
                          cat.fontface=4, main="Genes with HD bootleneck & non bootleneck")





# To plot the venn diagram we will use the grid.draw() function to plot the venn diagram
grid.draw(venn.plot)

VENN.LIST <- list_units_of_interest_lynx_lynx_lynx_pardinus_LD_W
venn.plot <- venn.diagram(VENN.LIST , 
                          filename = NULL,
                          scaled = TRUE,
                          fill=c("palegreen", "steelblue1", "pink"), 
                          lty = "blank", 
                          cex = 1,
                          alpha=c(0.3,0.3, 0.3), 
                          cat.fontface=4, main="Genes with gain in diversity in bootleneck vs non bootleneck")





# To plot the venn diagram we will use the grid.draw() function to plot the venn diagram
grid.draw(venn.plot)


```


#### Boxplot ratio per unit

No corro esto porque creo que NO es útil.
Lo que representa es el boxplot de los ratios y se ve que hay algunos valores muy extremos. 

Los ratios que voy a representar son:
"ratio_pairwise_average", "ratio_watterson_average", "ratio_corrected_by_pairwise_average_intergenic_per_unit", "ratio_corrected_by_watterson_average_intergenic_per_unit"
No estoy haciendo esta vez: 
"ratio_corrected_by_pairwise_average_intergenic_weighted", "ratio_corrected_by_watterson_average_intergenic_weighted"
Primero los voy a representar en boxplot para chr, feature, y región , luego voy a hacer una tabla con la media de los ratios y su bootstrap. 

```{r}

library(rlang)
# Ratio de la diversidad población bootleneck frente non bootleneck
## BOXPLOT

DATAFRAMES=c("data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity", "data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity", "data_diversity_c_lp_sm_n019_autosomes_diversity_c_lp_do_n012_autosomes_diversity")

INDICES=c("ratio_watterson_average", "ratio_pairwise_average")

GROUPS=c("feature", "chr")


myplot <- function(data, title){
  for (INDEX in INDICES){
    for (GROUP in GROUPS){
  pdf(paste(wd_output, "boxplot_violin_plot/",title,"_",GROUP,"_",INDEX,"_boxplot.pdf", sep=""))
  plot <- ggplot(data=data, aes_string(x=GROUP, y = INDEX)) +
        geom_boxplot() +
        #scale_y_continuous(trans = 'log10') +
        theme_bw() +  #theme selection for background and lines
        theme(axis.line.x = element_line(color="black", size = 0.5),
              axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1))+
  labs(title = paste (title,  sep=""))
  print (plot)
  dev.off()
}}}



myplot2 <- function(data, title){
  for (INDEX in INDICES){
    for (GROUP in GROUPS){
  pdf(paste(wd_output, "boxplot_violin_plot/",title,"_",GROUP,"_",INDEX,"_violin.pdf", sep=""))
  plot <- ggplot(data=data, aes_string(x=GROUP, y = INDEX)) +
        geom_violin() +
        #scale_y_continuous(trans = 'log10') +
        theme_bw() +  #theme selection for background and lines
        theme(axis.line.x = element_line(color="black", size = 0.5),
              axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1))+
  labs(title = paste (title, sep=""))
  print (plot)
  dev.off()
}}}



for(i in DATAFRAMES){
  print(myplot(get(i), i))
  print(myplot2(get(i), i))

}


```


#### 3D Plot divergence and recombination vs ratio

```{r}
library(plotly)

# data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity

plot_ly(x=filter(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity,feature=="UCNE")$divergence,
        y=filter(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity,feature=="UCNE")$recombination_rate,
        z=filter(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity,feature=="UCNE")$ratio_watterson_average)


plot_ly(x=data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity$divergence,
        y=data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity$recombination_rate,
        z=data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity$ratio_watterson_average, 
        color = ~data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_no_n008_autosomes_diversity$feature, 
        mode = "markers",marker=list(opacity=0.5))
```

####  Plot boot data for each group

No lo hago

```{r}

library(rlang)

DATAFRAMES=c("ratio_boot_c_ll_ki_n013_c_ll_no_n008_feature", "ratio_boot_c_ll_ki_n013_c_ll_po_n008_feature", "ratio_boot_c_lp_sm_n019_c_lp_do_n012_feature") 

# "ratio_boot_c_ll_ki_n013_c_ll_no_n008_chr", "ratio_boot_c_ll_ki_n013_c_ll_po_n008_chr", "ratio_boot_c_lp_sm_n019_c_lp_do_n012_chr",  "ratio_boot_c_ll_ki_n013_c_ll_no_n008_region", "ratio_boot_c_ll_ki_n013_c_ll_po_n008_region", "ratio_boot_c_lp_sm_n019_c_lp_do_n012_region") 

INDICES=c("ratio_watterson_boot", "ratio_pairwise_boot")




myplot3 <- function(data,title){
  for (INDEX in INDICES)
  {
    print (INDEX)
  pdf(paste(wd_output,title,"_",INDEX,".pdf", sep=""))
  plot <- ggplot(data=data, aes_string(x=colnames(data)[1],y=paste("mean_",INDEX,sep=""), fill="chr_type", colour="chr_type")) +
        geom_point() +
        geom_errorbar(aes_string(ymin=paste("mean_",INDEX,"-sd_",INDEX,sep=""), ymax=paste("mean_",INDEX,"+sd_",INDEX,sep=""))) +
        #scale_y_continuous(trans = 'log10') +
        theme_bw() +  #theme selection for background and lines
        theme(axis.line.x = element_line(color="black", size = 0.5),
              axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1))
  # labs(title = paste (title, "scale_y_transformed", sep=""))
  print (plot)
  dev.off() 
    
  }
}


for(i in DATAFRAMES){
  print(myplot3(get(i), i))
}


```
# -----------------


### Global

Ahora hago el ratio de las medias.

```{r}

# Saco las tablas para cada población y añado una columna en la que corrijo por la media de pairwise. 


POPS=c("c_ll_ki_n013","c_ll_no_n008","c_ll_po_n008", "c_lp_do_n012", "c_lp_sm_n019")

# Feature
for (POP in POPS)
{print (POP)
    data.frame <-  stats_df_pop_feature  %>%  filter (pop==as.character(POP))
    assign(paste(POP,"_stats_feature", sep=""), data.frame)
  rm (data.frame)}

# Chr
for (POP in POPS)
{print (POP)
    data.frame <-  stats_df_pop_chr  %>%  filter (pop==as.character(POP))
    assign(paste(POP,"_stats_chr", sep=""), data.frame)
  rm (data.frame)}

# Region
for (POP in POPS)
{print (POP)
    data.frame <-  stats_df_pop_region  %>%  filter (pop==as.character(POP))
    assign(paste(POP,"_stats_region", sep=""), data.frame)
  rm (data.frame)}


## INTERACCION
# Feature - chr
for (POP in POPS)
{print (POP)
    data.frame <-  stats_df_pop_feature_chr  %>%  filter (pop==as.character(POP))
    assign(paste(POP,"_stats_feature_chr", sep=""), data.frame)
  rm (data.frame)}

# Feature - region
for (POP in POPS)
{ print (POP)
    data.frame <-  stats_df_pop_feature_region  %>%  filter (pop==as.character(POP))
    assign(paste(POP,"_stats_feature_region", sep=""), data.frame)
  rm (data.frame)}

# Region - chr
for (POP in POPS)
{print (POP)
    data.frame <-  stats_df_pop_region_chr  %>%  filter (pop==as.character(POP))
    assign(paste(POP,"_stats_region_chr", sep=""), data.frame)
  rm (data.frame)}

```

Sobre la de stats de cada población. ¡¡Es el ratio de las medias!!!


#### Median

```{r}

### FEATURE ###

# Calculo el ratio para la mediana:

bootleneck_vs_non_bootleneck_ratio_median_feature <- function (dataframe_POP1, dataframe_POP2, name_POP1, name_POP2){
  
  # Nombre de las poblaciones
  
  POP1=as.character(as.data.frame(dataframe_POP1) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
  POP2=as.character(as.data.frame(dataframe_POP2) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
   
  # Valor para intergénico de la población --> autosomes.
  
  autosomes_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
    autosomes_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic))  
  
  # Valor para intergénico de la población --> chrX.

  chrX_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
    chrX_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic))  
  
  
  # Calculo de los ratios globales.
  
  ratio_averages_POP1_POP2 <- full_join ( select ( dataframe_POP1, pop, feature, total_count, median_pairwise_ave, median_watterson_ave,  type_chr), 
                                          select ( dataframe_POP2, pop, feature, total_count, median_pairwise_ave, median_watterson_ave,  type_chr), 
                                          by=c("feature", "type_chr")) %>% 
    
    mutate (ratio_median_pairwise = median_pairwise_ave.y/median_pairwise_ave.x) %>% 
    mutate (ratio_median_watterson = median_watterson_ave.y/median_watterson_ave.x) %>% 
    
    mutate (ratio_median_pairwise_corrected = ifelse(type_chr=="autosomes",                  (median_pairwise_ave.y/autosomes_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/autosomes_pairwise_average_intergenic_per_unit_pop1_median), 
(median_pairwise_ave.y/chrX_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/chrX_pairwise_average_intergenic_per_unit_pop1_median))) %>% 
  
    mutate (ratio_median_watterson_corrected = ifelse(type_chr=="autosomes",                  (median_watterson_ave.y/autosomes_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/autosomes_watterson_average_intergenic_per_unit_pop1_median), 
(median_watterson_ave.y/chrX_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/chrX_watterson_average_intergenic_per_unit_pop1_median)))

  
  dataframename <- paste ("ratio_median", name_POP1, name_POP2,  sep="_")
  assign (dataframename, ratio_averages_POP1_POP2,.GlobalEnv)
}


# Create data frame

# Dataframe Kirov-Norway

bootleneck_vs_non_bootleneck_ratio_median_feature(c_ll_ki_n013_stats_feature,c_ll_no_n008_stats_feature, deparse(substitute(c_ll_ki_n013_stats_feature)),deparse(substitute(c_ll_no_n008_stats_feature)))

write.table(ratio_median_c_ll_ki_n013_stats_feature_c_ll_no_n008_stats_feature, paste(wd_output,"ratio_median_autosomes_feature_c_ll_ki_n013_c_ll_no_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


# Dataframe Kirov-Poland

bootleneck_vs_non_bootleneck_ratio_median_feature(c_ll_ki_n013_stats_feature,c_ll_po_n008_stats_feature, deparse(substitute(c_ll_ki_n013_stats_feature)),deparse(substitute(c_ll_po_n008_stats_feature)))
write.table(ratio_median_c_ll_ki_n013_stats_feature_c_ll_po_n008_stats_feature, paste(wd_output,"ratio_median_autosomes_feature_c_ll_ki_n013_c_ll_po_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


# Dataframe Sierra_Morena-Doñana

bootleneck_vs_non_bootleneck_ratio_median_feature(c_lp_sm_n019_stats_feature, c_lp_do_n012_stats_feature, deparse(substitute(c_lp_sm_n019_stats_feature)),deparse(substitute(c_lp_do_n012_stats_feature)))
write.table(ratio_median_c_lp_sm_n019_stats_feature_c_lp_do_n012_stats_feature, paste(wd_output,"ratio_median_autosomes_feature_c_lp_sm_n019_c_lp_do_n012.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

###############################

### REGION ###

# Calculo el ratio para la media:

bootleneck_vs_non_bootleneck_ratio_median_region <- function(dataframe_POP1, dataframe_POP2, name_POP1, name_POP2){
  
  # Nombre de las poblaciones
  
  POP1=as.character(as.data.frame(dataframe_POP1) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
  POP2=as.character(as.data.frame(dataframe_POP2) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
   
  # Valor para intergénico de la población --> autosomes.
  
  autosomes_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
    autosomes_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic))  
  
  # Valor para intergénico de la población --> chrX.

  chrX_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
    chrX_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic)) 
  
  
  # Calculo de los ratios globales.
  
  ratio_averages_POP1_POP2 <- full_join ( select ( dataframe_POP1, pop, region, total_count, median_pairwise_ave, median_watterson_ave,  type_chr), 
                                          select ( dataframe_POP2, pop, region, total_count, median_pairwise_ave, median_watterson_ave,  type_chr), 
                                          by=c("region", "type_chr"))  %>% 
    
    
 mutate (ratio_median_pairwise = median_pairwise_ave.y/median_pairwise_ave.x) %>% 
    mutate (ratio_median_watterson = median_watterson_ave.y/median_watterson_ave.x) %>% 
    
    mutate (ratio_median_pairwise_corrected = ifelse(type_chr=="autosomes",                  (median_pairwise_ave.y/autosomes_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/autosomes_pairwise_average_intergenic_per_unit_pop1_median), 
(median_pairwise_ave.y/chrX_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/chrX_pairwise_average_intergenic_per_unit_pop1_median))) %>% 
  
    mutate (ratio_median_watterson_corrected = ifelse(type_chr=="autosomes",                  (median_watterson_ave.y/autosomes_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/autosomes_watterson_average_intergenic_per_unit_pop1_median), 
(median_watterson_ave.y/chrX_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/chrX_watterson_average_intergenic_per_unit_pop1_median)))

  
  dataframename <- paste ("ratio_median", name_POP1, name_POP2,  sep="_")
  assign (dataframename, ratio_averages_POP1_POP2,.GlobalEnv)

}

# Create data frame

# Dataframe Kirov-Norway

bootleneck_vs_non_bootleneck_ratio_median_region(c_ll_ki_n013_stats_region,c_ll_no_n008_stats_region, deparse(substitute(c_ll_ki_n013_stats_region)),deparse(substitute(c_ll_no_n008_stats_region)))
write.table(ratio_median_c_ll_ki_n013_stats_region_c_ll_no_n008_stats_region, paste(wd_output,"ratio_median_autosomes_region_c_ll_ki_n013_c_ll_no_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

# Dataframe Kirov-Poland

bootleneck_vs_non_bootleneck_ratio_median_region(c_ll_ki_n013_stats_region,c_ll_po_n008_stats_region, deparse(substitute(c_ll_ki_n013_stats_region)),deparse(substitute(c_ll_po_n008_stats_region)))
write.table(ratio_median_c_ll_ki_n013_stats_region_c_ll_po_n008_stats_region, paste(wd_output,"ratio_median_autosomes_region_c_ll_ki_n013_c_ll_po_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


# Dataframe Sierra_Morena-Doñana

bootleneck_vs_non_bootleneck_ratio_median_region(c_lp_sm_n019_stats_region, c_lp_do_n012_stats_region, deparse(substitute(c_lp_sm_n019_stats_region)),deparse(substitute(c_lp_do_n012_stats_region)))
write.table(ratio_median_c_lp_sm_n019_stats_region_c_lp_do_n012_stats_region, paste(wd_output,"ratio_median_autosomes_region_c_lp_sm_n019_c_lp_do_n012.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

###############################

### chr ###

# Calculo el ratio para la media:

bootleneck_vs_non_bootleneck_ratio_median_chr <- function(dataframe_POP1, dataframe_POP2, name_POP1, name_POP2){
  
  # Nombre de las poblaciones
  
  POP1=as.character(as.data.frame(dataframe_POP1) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
  POP2=as.character(as.data.frame(dataframe_POP2) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
   
  # Valor para intergénico de la población --> autosomes.
  
  autosomes_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
    autosomes_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic))  
  
  # Valor para intergénico de la población --> chrX.

  chrX_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
    chrX_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic)) 
  
  
  # Calculo de los ratios globales.
  
  ratio_averages_POP1_POP2 <- full_join ( select ( dataframe_POP1, pop, chr, total_count, median_pairwise_ave, median_watterson_ave), 
                                          select ( dataframe_POP2, pop, chr, total_count, median_pairwise_ave, median_watterson_ave), 
                                          by=c("chr"))  %>% 
    
    
 mutate (ratio_median_pairwise = median_pairwise_ave.y/median_pairwise_ave.x) %>% 
    mutate (ratio_median_watterson = median_watterson_ave.y/median_watterson_ave.x) %>% 
    
    mutate (ratio_median_pairwise_corrected = ifelse (chr!="chrX",                  (median_pairwise_ave.y/autosomes_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/autosomes_pairwise_average_intergenic_per_unit_pop1_median), 
(median_pairwise_ave.y/chrX_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/chrX_pairwise_average_intergenic_per_unit_pop1_median))) %>% 
  
    mutate (ratio_median_watterson_corrected = ifelse (chr!="chrX",                  (median_watterson_ave.y/autosomes_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/autosomes_watterson_average_intergenic_per_unit_pop1_median), 
(median_watterson_ave.y/chrX_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/chrX_watterson_average_intergenic_per_unit_pop1_median)))

  
  dataframename <- paste ("ratio_median", name_POP1, name_POP2,  sep="_")
  assign (dataframename, ratio_averages_POP1_POP2,.GlobalEnv)

}

# Create data frame

# Dataframe Kirov-Norway
bootleneck_vs_non_bootleneck_ratio_median_chr(c_ll_ki_n013_stats_chr,c_ll_no_n008_stats_chr, deparse(substitute(c_ll_ki_n013_stats_chr)),deparse(substitute(c_ll_no_n008_stats_chr)))
write.table(ratio_median_c_ll_ki_n013_stats_chr_c_ll_no_n008_stats_chr, paste(wd_output,"ratio_median_autosomes_chr_c_ll_ki_n013_c_ll_no_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


# Dataframe Kirov-Poland
bootleneck_vs_non_bootleneck_ratio_median_chr(c_ll_ki_n013_stats_chr,c_ll_po_n008_stats_chr, deparse(substitute(c_ll_ki_n013_stats_chr)),deparse(substitute(c_ll_po_n008_stats_chr)))
write.table(ratio_median_c_ll_ki_n013_stats_chr_c_ll_po_n008_stats_chr, paste(wd_output,"ratio_median_autosomes_chr_c_ll_ki_n013_c_ll_po_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

# Dataframe Sierra_Morena-Doñana
bootleneck_vs_non_bootleneck_ratio_median_chr(c_lp_sm_n019_stats_chr, c_lp_do_n012_stats_chr, deparse(substitute(c_lp_sm_n019_stats_chr)),deparse(substitute(c_lp_do_n012_stats_chr)))
write.table(ratio_median_c_lp_sm_n019_stats_chr_c_lp_do_n012_stats_chr, paste(wd_output,"ratio_median_autosomes_chr_c_lp_sm_n019_c_lp_do_n012.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


############## INTERACCIONES ################

### FEATURE - CHR ###

# Calculo el ratio para la mediana:

bootleneck_vs_non_bootleneck_ratio_median_feature_chr <- function(dataframe_POP1, dataframe_POP2, name_POP1, name_POP2){
  
  # Nombre de las poblaciones
  
  POP1=as.character(as.data.frame(dataframe_POP1) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
  POP2=as.character(as.data.frame(dataframe_POP2) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
   
  # Valor para intergénico de la población --> autosomes.
  
  autosomes_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
  autosomes_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic))  
  
  # Valor para intergénico de la población --> chrX.

  chrX_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
  chrX_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic)) 
  
  
  # Calculo de los ratios globales.
  
  ratio_averages_POP1_POP2 <- full_join ( select ( dataframe_POP1, feature, pop, chr, total_count, median_pairwise_ave, median_watterson_ave), 
                                          select ( dataframe_POP2, feature, pop, chr, total_count, median_pairwise_ave, median_watterson_ave), 
                                          by=c("chr", "feature")) %>% 
    
    
    mutate (ratio_median_pairwise = median_pairwise_ave.y/median_pairwise_ave.x) %>% 
    mutate (ratio_median_watterson = median_watterson_ave.y/median_watterson_ave.x) %>% 
    
    mutate (ratio_median_pairwise_corrected = ifelse(chr!="chrX",  
(median_pairwise_ave.y/autosomes_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/autosomes_pairwise_average_intergenic_per_unit_pop1_median), (median_pairwise_ave.y/chrX_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/chrX_pairwise_average_intergenic_per_unit_pop1_median))) %>% 
  
    mutate (ratio_median_watterson_corrected = ifelse(chr!="chrX",                  (median_watterson_ave.y/autosomes_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/autosomes_watterson_average_intergenic_per_unit_pop1_median), 
(median_watterson_ave.y/chrX_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/chrX_watterson_average_intergenic_per_unit_pop1_median)))

  
  dataframename <- paste ("ratio_median", name_POP1, name_POP2,  sep="_")
  assign (dataframename, ratio_averages_POP1_POP2,.GlobalEnv)
  
}

# Create data frame

# Dataframe Kirov-Norway

bootleneck_vs_non_bootleneck_ratio_median_feature_chr(c_ll_ki_n013_stats_feature_chr,c_ll_no_n008_stats_feature_chr, deparse(substitute(c_ll_ki_n013_stats_feature_chr)),deparse(substitute(c_ll_no_n008_stats_feature_chr)))
write.table(ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_no_n008_stats_feature_chr, paste(wd_output,"ratio_median_autosomes_feature_chr_c_ll_ki_n013_c_ll_no_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


# Dataframe Kirov-Poland

bootleneck_vs_non_bootleneck_ratio_median_feature_chr(c_ll_ki_n013_stats_feature_chr,c_ll_po_n008_stats_feature_chr, deparse(substitute(c_ll_ki_n013_stats_feature_chr)),deparse(substitute(c_ll_po_n008_stats_feature_chr)))
write.table(ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_po_n008_stats_feature_chr, paste(wd_output,"ratio_median_autosomes_feature_chr_c_ll_ki_n013_c_ll_po_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


# Dataframe Sierra_Morena-Doñana

bootleneck_vs_non_bootleneck_ratio_median_feature_chr(c_lp_sm_n019_stats_feature_chr, c_lp_do_n012_stats_feature_chr, deparse(substitute(c_lp_sm_n019_stats_feature_chr)),deparse(substitute(c_lp_do_n012_stats_feature_chr)))
write.table(ratio_median_c_lp_sm_n019_stats_feature_chr_c_lp_do_n012_stats_feature_chr, paste(wd_output,"ratio_median_autosomes_feature_chr_c_lp_sm_n019_c_lp_do_n012.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )


### FEATURE - REGION ###

# Calculo el ratio para la media:

bootleneck_vs_non_bootleneck_ratio_median_feature_region <- function(dataframe_POP1, dataframe_POP2, name_POP1, name_POP2){
  
  # Nombre de las poblaciones
  
  POP1=as.character(as.data.frame(dataframe_POP1) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
  POP2=as.character(as.data.frame(dataframe_POP2) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
   
  # Valor para intergénico de la población --> autosomes.
  
  autosomes_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
  autosomes_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic))  
  
  # Valor para intergénico de la población --> chrX.

  chrX_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
  chrX_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic)) 
  
  
  
  # Calculo de los ratios globales.
  
  ratio_averages_POP1_POP2 <- full_join ( 
    select ( dataframe_POP1, pop, feature, region, total_count, median_pairwise_ave, median_watterson_ave, median_pairwise_ave_corrected, median_watterson_ave_corrected, type_chr), 
    select ( dataframe_POP2, pop, feature, region, total_count, median_pairwise_ave, median_watterson_ave, median_pairwise_ave_corrected, median_watterson_ave_corrected, type_chr), 
    by=c("feature","region", "type_chr")) %>% 
    
    
    mutate (ratio_median_pairwise = median_pairwise_ave.y/median_pairwise_ave.x) %>% 
    mutate (ratio_median_watterson = median_watterson_ave.y/median_watterson_ave.x) %>% 
    
     mutate (ratio_median_pairwise_corrected = ifelse(type_chr=="autosomes",                  (median_pairwise_ave.y/autosomes_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/autosomes_pairwise_average_intergenic_per_unit_pop1_median), 
(median_pairwise_ave.y/chrX_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/chrX_pairwise_average_intergenic_per_unit_pop1_median))) %>% 
  
    mutate (ratio_median_watterson_corrected = ifelse(type_chr=="autosomes",                  (median_watterson_ave.y/autosomes_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/autosomes_watterson_average_intergenic_per_unit_pop1_median), 
(median_watterson_ave.y/chrX_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/chrX_watterson_average_intergenic_per_unit_pop1_median)))

  
  dataframename <- paste ("ratio_median", name_POP1, name_POP2,  sep="_")
  assign (dataframename, ratio_averages_POP1_POP2,.GlobalEnv)
 
}

# Create data frame

# Dataframe Kirov-Norway

bootleneck_vs_non_bootleneck_ratio_median_feature_region(c_ll_ki_n013_stats_feature_region,c_ll_no_n008_stats_feature_region, deparse(substitute(c_ll_ki_n013_stats_feature_region)),deparse(substitute(c_ll_no_n008_stats_feature_region)))
write.table(ratio_median_c_ll_ki_n013_stats_feature_region_c_ll_no_n008_stats_feature_region, paste(wd_output,"ratio_median_feature_region_c_ll_ki_n013_c_ll_no_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

# Dataframe Kirov-Poland

bootleneck_vs_non_bootleneck_ratio_median_feature_region(c_ll_ki_n013_stats_feature_region,c_ll_po_n008_stats_feature_region, deparse(substitute(c_ll_ki_n013_stats_feature_region)),deparse(substitute(c_ll_po_n008_stats_feature_region)))
write.table(ratio_median_c_ll_ki_n013_stats_feature_region_c_ll_po_n008_stats_feature_region, paste(wd_output,"ratio_median_feature_region_c_ll_ki_n013_c_ll_po_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

# Dataframe Sierra_Morena-Doñana

bootleneck_vs_non_bootleneck_ratio_median_feature_region(c_lp_sm_n019_stats_feature_region,c_lp_do_n012_stats_feature_region, deparse(substitute(c_lp_sm_n019_stats_feature_region)),deparse(substitute(c_lp_do_n012_stats_feature_region)))
write.table(ratio_median_c_lp_sm_n019_stats_feature_region_c_lp_do_n012_stats_feature_region, paste(wd_output,"ratio_median_feature_region_c_lp_sm_n019_c_lp_do_n012.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )



### REGION - CHR ###

# Calculo el ratio para la mediana:

bootleneck_vs_non_bootleneck_ratio_median_region_chr <- function(dataframe_POP1, dataframe_POP2, name_POP1, name_POP2){
  
  # Nombre de las poblaciones
  
  POP1=as.character(as.data.frame(dataframe_POP1) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
  POP2=as.character(as.data.frame(dataframe_POP2) %>% select (pop) %>% mutate(pop=as.character(pop)) %>% .[1,1]) 
   
  # Valor para intergénico de la población --> autosomes.
  
  autosomes_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
  autosomes_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(autosomes_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic))  
  
  # Valor para intergénico de la población --> chrX.

  chrX_pairwise_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop1_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP1)) %>% select (median_watterson_ave_intergenic))  
  
  chrX_pairwise_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit_pop2_median <- as.numeric(chrX_intergenic_average_values %>% filter (pop==as.character(POP2)) %>% select (median_watterson_ave_intergenic)) 
  
  
  
  # Calculo de los ratios globales.
  
  ratio_averages_POP1_POP2 <- full_join ( 
    select ( dataframe_POP1, pop, region, region, total_count, median_pairwise_ave, median_watterson_ave, median_pairwise_ave_corrected, median_watterson_ave_corrected, chr), 
    select ( dataframe_POP2, pop, region, region, total_count, median_pairwise_ave, median_watterson_ave, median_pairwise_ave_corrected, median_watterson_ave_corrected, chr), 
    by=c("region", "chr")) %>% 
    
    
    mutate (ratio_median_pairwise = median_pairwise_ave.y/median_pairwise_ave.x) %>% 
    mutate (ratio_median_watterson = median_watterson_ave.y/median_watterson_ave.x) %>% 
    
     mutate (ratio_median_pairwise_corrected = ifelse(chr!="chrX",                  (median_pairwise_ave.y/autosomes_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/autosomes_pairwise_average_intergenic_per_unit_pop1_median), 
(median_pairwise_ave.y/chrX_pairwise_average_intergenic_per_unit_pop2_median)/(median_pairwise_ave.x/chrX_pairwise_average_intergenic_per_unit_pop1_median))) %>% 
  
    mutate (ratio_median_watterson_corrected = ifelse(chr!="chrX",                  (median_watterson_ave.y/autosomes_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/autosomes_watterson_average_intergenic_per_unit_pop1_median), 
(median_watterson_ave.y/chrX_watterson_average_intergenic_per_unit_pop2_median)/(median_watterson_ave.x/chrX_watterson_average_intergenic_per_unit_pop1_median)))

  
  dataframename <- paste ("ratio_median", name_POP1, name_POP2,  sep="_")
  assign (dataframename, ratio_averages_POP1_POP2,.GlobalEnv)
 
}

# Create data frame

# Dataframe Kirov-Norway

bootleneck_vs_non_bootleneck_ratio_median_region_chr(c_ll_ki_n013_stats_region_chr,c_ll_no_n008_stats_region_chr, deparse(substitute(c_ll_ki_n013_stats_region_chr)),deparse(substitute(c_ll_no_n008_stats_region_chr)))
write.table(ratio_median_c_ll_ki_n013_stats_region_chr_c_ll_no_n008_stats_region_chr, paste(wd_output,"ratio_median_autosomes_region_chr_c_ll_ki_n013_c_ll_no_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
 
# Dataframe Kirov-Poland
 
bootleneck_vs_non_bootleneck_ratio_median_region_chr(c_ll_ki_n013_stats_region_chr,c_ll_po_n008_stats_region_chr, deparse(substitute(c_ll_ki_n013_stats_region_chr)),deparse(substitute(c_ll_po_n008_stats_region_chr)))
write.table(ratio_median_c_ll_ki_n013_stats_region_chr_c_ll_po_n008_stats_region_chr, paste(wd_output,"ratio_median_autosomes_region_chr_c_ll_ki_n013_c_ll_po_n008.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
 
# Dataframe Sierra_Morena-Doñana
 
bootleneck_vs_non_bootleneck_ratio_median_region_chr(c_lp_sm_n019_stats_region_chr, c_lp_do_n012_stats_region_chr, deparse(substitute(c_lp_sm_n019_stats_region_chr)),deparse(substitute(c_lp_do_n012_stats_region_chr)))
write.table(ratio_median_c_lp_sm_n019_stats_region_chr_c_lp_do_n012_stats_region_chr, paste(wd_output,"ratio_median_autosomes_region_chr_c_lp_sm_n019_c_lp_do_n012.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )



```

##### Plot for ratio

```{r}

DATAFRAMES=c(
"ratio_median_c_ll_ki_n013_stats_feature_c_ll_no_n008_stats_feature", "ratio_median_c_ll_ki_n013_stats_feature_c_ll_po_n008_stats_feature", "ratio_median_c_lp_sm_n019_stats_feature_c_lp_do_n012_stats_feature")

INDEXES=c("ratio_median_watterson_corrected")

for (DATAFRAME in DATAFRAMES)
{
for (INDEX in INDEXES)
  {

ggplot (get(DATAFRAME), aes_string("feature", INDEX, fill="type_chr", colour="type_chr")) +
  geom_point() +
  theme(text=element_text(family = 'Times', size = 12, color = 'black'), axis.text.x = element_text(angle = 45, hjust = 1))
  
  ggsave(paste(wd_output, DATAFRAME,"_", INDEX,".pdf", sep=""))
}
}



```



##### Heatmap for two groups

```{r}
library( gplots)

# ls(pattern="ratio_median")  y selecciono los que tienen comparación a pares
DATAFRAMES=c(
"ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_no_n008_stats_feature_chr", "ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_po_n008_stats_feature_chr", "ratio_median_c_lp_sm_n019_stats_feature_chr_c_lp_do_n012_stats_feature_chr")




INDICE=c("ratio_median_pairwise_corrected", "ratio_median_watterson_corrected")
#########################################################
### A) Installing and loading required packages
#########################################################

if (!require("gplots")) {
   install.packages("gplots", dependencies = TRUE)
   library(gplots)}

if (!require("RColorBrewer")) {
   install.packages("RColorBrewer", dependencies = TRUE)
   library(RColorBrewer)
   }

  
  library(eply)

#########################################################
### B) Reading in data and transform it into matrix format
#########################################################
for (DATA in DATAFRAMES)
{  
  for (INDEX in INDICE)
  {

    DATAFRAME=as.data.frame(get(DATA))
    DATAFRAME$chr <- factor (DATAFRAME$chr, levels=c( "chrD4","chrE1","chrE3","chrF1","chrF2","chrB4","chrD2","chrE2","chrA3","chrB3","chrC1","chrD1","chrD3","chrA2","chrB2","chrA1","chrC2","chrB1","chrX"))
    
    DATAFRAME$feature <- factor (DATAFRAME$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))

    POP1=as.character(DATAFRAME$pop.x[1])
    POP2=as.character(DATAFRAME$pop.y[1])
    
    temp.data.frame.diversity <- reshape2::acast(DATAFRAME , list(names(DATAFRAME)[1], names(DATAFRAME)[3]), value.var=INDEX)
    
    temp.data.frame.counts <- reshape2::acast(DATAFRAME, list(names(DATAFRAME)[1], names(DATAFRAME)[3]), value.var="total_count.x")

   
   
#########################################################
### C) Customizing and plotting the heat map
#########################################################

# creates a 5 x 5 inch image
png(paste(wd_output,"heatmap_",names(DATAFRAME)[1],"_",names(DATAFRAME)[3],"_",INDEX,"_",POP1,"_",POP2,".png", sep=""),    # create PNG for the heat map        
  width = 5*500,        # 5 x 300 pixels
  height = 5*500,
  res = 300,            # 300 pixels per inch
  pointsize = 8)        # smaller font size


my_palette <- colorRampPalette(c("yellow", "orange", "red"))(n = 1000)
# colors = c(seq(-3,-2,length=100),seq(-2,0.5,length=100),seq(0.5,6,length=100))

    
heatmap.2(temp.data.frame.diversity,
  cellnote = temp.data.frame.counts,  
  col=my_palette, 
  #breaks=colors,
  main = paste(INDEX,POP1,POP2, sep=" "), # heat map title
  notecol="black",      # change font color of cell labels to black
  # density.info="none",  # turns off density plot inside color legend
  trace="none",         # turns off trace lines inside the heat map
  margins =c(20,10),     # widens margins around plot
  # col=my_palette,       # use on color palette defined earlier
  # breaks=col_breaks,    # enable color transition at specified limits
  dendrogram="none", 
  Rowv=FALSE,
  Colv=FALSE
  )           # turn off column clustering
  
dev.off()               # close the PNG device

  }
}  
  


```

# ------

#### Cat info join

Solo puedo unir la que sea solo agrupadas por cromosoma.


```{r}

# Creo tablas con la información de gato. Como son tablas resumen, solo las puedo unir cuando tenga información de cromosoma. 

ratio_median_c_ll_ki_n013_stats_chr_c_ll_no_n008_stats_chr_cat_info <- left_join(ratio_median_c_ll_ki_n013_stats_chr_c_ll_no_n008_stats_chr, cat_chr_info, by="chr") %>% right_join(., filter(as.data.frame(stats_df_pop_chr), pop=="c_ll_ki_n013") %>% select(chr,mean_recombination_rate, mean_divergence_rate), by="chr") 

ratio_median_c_ll_ki_n013_stats_chr_c_ll_po_n008_stats_chr_cat_info <- left_join(ratio_median_c_ll_ki_n013_stats_chr_c_ll_po_n008_stats_chr, cat_chr_info, by="chr") %>% right_join(., filter(as.data.frame(stats_df_pop_chr), pop=="c_ll_ki_n013") %>% select(chr,mean_recombination_rate, mean_divergence_rate), by="chr") 

ratio_median_c_lp_sm_n019_stats_chr_c_lp_do_n012_stats_chr_cat_info <- left_join(ratio_median_c_lp_sm_n019_stats_chr_c_lp_do_n012_stats_chr, cat_chr_info, by="chr") %>% right_join(., filter(as.data.frame(stats_df_pop_chr), pop=="c_lp_sm_n019") %>% select(chr,mean_recombination_rate, mean_divergence_rate), by="chr") 

# En realidad da igual la población que escoja, todos tienen la misma tasa de recombinación

# Creo las tablas de interacción teniendo en cuenta la feature y el cromosoma.

ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_po_n008_stats_feature_chr_cat_info <- left_join(ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_po_n008_stats_feature_chr, cat_chr_info, by="chr") %>% right_join(., filter(as.data.frame(stats_df_pop_chr), pop=="c_ll_ki_n013") %>% select(chr,mean_recombination_rate, mean_divergence_rate), by="chr")

ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_no_n008_stats_feature_chr_cat_info <- left_join(ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_no_n008_stats_feature_chr, cat_chr_info, by="chr") %>% right_join(., filter(as.data.frame(stats_df_pop_chr), pop=="c_ll_ki_n013") %>% select(chr,mean_recombination_rate, mean_divergence_rate), by="chr")

ratio_median_c_lp_sm_n019_stats_feature_chr_c_lp_do_n012_stats_feature_chr_cat_info <- left_join(ratio_median_c_lp_sm_n019_stats_feature_chr_c_lp_do_n012_stats_feature_chr, cat_chr_info, by="chr") %>% right_join(., filter(as.data.frame(stats_df_pop_chr), pop=="c_lp_sm_n019") %>% select(chr,mean_recombination_rate, mean_divergence_rate), by="chr")

```

##### General ratio vs recombination

```{r}
library("lme4")


ratio_median_c_lp_sm_n019_stats_feature_chr_c_lp_do_n012_stats_feature_chr_cat_info_vs_recombination <- lmList(ratio_median_pairwise_corrected ~ cM.Mb | feature, ratio_median_c_lp_sm_n019_stats_feature_chr_c_lp_do_n012_stats_feature_chr_cat_info)

sink(paste (wd_output,"lm_ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_per_feature_c_ll_ki_n013_c_ll_po_n008.txt"))
print(summary(ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_ll_ki_n013_c_ll_po_n008_diversity))
sink()

ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_ll_ki_n013_c_ll_no_n008_diversity <- lmList(log(ratio_pairwise_average_corrected) ~ recombination_rate.x | feature, data_diversity_c_ll_ki_n013_diversity_c_ll_no_n008_diversity)

sink(paste (wd_output,"lm_ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_per_feature_c_ll_ki_n013_c_ll_no_n008.txt"))
print(summary(ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_ll_ki_n013_c_ll_no_n008_diversity))
sink()

ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_lp_sm_n019_c_lp_do_n012_diversity  <- lmList(log(ratio_pairwise_average_corrected) ~ recombination_rate.x | feature, data_diversity_c_lp_sm_n019_diversity_c_lp_do_n012_diversity)

sink(paste (wd_output,"lm_ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_per_feature_c_lp_sm_n019_c_lp_do_n012.txt"))
print(summary(ratio_pairwise_average_corrected_vs_recombination_rate_per_unit_c_lp_sm_n019_c_lp_do_n012_diversity))
sink()
```

##### Plot join with ratio info 


```{r}

DATAFRAMES=c("ratio_median_c_ll_ki_n013_stats_chr_c_ll_no_n008_stats_chr_cat_info","ratio_median_c_ll_ki_n013_stats_chr_c_ll_po_n008_stats_chr_cat_info","ratio_median_c_lp_sm_n019_stats_chr_c_lp_do_n012_stats_chr_cat_info")
INDEXES=c("ratio_median_pairwise_corrected", "ratio_median_watterson_corrected") 

# Ratio vs tamaño

for (DATAFRAME in DATAFRAMES)
{
  
POP1=as.character(as.data.frame(get(DATAFRAME)) %>% select(pop.x) %>% .[1,1])
POP2=as.character(as.data.frame(get(DATAFRAME)) %>% select(pop.y) %>% .[1,1])

for (INDEX in INDEXES)
  {
ggplot (as.data.frame(get(DATAFRAME) %>% filter (chr!="chrX")), aes_string("SizeMb_v8", INDEX)) +
  geom_point(aes_string(fill="chr" , colour="chr")) +
  geom_smooth(method = "lm") +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "cat_size_vs_",INDEX,"_",POP1,"_",POP2,".pdf", sep=""))

}
    
# Ratio vs tamaño


for (INDEX in INDEXES)
  {
ggplot (as.data.frame(get(DATAFRAME) %>% filter (chr!="chrX")), aes_string("percentage_genes", INDEX)) +
  geom_point(aes_string(fill="chr" , colour="chr")) +
  geom_smooth(method = "lm") +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "cat_gene-content_vs_",INDEX,"_",POP1,"_",POP2,".pdf", sep=""))

}
    
# Ratio vs chr recombination

for (INDEX in INDEXES)
  {
ggplot (as.data.frame(get(DATAFRAME) %>% filter (chr!="chrX")), aes_string("cM.Mb", INDEX)) +
  geom_point(aes_string(fill="chr" , colour="chr")) +
  geom_smooth(method = "lm") +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "cat_chr-recomb_vs_",INDEX,"_",POP1,"_",POP2,".pdf", sep=""))

}

# Ratio vs calculated recombination

for (INDEX in INDEXES)
  {
ggplot (as.data.frame(get(DATAFRAME) %>% filter (chr!="chrX")), aes_string("mean_recombination_rate", INDEX)) +
  geom_point(aes_string(fill="chr" , colour="chr")) +
  geom_smooth(method = "lm") +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "cat_calculated-recomb_vs_",INDEX,"_",POP1,"_",POP2,".pdf", sep=""))
}

  # Ratio vs calculated divergence

for (INDEX in INDEXES)
  {
ggplot (as.data.frame(get(DATAFRAME) %>% filter (chr!="chrX")), aes_string("mean_divergence_rate", INDEX)) +
  geom_point(aes_string(fill="chr" , colour="chr")) +
  geom_smooth(method = "lm") +
  theme_bw()   #theme selection for background and lines
  ggsave(paste(wd_output, "divergence_vs_",INDEX,"_",POP1,"_",POP2,".pdf", sep=""))


}
}


####


DATAFRAMES=c("ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_po_n008_stats_feature_chr_cat_info","ratio_median_c_ll_ki_n013_stats_feature_chr_c_ll_no_n008_stats_feature_chr_cat_info","ratio_median_c_lp_sm_n019_stats_feature_chr_c_lp_do_n012_stats_feature_chr_cat_info")
INDEXES=c("ratio_median_pairwise_corrected", "ratio_median_watterson_corrected") 

for (DATAFRAME in DATAFRAMES)
{
  
POP1=as.character(as.data.frame(get(DATAFRAME)) %>% select(pop.x) %>% .[1,1])
POP2=as.character(as.data.frame(get(DATAFRAME)) %>% select(pop.y) %>% .[1,1])

for (INDEX in INDEXES)
  {

ggplot (filter(get(DATAFRAME), chr!="chrX"), aes(mean_divergence_rate, ratio_median_pairwise_corrected, fill=feature, colour=feature)) +
          geom_point() +
  geom_smooth(method = "lm") +
    facet_grid(~feature)
  ggsave(paste(wd_output, "recombination_rate_vs_",INDEX,"_",POP1,"_",POP2,"_by_feature_and_chr.pdf", sep=""))
  
ggplot (filter(get(DATAFRAME), chr!="chrX"), aes(mean_divergence_rate, ratio_median_pairwise_corrected, fill=feature, colour=feature)) +
          geom_point() +
  geom_smooth(method = "lm") +
    facet_grid(~feature)
  ggsave(paste(wd_output, "divergence_rate_vs_",INDEX,"_",POP1,"_",POP2,"_by_feature_and_chr.pdf", sep=""))
  


}
}

```



# ----------------------------------------------------------------
# ----------------------------------------------------------------
## Otros

### GAM

```{r}
require(gam)
require(ISLR)
attach(Wage)
require("mgcv")

gam1<-gam(wage~s(age,df=6)+s(year,df=6)+education ,data = Wage)
#in the above function s() is the shorthand for fitting smoothing splines 
#in gam() function
summary(gam1)

#Plotting the Model
par(mfrow=c(1,3)) #to partition the Plotting Window
plot(gam1,se = TRUE) 
#se stands for standard error Bands

hist(log(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity$ratio_watterson_average), breaks=30, col="red")
hist(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity$ratio_watterson_average_corrected, breaks=30, col="red")

gam1<-gam(log(ratio_watterson_average)~+s(length)+chr+feature+divergence+recombination_rate,data = data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity, method = "REML")
#in the above function s() is the shorthand for fitting smoothing splines 
#in gam() function
summary(gam1)

par(mfrow=c(3,3)) #to partition the Plotting Window
gam.check(gam1)


#Plotting the Model
par(mfrow=c(1,3)) #to partition the Plotting Window
plot(gam1,se = TRUE) 
#se stands for standard error Bands




ki.po.model_iteraction <- lmer (ratio_corrected_by_watterson_average_intergenic_per_unit ~ feature * recombination_rate.y * chr + ( 1 | unique_id ), data=data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity, REML=FALSE)

r.squaredGLMM(ki.po.model_iteraction)

ggplot(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity, aes(ratio_corrected_by_watterson_average_intergenic_per_unit)) +
  geom_density()


d <- density(data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity$ratio_corrected_by_watterson_average_intergenic_per_unit) # returns the density data 
plot(d)


```


## Modelo mixto generalizado


```{r}
library(lme4)
library(MuMIn)
library(gvlma)

data=data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity


ki.po.model_iteraction <- lmer (ratio_corrected_by_watterson_average_intergenic_per_unit ~ feature * recombination_rate.y * chr + ( 1 | unique_id ), data=data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity, REML=FALSE)

r.squaredGLMM(ki.po.model_iteraction)

summary (ki.po.model_iteraction)

# Of course you should do model simplification or model averaging in an attempt to get a parsimonious model before you do any of this, but I just wanted to flag this up.
anova_model1 <- anova(ki.po.model_iteraction)


mod <- lm(ratio_corrected_by_watterson_average_intergenic_per_unit ~ feature * recombination_rate.y * chr,data=data_diversity_c_ll_ki_n013_autosomes_diversity_c_ll_po_n008_autosomes_diversity)

# Do I understand correctly it is fine the outcome variable  does not need to be normally distributed itself ?
# Just like general linear models, your outcome variable does not need to be normally distributed as a univariate variable. However, LME models assume that the residuals of the model are normally distributed. So a transformation or adding weights to the model would be a way of taking care of this (and checking with diagnostic plots, of course).
par(mfrow = c(2, 2))
plot(mod)
# problema de convergencia!

gvlma::gvlma(mod)

anova(ki.po.model_nointeraction,ki.po.model_iteraction)

mean(ki.po.model_iteraction$residuals)
# https://www.ncbi.nlm.nih.gov/pubmed/21077903


# Super util para iterpretar los plots: https://stats.stackexchange.com/questions/58141/interpreting-plot-lm/65864#65864
mod.stdres = rstandard(mod)
plot(c_ll_ki_n013_diversity_c_ll_po_n008_diversity_for_model$Populations, mod.stdres, 
  ylab="Standardized Residuals") 

ggplot (data=c_ll_ki_n013_diversity, aes(watterson_ave)) +
  geom_histogram()

kk <- c_ll_ki_n013_diversity %>% filter(feature=="CDS")

shapiro.test(randomssubset$watterson_ave)

a <- seq(1, 700000, by = 150) # option 2
randomssubset <- kk[a,]





```


https://stats.stackexchange.com/questions/101274/how-to-interpret-a-qq-plot
https://www.google.com/search?client=safari&rls=en&q=how+to+correct+for+right+skewness+residuals&ie=UTF-8&oe=UTF-8
https://stats.stackexchange.com/questions/135008/how-to-deal-with-non-normally-distributed-residuals
https://stats.stackexchange.com/questions/58141/interpreting-plot-lm/65864#65864
https://stats.stackexchange.com/questions/76226/interpreting-the-residuals-vs-fitted-values-plot-for-verifying-the-assumptions
https://brownmath.com/stat/shape.htm
https://www.researchgate.net/post/how_to_reduce_skewness_and_kurtosis
https://www.researchgate.net/post/how_to_deal_with_skewness


### Assumptions of the model

Assumption 1
The regression model is linear in parameters

```{r}

```

Assumption 2
The mean of residuals is zero





Again, let’s work through this: First, the output reminds you of the model that you
fit. Then, there’s some general summary statistics such as Akaike’s Information
Criterion, the log-Likelihood etc. We won’t go into the meaning of these different
values in this tutorial because these are conceptually a little bit more involved.
Let’s focus on the output for the random effects first:


You’re being reminded of the formula of the two models that you’re comparing.
Then, you find a Chi-Square value, the associated degrees of freedom and the pvalue2.
You would report this result the following way:
“… politeness affected pitch (χ2(1)=11.62, 



