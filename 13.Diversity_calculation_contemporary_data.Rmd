---
title: "13.Diversity_calculation_contemporary_data"
output: html_document
---

En este script voy a hacer los análisis de diversidad para las poblaciones contemporaneas. 

Ahora tengo que descargarme todos los archivos de cada población y despues hacer un super-join para cada población para acabar haciendo una unica tabla con rbind con todas las poblaciones. 

# Creación tablas

```{r}

# https://github.com/MTFA/CohortEx/wiki/Run-rJava-with-RStudio-under-OSX-10.10,-10.11-(El-Capitan)-or-10.12-(Sierra)

# Ahora hago un join de la tabla principal de diversidad con las de telómeros, centrómeros y cromosoma. 

library(dplyr)
library(tidyr)

wd_in <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/raw_tables/"
wd_out <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_recom <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/recombination"
wd_diver <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/divergence"

# Ojo! antes de correr esto, asegurarme que no lo he corrido antes porque si no estoy haciendo append a las tablas viejas y no creando nuevas. --> YA NO PASA ESTO PQ LO TENGO EN CARPETAS DISTINTAS!!!!

poplist <- c("c_ll_ki_n013", "c_ll_po_n008","c_ll_no_n008","c_lp_sm_n019", "c_lp_do_n012")

  
for (pop in poplist)
{
  if (exists("dataset"))
  {rm (dataset)
  }
  
  files_for_given_pop <- list.files(path = wd_in, pattern = pop)
  
  for (file_for_given_pop in files_for_given_pop)
  {
    message (file_for_given_pop)
    # if the merged dataset doesn't exist, create it
    if (!exists("dataset"))
    {
      dataset <- read.table(paste(wd_in,file_for_given_pop, sep=""), header=TRUE, sep="\t") 
    }
    
    # if the merged dataset does exist, append to it
    if (exists("dataset"))
    {
      temp_dataset <-read.table(paste(wd_in,file_for_given_pop, sep=""), header=TRUE, sep="\t", na.strings = c("NA", "na"))
      dataset <- dplyr::full_join(dataset, temp_dataset, by = c("scaffold", "start_cero_based", "end", "length", "NAs", "informative_sites", "feature", "strandness", "frame", "id_gene", "id", "watterson_ave", "watterson_sd", "pairwise_ave", "pairwise_sd", "tajimaD", "pop", "specie", "epoch"))   
      rm(temp_dataset)
      assign(pop, dataset) # Con esto quiero ponerle el nombre de la población a la dataframe. 
    }
  }    
}



rm(dataset)



data_diversity_raw <-rbind(c_ll_ki_n013,c_ll_po_n008,c_ll_no_n008,c_lp_sm_n019,c_lp_do_n012) %>% 
    mutate( watterson_ave = as.numeric(gsub("\\*10\\^","e",watterson_ave)),
            watterson_sd = as.numeric(gsub("\\*10\\^","e",watterson_sd)),
            pairwise_ave  = as.numeric(gsub("\\*10\\^","e",pairwise_ave)),
            pairwise_sd  = as.numeric(gsub("\\*10\\^","e",pairwise_sd)),
            tajimaD = as.numeric(gsub("\\*10\\^","e",tajimaD)))


write.table (data_diversity_raw, paste(wd_out, "global.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_ki_n013, paste(wd_out, "c_ll_ki_n013.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_ki_n008, paste(wd_out, "c_ll_ki_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_no_n008, paste(wd_out, "c_ll_no_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_ll_po_n008, paste(wd_out, "c_ll_po_n008.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_lp_do_n012, paste(wd_out, "c_ll_do_n012.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
# write.table (c_lp_sm_n019, paste(wd_out, "c_ll_sm_n019.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
#write.table (c_lp_sm_n012, paste(wd_out, "c_ll_sm_n012.per.unit.averages.chr.all.regions.tsv", sep=""), row.names = F, quote = F, sep = '\t')
```

## Cargar tablas 


```{r}

library(dplyr)
library(ggplot2)
library(tidyr)

wd_in <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/raw_tables/"
wd_out <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_recom <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/recombination"
wd_diver <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/divergence"
wd_GC <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/GC_content"

# data_diversity <- data_diversity_raw 
# En teoría debería de funcionar llamando a la tabla anterior, pero como no funciona no le doy más vueltas. Me he descargado la raw y la he vuelto a cargar, que así funcionaba antes, y así ha funcionado ahora. 

data_diversity <- read.table(paste(wd_out, "global.per.unit.averages.chr.all.regions.tsv", sep=""), header=T, na.strings = c("NA", "na"), stringsAsFactors = F) %>%  
  replace(., is.na(.), "0") %>%  # Para que pueda calcular cuando es mayor o menor que 75%; si es NA no lo reconoce. 
  dplyr::mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "NE_Poland",
                            ifelse (pop == "c_ll_ki_n013", "Kirov", 
                            ifelse (pop == "c_ll_no_n008", "Norway", 
                            ifelse (pop == "c_lp_sm_n019", "Andujar",  
                            ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
  dplyr::mutate (., Species =ifelse (specie=="ll", "L.lynx", 
                   ifelse (specie=="lp", "L.pardinus", NA))) %>% 
  # Anoto qué es cada región excluyendo las de los chr F1 y F2 centromero y telómero. 
  dplyr::mutate (., region = ifelse (chr.x=="chrF2" & centr_percentage >= 0.75, NA, 
                             ifelse (chr.x=="chrF2" & tel2m_percentage >= 0.75, NA,
                             ifelse (tel2m_percentage >= 0.75, "Telomere_2m", 
                             ifelse (centr_percentage >= 0.75, "Centromere", "Interstitial" )))))  %>% 
  # Ahora elimino la barra baja que encuentro en algunos de los lncRNA
  #mutate(new_id=ifelse(feature=="lncRNA", substr(.$id_gene,start=1,stop=13), as.character(id_gene))) %>% 
  #select(-id_gene) %>% 
  #dplyr::rename(id_gene = new_id) %>% 
  # Creo un identificador único para luego poder filtrar por este cuando tenga que sacar los comunes a todas las poblaciones. 
  dplyr::mutate (., chr = ifelse (chr.x == chr.y, as.character(chr.x), "PROBLEMA")) %>% 
  dplyr::select (-c(chr.x, chr.y)) %>% 
  mutate (., unique_id = paste (id,feature, sep="_")) %>% 
  #Haciendo este mutate lo que hago es modificar el valor de watterson para tener en ucenta el tamaño poblacional verdadero de la población (chr) cuando consideramos la diferencia entre machos y hembras. En el xls modif_a_watterson_chrX viene explicado. 
  mutate (., watterson_modif = ifelse (chr=="chrX" & pop == "c_ll_ki_n013", watterson_ave * 1.09, 
                               ifelse (chr=="chrX" & pop == "c_ll_po_n008", watterson_ave * 1.12,
                               ifelse (chr=="chrX" & pop == "c_ll_no_n008", watterson_ave * 1.15,
                               ifelse (chr=="chrX" & pop == "c_lp_sm_n019", watterson_ave * 1.07, 
                               ifelse (chr=="chrX" & pop == "c_lp_do_n012", watterson_ave * 1.10, watterson_ave)))))) %>% 
  dplyr::select (., -watterson_ave) %>% 
  dplyr::rename(watterson_ave = watterson_modif) %>% 
  dplyr::rowwise() %>%
 # los promotores de los lncRNA siguen llamandose igual, y ojo que están sacados de la notación de los propios lncrNA pero sin tener en cuenta los distintos transcritos.
  dplyr::mutate(new_id = ifelse ( feature=="lncRNA" | feature =="intron_lncRNA",substr(as.character(id_gene), start = 1, stop = 13),as.character(id_gene))) %>% 
  dplyr::select (.,-id_gene) %>% 
  dplyr::rename(id_gene = new_id)
                                     

#View(data_diversity)
#unique(data_diversity$pop)
#unique(data_diversity$Populations)

#¡Ojo! el filtro que estás aplicando se está quedando con las que para la Tajima son NA. Si las quieres eliminar ¡ojo!
# 2248581

# Compruebo que efectivamente no hay ningún cromosoma que no encaje. 
# unique(data_diversity$chr)
# Está bien!
```

## Filtering por tamaño y transcritos

```{r}
# Ojo los lncRNA tienen más de un trasncrito, así que hay que eliminarlo. 
# En primer lugar vamos a sacar una lista para que luego la podamos filtrar. 


all_lncRNA <- data_diversity %>% ungroup(.) %>% dplyr::filter (pop=="c_ll_ki_n013") %>%  dplyr::filter (feature=="lncRNA"| feature=="intron_lncRNA" ) %>% dplyr::mutate(id2=id) %>% separate (id2,c("a", "b", "c", "d", "e"), "_", extra = "drop") %>% dplyr::mutate(new_id=paste(c,d, sep="_")) %>% dplyr::select (-c(a,b,c,d,e)) 

# Selecciono todos los que tienen más de un transcrito.
all_lncRNA_sum_lenght_repeted <- all_lncRNA %>% as.data.frame(.) %>% dplyr::group_by (id_gene, new_id) %>% dplyr::summarise (sum_length = sum(length)) %>% dplyr::group_by(id_gene) %>% dplyr::filter(n()>1)

# Me quedo con el más largo, y añado la información que se pierde al hacer el resumen de la identidad del transcrito. 
all_lncRNA_sum_lenght_repeted_large_length <- all_lncRNA_sum_lenght_repeted %>% dplyr::summarise(sum_length = max(sum_length))  %>%  dplyr::inner_join(., all_lncRNA_sum_lenght_repeted, by=c("id_gene", "sum_length"))

# Elimino duplicados en caso de que haya más de un transcrito con la misma longitud, quedandome con uno al azar--> Esta tabla sería la buena, con la que me tengo que quedar, asi que hago antijoin para lograr lo que tengo que tirar. 
all_lncRNA_sum_lenght_repeted_large_length_no_duplicates <- all_lncRNA_sum_lenght_repeted_large_length[!duplicated(all_lncRNA_sum_lenght_repeted_large_length$id_gene),]

# Selecciono el id de todos estos.
all_lncRNA_sum_lenght_repeted_large_length_no_duplicates_unique_id  <- dplyr::anti_join(all_lncRNA, all_lncRNA_sum_lenght_repeted_large_length_no_duplicates, by=c("id_gene", "new_id")) %>% dplyr::select("unique_id")


data_diversity_pre <- data_diversity %>% ungroup(.) %>%  
  dplyr::anti_join(all_lncRNA_sum_lenght_repeted_large_length_no_duplicates_unique_id,by="unique_id") %>% 
  dplyr::filter (., informative_sites>=50) %>% 
  dplyr::filter (., informative_sites/length>=0.20) %>% 
  dplyr::filter (., !(feature=="promoter_gene_250")) %>% 
  dplyr::filter (., !(feature=="promoter_gene_500")) %>% 
  dplyr::filter (., !(feature=="promoter_gene_1000" & length < 1000)) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_250")) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_500")) %>% 
  dplyr::filter (., !(feature=="promoter_lncRNA_1000" & length < 1000)) 


# Sanity check de que nada con las mismas coordenadas y con las misma longitud y strandness y frame se va a contar doble, pq no debería. 
# kk1 <- data_diversity_pre %>% mutate (position=paste(scaffold,start_cero_based,end, length, feature, strandness, frame, id_gene)) 
# kk2 <- as.data.frame(table (kk3$position)) %>% filter(Freq>5)



# Saco la lista de elementos comunes a todas las unidades para cada especie. 

# Primero par lynx lynx:

data_diversity_pre_ki <- data_diversity_pre %>% filter (pop=="c_ll_ki_n013")
data_diversity_pre_no <- data_diversity_pre %>% filter (pop=="c_ll_no_n008")
data_diversity_pre_po <- data_diversity_pre %>% filter (pop=="c_ll_po_n008")


lista_lynxlynx <- dplyr::inner_join(data_diversity_pre_ki, data_diversity_pre_no, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id")) %>% dplyr::inner_join(., data_diversity_pre_po, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id" ))  %>% select("unique_id")

data_diversity_filtered_lynxlynx <- data_diversity_pre %>% dplyr::filter (specie=="ll") %>% dplyr::filter(unique_id %in% lista_lynxlynx$unique_id)

# Ahora para pardinus:

data_diversity_pre_sm <- data_diversity_pre %>% dplyr::filter (pop=="c_lp_sm_n019")
data_diversity_pre_do <- data_diversity_pre %>% dplyr::filter (pop=="c_lp_do_n012")

lista_lynxpardinus <- dplyr::inner_join( data_diversity_pre_sm, data_diversity_pre_do, by = c("scaffold", "start_cero_based", "end", "length", "feature", "strandness", "frame", "id_gene", "id", "region", "chr", "unique_id")) %>% dplyr::select("unique_id")

data_diversity_filtered_lynxpardinus <- data_diversity_pre %>% dplyr::filter (specie=="lp") %>% dplyr::filter(unique_id %in% lista_lynxpardinus$unique_id)

# Con los filtrados hemos perdido 251.736 unidades. Aqui entran los promotores que se han caido. 
```

## Adding divergence rate

```{r}

divergence_per_unit_lynx_lynx <- read.table(paste(wd_diver, "/c_ll_ki_0090_plus_c_lr_zz_0001_recal_round-1_25x_SNPs.divergence.tsv", sep=""), header=T, fill = TRUE) %>% dplyr::rename("informative_sites_substitutions"="informative_sites") %>% dplyr::rename("unique_id"="id_gene")
# empty_divergence_per_unit_lynx_lynx <- subset(divergence_per_unit_lynx_lynx, is.na(divergence_per_unit_lynx_lynx$divergence))
# rm(empty_divergence_per_unit_lynx_lynx)

divergence_per_unit_lynx_pardinus <- read.table(paste(wd_diver, "/c_lp_sm_0298_plus_c_lr_zz_0001_recal_round-1_25x_SNPs.divergence.tsv", sep=""), header=T, fill = TRUE) %>% dplyr::rename("informative_sites_substitutions"="informative_sites") %>% dplyr::rename("unique_id"="id_gene")
# empty_divergence_per_unit_lynx_pardinus <- subset(divergence_per_unit_lynx_pardinus, is.na(divergence_per_unit_lynx_pardinus$divergence))
# rm(empty_divergence_per_unit_lynx_pardinus)


data_diversity_filtered_lynxlynx_divergence <- data_diversity_filtered_lynxlynx %>% dplyr::left_join (., divergence_per_unit_lynx_lynx)
data_diversity_filtered_lynxpardinus_divergence <- data_diversity_filtered_lynxpardinus %>%  dplyr::left_join (., divergence_per_unit_lynx_pardinus)

```

## Adding GC content

```{r}

GC_content_per_unit_lynx_lynx <- read.table(paste(wd_GC, "/list_of_units_with_chr_info_in_lynx_no_duplicates.GC_content.ll.bed", sep=""), header=F, fill = TRUE) %>% dplyr::rename("scaffold"="V1", "start_cero_based"="V2", "end"="V3", "unique_id"="V4", "GC_content"="V6") %>% select(-c("V5", "V7",	"V8",	"V9",	"V10",	"V11",	"V12","V13")) 


GC_content_per_unit_lynx_pardinus <- read.table(paste(wd_GC, "/list_of_units_with_chr_info_in_lynx_no_duplicates.GC_content.lp.bed", sep=""), header=F, fill = TRUE) %>% dplyr::rename("scaffold"="V1", "start_cero_based"="V2", "end"="V3", "unique_id"="V4", "GC_content"="V6") %>% select(-c("V5", "V7",	"V8",	"V9",	"V10",	"V11",	"V12","V13")) 


data_diversity_filtered_lynxlynx_divergence_GC <- data_diversity_filtered_lynxlynx_divergence %>% dplyr::left_join (., GC_content_per_unit_lynx_lynx)
data_diversity_filtered_lynxpardinus_divergence_GC <- data_diversity_filtered_lynxpardinus_divergence %>%  dplyr::left_join (., GC_content_per_unit_lynx_pardinus)
```


## Adding recombination rate

```{r}

# Ahora adjunto los datos de recombinación. 

recombination_per_unit <- read.table(paste(wd_recom, "/recombination_rate_per_unit_all_info_sorted_filtered_uniq.bed", sep=""), header=F, na.strings = c("NA", "na"))
colnames(recombination_per_unit) <- c("unique_id","recombination_rate")
recombination_per_unit$unique_id <- as.factor(recombination_per_unit$unique_id)

data_diversity_filtered <- rbind(data_diversity_filtered_lynxlynx_divergence_GC, data_diversity_filtered_lynxpardinus_divergence_GC) %>% dplyr::left_join (., recombination_per_unit, by = "unique_id")   
# Ordenar los factores. 

data_diversity_filtered$Populations <- factor (data_diversity_filtered$Populations, levels=c("Kirov","Kirov_subsampled","NE_Poland","Norway", "Andujar","Donana"))

data_diversity_filtered$chr <- factor(data_diversity_filtered$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrC2","chrB2","chrB3","chrB4","chrA3","chrD1","chrD3","chrD4","chrD2","chrF2","chrF1","chrE2","chrE1","chrX"))

data_diversity_filtered$watterson_ave <- as.numeric(data_diversity_filtered$watterson_ave)
data_diversity_filtered$watterson_sd <- as.numeric(data_diversity_filtered$watterson_sd)
data_diversity_filtered$pairwise_ave <- as.numeric(data_diversity_filtered$pairwise_ave)
data_diversity_filtered$pairwise_sd <- as.numeric(data_diversity_filtered$pairwise_sd)
data_diversity_filtered$tajimaD <- as.numeric(data_diversity_filtered$tajimaD)

write.table (data_diversity_filtered, paste(wd_out, "global.per.unit.averages.chr.all.regions.filtered.watterson.modif.chrX.tsv", sep=""), row.names = F, quote = F, sep = '\t')

# 5/6/2018
# Hemos decidido filtrar el 20% de sitios informativos/length.
# También que tengan un mínimo de 50 sitios informativos. 
# Por último tamibén quitamos los promotores que tengan menos del tamaño esperado. 
## Aquí abajo están todas las pruebecillas que he ido haciendo para al final quedarnos con los filtro que explicamos arriba. 

# Voy a nombrar como telómero 10m, 2m o centr lo que tenga más de 75% de bases como tal. 
# Ojo que : Todo lo que tiene bases como tel2m está contenido en 10m, pero por supuesto no todo lo que está en 2m está en 10m . 
# 21/06/2018 --> Despues de pensarlo, y hacer gráficas que comparaban tel 0-10 con tel 0-2 me voy a quedar solo con tel2.  
#
# uu <- filter (data_diversity, data_diversity$tel10m_percentage!=data_diversity$tel2m_percentage)

# # Porcentaje de telomericas.
# ggplot (data = data_diversity, aes(tel10m_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# 
# ggplot (data = data_diversity, aes(data_diversity$tel2m_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# ggplot (data = data_diversity, aes(data_diversity$centr_percentage)) +
#   geom_histogram() +
#    scale_y_continuous(trans = 'log10') 
# 
# Para cada una de las unidades voy comprobando
# ggplot (data = filter (data_diversity,data_diversity$feature=="CDS" & data_diversity$length<2000), aes(informative_sites)) +
#   geom_histogram(bins=500) 
# ggplot (data = filter(data_diversity, data_diversity$feature=="CDS"), aes(x=informative_sites, y=length)) +
#   geom_point()
# ggplot (data = filter (data_diversity,data_diversity$feature=="intergenic"), aes(length)) +
#   geom_histogram(bins=1000)
# ggplot (data = filter (data_diversity,data_diversity$feature=="intron" & data_diversity$length<150000), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="5UTR"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="3UTR"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="lncRNA"), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="ncRNA "), aes(length)) +
#   geom_histogram(bins=1000) 
# ggplot (data = filter (data_diversity,data_diversity$feature=="UCNE"), aes(length)) +
#   geom_histogram(bins=1000) 
### Otros sanity checks

# SANITY CHECKS:

# lncRNA <- data_diversity %>% filter (feature=="lncRNA")
# 55885 observaciones

# ggplot(lncRNA, aes(x=length))+
#   geom_histogram(bins = 2000) +
#  coord_cartesian(xlim=c(0, 3000))

# sncRNA <- data_diversity %>% filter (feature=="ncRNA")
# 21043 observaciones

# ggplot(sncRNA, aes(x=length))+
#   geom_histogram(bins = 2000) +
#  coord_cartesian(xlim=c(0, 3000))

# ncRNA <- inner_join(lncRNA, sncRNA, by = c("scaffold", "start_cero_based", "end", "length")) %>%  select ("scaffold", "start_cero_based", "end","feature.x","id_gene.x", "id.x", "feature.y","id_gene.y", "id.y" ) %>% unique
# Son 14 los que coinciden. 

# Algunas notas sobre los lncRNA y ncRNA
# Infernal ("INFERence of RNA ALignment") is for searching DNA sequence databases for RNA structure and sequence similarities. It is an implementation of a special case of profile stochastic context-free grammars called covariance models (CMs). A CM is like a sequence profile, but it scores a combination of sequence consensus and RNA secondary structure consensus, so in many cases, it is more capable of identifying RNA homologs that conserve their secondary structure more than their primary sequence.

# En su momento:
# He sacado graficas para tel2m y telomero de 0 a 10m y hemos decidido quedarnos con tel2m.

# Borro las que no necesito luego

rm (data_diversity_pre_sm)
rm (data_diversity_pre_do)
rm (data_diversity_pre_ki)
rm (data_diversity_pre_po)
rm (data_diversity_pre_no)
rm (data_diversity)
rm (data_diversity_filtered_lynxlynx)
rm (data_diversity_filtered_lynxpardinus)
rm (data_diversity_pre)
rm (lista_lynxlynx)
rm (lista_lynxpardinus)
rm (c_ll_ki_n013)
rm (c_ll_no_n008)
rm (c_ll_po_n008)
rm (c_lp_do_n012)
rm (c_lp_sm_n019)

```

# -------------------------------------------------

# Modifying data

## Load library & wd
```{r}
library(viridis)
library(ggplot2); theme_set(theme_minimal())
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(arules)
library(boot)
library(broom)
library(Hmisc)

wd <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/"
```

## Load table 
```{r}
data_diversity_filtered <- read.table(paste(wd, "global.per.unit.averages.chr.all.regions.filtered.watterson.modif.chrX.tsv", sep=""), header=T, na.strings = c("NA", "na")) %>%
  # filtramos para que tenga información de cromosoma
  filter(., !is.na(chr)) %>% 
  filter(., !is.na(region))
# En esta tabla hay valores de watterson que son 0 a pesar de ser valores que teníamos anteriormente, y que tengamos valores para pi. Esto es por la transformación de watterson para chr, y que hemos realizado. Para los autosomas, hemos dejado el valor como está y para los chr X hemos aplicado una corrección. Como en algunos casoa unque tnga valores de diversidad no tngo valores de chr, al aplicar la corrección se queda en cero. Lo que tngo que hacer ahora es filtrar para los valores que no tengan info de chr. Y eso lo hago aquí, al principio. 
```


## Modifying dataframe
## 1.  Recombination categories
```{r}
# I used a function that discritize a continious variable, based on values of the variable itself (interval), or on the frequency of units under this variable (frequency)
discrete_recomb <- discretize(data_diversity_filtered$recombination_rate, method = "frequency", breaks = 20)
data_diversity_filtered_recomb_cat  <- cbind (data_diversity_filtered, as.data.frame(discrete_recomb))
# rm (data_diversity_filtered)
```

## 2. Density plot watterson
Now we are plotting a density plot of the diversity (watterson and pi) of the populations. Those are bimodal. Therefore I will get the lowest value of this density plot in order to stablish a threshold for "no diverse" vs "diverse" units. 
```{r}

POPS=c("c_ll_ki_n013","c_ll_no_n008", "c_ll_po_n008", "c_lp_sm_n019", "c_lp_do_n012")

for (POP in POPS)
{
DATAFRAME <- data_diversity_filtered_recomb_cat %>% dplyr::filter (pop==POP)
maxY1_position <- which.max(density(log10(DATAFRAME$watterson_ave))$y)
maxX1_value <- density(log10(DATAFRAME$watterson_ave))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$watterson_ave))$y[density(log10(DATAFRAME$watterson_ave))$x>(maxX1_value+3)])
maxY2_position <- which(density(log10(DATAFRAME$watterson_ave))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$watterson_ave))$x[maxY2_position] 
DensityWatterson.Y <- density(log10(DATAFRAME$watterson_ave))$y
DensityWatterson.X <- density(log10(DATAFRAME$watterson_ave))$x
minY_value <- min(DensityWatterson.Y[DensityWatterson.X < maxX2_value & DensityWatterson.X > maxX1_value])
minY_position <- which(DensityWatterson.Y == minY_value)
minX_value <- density(log10(DATAFRAME$watterson_ave))$x[minY_position] 
# ggplot(DATAFRAME, aes(log10(watterson_ave))) + 
#   geom_density() + 
#   scale_color_viridis(discrete=TRUE) +
#   scale_fill_viridis(discrete=TRUE) +
#   geom_vline(xintercept = density(log10(DATAFRAME$watterson_ave))$x[minY_position]) +
#   ggsave(paste0(wd_output, POP,"_density_watterson.pdf"))
# 
# ggplot(DATAFRAME, aes(log10(watterson_ave))) + 
#   geom_density() + 
#   facet_wrap(~feature) +
#   scale_color_viridis(discrete=TRUE) +
#   scale_fill_viridis(discrete=TRUE) +
#   geom_vline(xintercept = density(log10(DATAFRAME$watterson_ave))$x[minY_position]) +
#   ggsave(paste0(wd_output, POP,"_density_feature_watterson.pdf"))
assign(paste0(POP,"_density_min_value_watterson"), c(POP,minX_value))
}

# Join different tables. 

density_min_values_watterson <- as.data.frame(rbind (c_lp_sm_n019_density_min_value_watterson, c_lp_do_n012_density_min_value_watterson, c_ll_ki_n013_density_min_value_watterson, c_ll_po_n008_density_min_value_watterson, c_ll_no_n008_density_min_value_watterson)) 
names(density_min_values_watterson) <- c("pop", "min_density_value_watterson")
density_min_values_watterson$min_density_value_watterson <- as.numeric(as.character(density_min_values_watterson$min_density_value_watterson))

rm (c_lp_sm_n019_density_min_value_watterson)
rm (c_lp_do_n012_density_min_value_watterson)
rm (c_ll_ki_n013_density_min_value_watterson)
rm (c_ll_po_n008_density_min_value_watterson)
rm (c_ll_no_n008_density_min_value_watterson) 
rm (DATAFRAME)
```

## 3. Density plot pairwise

```{r}

POPS=c("c_ll_ki_n013","c_ll_no_n008", "c_ll_po_n008", "c_lp_sm_n019", "c_lp_do_n012")

for (POP in POPS)
{
DATAFRAME <- data_diversity_filtered_recomb_cat %>% dplyr::filter (pop==POP)
maxY1_position <- which.max(density(log10(DATAFRAME$pairwise_ave))$y)
maxX1_value <- density(log10(DATAFRAME$pairwise_ave))$x[maxY1_position] 
maxY_value <- max(density(log10(DATAFRAME$pairwise_ave))$y[density(log10(DATAFRAME$pairwise_ave))$x>(maxX1_value+3)])
maxY2_position <- which(density(log10(DATAFRAME$pairwise_ave))$y == maxY_value)
maxX2_value <- density(log10(DATAFRAME$pairwise_ave))$x[maxY2_position] 
Densitypairwise.Y <- density(log10(DATAFRAME$pairwise_ave))$y
Densitypairwise.X <- density(log10(DATAFRAME$pairwise_ave))$x
minY_value <- min(Densitypairwise.Y[Densitypairwise.X < maxX2_value & Densitypairwise.X > maxX1_value])
minY_position <- which(Densitypairwise.Y == minY_value)
minX_value <- density(log10(DATAFRAME$pairwise_ave))$x[minY_position] 
# ggplot(DATAFRAME, aes(log10(pairwise_ave))) + 
#    geom_density() + 
#    scale_color_viridis(discrete=TRUE) +
#    scale_fill_viridis(discrete=TRUE) +
#    geom_vline(xintercept = density(log10(DATAFRAME$pairwise_ave))$x[minY_position]) +
#   ggsave(paste0(wd_output, POP,"_density_pairwise.pdf"))
# 
# ggplot(DATAFRAME, aes(log10(pairwise_ave))) + 
#    geom_density() + 
#   facet_wrap (~feature)+
#    scale_color_viridis(discrete=TRUE) +
#    scale_fill_viridis(discrete=TRUE) +
#    geom_vline(xintercept = density(log10(DATAFRAME$pairwise_ave))$x[minY_position]) +
#   ggsave(paste0(wd_output, POP,"_density_feature_pairwise.pdf"))
assign(paste0(POP,"_density_min_value_pairwise"), c(POP,minX_value))
}

# Uno las distintas tablas de puntos de corte. 

density_min_values_pairwise <- as.data.frame(rbind (c_lp_sm_n019_density_min_value_pairwise, c_lp_do_n012_density_min_value_pairwise, c_ll_ki_n013_density_min_value_pairwise, c_ll_po_n008_density_min_value_pairwise, c_ll_no_n008_density_min_value_pairwise)) 
names(density_min_values_pairwise) <- c("pop", "min_density_value_pairwise")
density_min_values_pairwise$min_density_value_pairwise <- as.numeric(as.character(density_min_values_pairwise$min_density_value_pairwise))

rm (c_lp_sm_n019_density_min_value_pairwise)
rm (c_lp_do_n012_density_min_value_pairwise)
rm (c_ll_ki_n013_density_min_value_pairwise)
rm (c_ll_po_n008_density_min_value_pairwise)
rm (c_ll_no_n008_density_min_value_pairwise) 
rm (DATAFRAME)
```

## 4. Create new variable low values to zero
Now I create a new variable replacing the diversity of units below the minimun of the density plot by 0; i.e. below the minimum value of the bimodal distributions, units are not variable, and hence, 0. 
```{r}
data_diversity_filtered_recomb_cat_zero_variable <- data_diversity_filtered_recomb_cat %>% 
  dplyr::mutate (watterson_zero = ifelse (pop=="c_lp_sm_n019"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_lp_sm_n019")$min_density_value_watterson) | 
pop=="c_lp_do_n012"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_lp_do_n012")$min_density_value_watterson) | 
pop=="c_ll_ki_n013"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_ll_ki_n013")$min_density_value_watterson) | 
pop=="c_ll_po_n008"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_ll_po_n008")$min_density_value_watterson) | 
pop=="c_ll_no_n008"&log10(watterson_ave)<(filter(density_min_values_watterson,pop=="c_ll_no_n008")$min_density_value_watterson),0,watterson_ave)) %>% 
  dplyr::mutate (pairwise_zero = ifelse (pop=="c_lp_sm_n019"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_lp_sm_n019")$min_density_value_pairwise) | 
pop=="c_lp_do_n012"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_lp_do_n012")$min_density_value_pairwise) | 
pop=="c_ll_ki_n013"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_ll_ki_n013")$min_density_value_pairwise) | 
pop=="c_ll_po_n008"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_ll_po_n008")$min_density_value_pairwise) | 
pop=="c_ll_no_n008"&log10(pairwise_ave)<(filter(density_min_values_pairwise,pop=="c_ll_no_n008")$min_density_value_pairwise),0,pairwise_ave)) %>%
  dplyr::mutate(tajimaD_transformed = ifelse(watterson_zero!="0" | pairwise_zero!="0", tajimaD, NA)) %>% select (-tajimaD) %>%  dplyr::rename(.,"tajimaD"="tajimaD_transformed")

rm (data_diversity_filtered_recomb_cat)
```

## 5. Rename & order factors
```{r}
data_diversity_filtered_recomb_cat_zero_variable$Populations <- factor (data_diversity_filtered_recomb_cat_zero_variable$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))
data_diversity_filtered_recomb_cat_zero_variable$feature <- plyr::revalue(data_diversity_filtered_recomb_cat_zero_variable$feature, c("intergenic"="Intergenic", "promoter_gene_1000"="Gen_promoter", "5UTR"="5UTR", "CDS"="CDS", "intron"="Intron", "3UTR"="3UTR", "promoter_lncRNA_1000"="lncRNA_promoter", "lncRNA"="lncRNA_exons", "intron_lncRNA"="lncRNA_intron", "ncRNA"="ncRNA", "UCNE"="UCNE"))
data_diversity_filtered_recomb_cat_zero_variable$feature <- factor (data_diversity_filtered_recomb_cat_zero_variable$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))
```
## 6. Autosomes vs chrX
Now I split my data.frame between X and autosomes. 
Consideramos como autosomicas todas aquellas posiciones que no estén en un cromosoma chrX.
```{r}
data_diversity_filtered_autosomes <- data_diversity_filtered_recomb_cat_zero_variable %>% dplyr::filter (chr!="chrX") %>% dplyr::mutate (type_chr="autosomes")
data_diversity_filtered_chrX <- data_diversity_filtered_recomb_cat_zero_variable %>% dplyr::filter (chr=="chrX") %>% dplyr::mutate (type_chr="chrX")
rm (data_diversity_filtered_recomb_cat_zero_variable)
```
## 7. Corrected with intergenic
Corrijo los valores individuales para la media de intergénico
Los datos para qcada poblacion van a tener el mismo dibujo, pero en los ratios si afecta.
Primero calculo los valores para intergénico para poder corregir por ellos, de media y mediana, pero voy a usar media para corregir. La media o mediana que uso para corregir es la sacada de los valores originales, no la que contempla los ceros, pero en realidad estos valores corregidos no se van a usar en ningún análisis posterior, aunque los dejo, por si necesitasemos usarlos en el futuro.
```{r}
# Autosomes
autosomes_intergenic_average_values <- data_diversity_filtered_autosomes  %>% dplyr::filter (feature=="Intergenic") %>% dplyr::group_by(pop) %>%
             dplyr::summarise(
                       total_count=n(), 
                       mean_watterson_ave_intergenic=mean(watterson_ave),
                       mean_pairwise_ave_intergenic=mean(pairwise_ave),
                       median_watterson_ave_intergenic=median(watterson_ave),
                       median_pairwise_ave_intergenic=median(pairwise_ave),
                      # Values considering zeros.
                       mean_watterson_ave_zero_intergenic=mean(watterson_zero),
                       mean_pairwise_ave_zero_intergenic=mean(pairwise_zero),
                       median_watterson_ave_zero_intergenic=median(watterson_zero),
                       median_pairwise_ave_zero_intergenic=median(pairwise_zero))

# ChrX:
chrX_intergenic_average_values <- data_diversity_filtered_chrX  %>% dplyr::filter (feature=="Intergenic") %>% dplyr::group_by(pop) %>%
             dplyr::summarise(
                       total_count=n(), 
                       mean_watterson_ave_intergenic=mean(watterson_ave),
                       mean_pairwise_ave_intergenic=mean(pairwise_ave),
                       median_watterson_ave_intergenic=median(watterson_ave),
                       median_pairwise_ave_intergenic=median(pairwise_ave),
                      # Values considering zeros.
                       mean_watterson_ave_zero_intergenic=mean(watterson_zero),
                       mean_pairwise_ave_zero_intergenic=mean(pairwise_zero),
                       median_watterson_ave_zero_intergenic=median(watterson_zero),
                       median_pairwise_ave_zero_intergenic=median(pairwise_zero))

# Saco las tablas para cada población y añado una columna en la que corrijo por la media de pairwise, per unit. 
# Los valores calculados, también me servirán a posteriori para calcular la mediana corregida. 
# Realmente aunque no vaya a usar los valores corregidos esto es util pq separo en poblaciones
POPS=c("c_ll_ki_n013","c_ll_no_n008","c_ll_po_n008", "c_lp_sm_n019","c_lp_do_n012")
for (POP in POPS)
{
  print (POP)
  # 1.- Media de intergénico por poblacion.
  ## autosomes
  autosomes_pairwise_average_intergenic_per_unit <- as.numeric(autosomes_intergenic_average_values %>% dplyr::filter (pop==as.character(POP)) %>% dplyr::select (mean_pairwise_ave_intergenic)) 
  autosomes_watterson_average_intergenic_per_unit <- as.numeric(autosomes_intergenic_average_values %>% dplyr::filter (pop==as.character(POP)) %>% dplyr::select (mean_watterson_ave_intergenic))
  dataframe_autosomes <-  data_diversity_filtered_autosomes %>%  dplyr::filter (pop==as.character(POP)) %>% 
  mutate(pairwise_ave_corrected = pairwise_ave/autosomes_pairwise_average_intergenic_per_unit) %>%  
  mutate(watterson_ave_corrected= watterson_ave/autosomes_watterson_average_intergenic_per_unit) 
   assign(paste(POP,"_autosomes_diversity", sep=""), dataframe_autosomes)
  rm (dataframe_autosomes)
   ## chrX
  chrX_pairwise_average_intergenic_per_unit <- as.numeric(chrX_intergenic_average_values %>% dplyr::filter (pop==as.character(POP)) %>% dplyr::select (mean_pairwise_ave_intergenic)) 
  chrX_watterson_average_intergenic_per_unit <- as.numeric(chrX_intergenic_average_values %>% dplyr::filter (pop==as.character(POP)) %>% dplyr::select (mean_watterson_ave_intergenic))
    dataframe_chrX <-  data_diversity_filtered_chrX %>%  dplyr::filter (pop==as.character(POP)) %>% 
  mutate(pairwise_ave_corrected = pairwise_ave/chrX_pairwise_average_intergenic_per_unit) %>%  
  mutate(watterson_ave_corrected = watterson_ave/chrX_watterson_average_intergenic_per_unit) 
    assign(paste(POP,"_chrX_diversity", sep=""), dataframe_chrX)
  rm (dataframe_chrX)
}
```
## 8. Fusiono y escribo tablas
```{r}
c_ll_ki_n013_diversity <- rbind (c_ll_ki_n013_autosomes_diversity, c_ll_ki_n013_chrX_diversity ) %>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
c_ll_no_n008_diversity <- rbind (c_ll_no_n008_autosomes_diversity, c_ll_no_n008_chrX_diversity )%>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
c_ll_po_n008_diversity <- rbind (c_ll_po_n008_autosomes_diversity, c_ll_po_n008_chrX_diversity )%>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
c_lp_sm_n019_diversity <- rbind (c_lp_sm_n019_autosomes_diversity, c_lp_sm_n019_chrX_diversity )%>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
c_lp_do_n012_diversity <- rbind (c_lp_do_n012_autosomes_diversity, c_lp_do_n012_chrX_diversity )%>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
### Autosomas
data_diversity_autosomes_filtered_ave_corrected <- rbind (c_ll_ki_n013_autosomes_diversity, c_ll_no_n008_autosomes_diversity, c_ll_po_n008_autosomes_diversity,  c_lp_sm_n019_autosomes_diversity, c_lp_do_n012_autosomes_diversity) %>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
### ChrX
data_diversity_chrX_filtered_ave_corrected <- rbind (c_ll_ki_n013_chrX_diversity, c_ll_no_n008_chrX_diversity, c_ll_po_n008_chrX_diversity,  c_lp_sm_n019_chrX_diversity, c_lp_do_n012_chrX_diversity) %>% 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA)))))) 
# Uno ambas tablas
data_diversity_filtered_ave_corrected <- rbind (data_diversity_autosomes_filtered_ave_corrected, data_diversity_chrX_filtered_ave_corrected)
rm (data_diversity_filtered_autosomes)
rm (data_diversity_filtered_chrX)

# Las guardo para luego poder hacer más comodo las comparaciones entre poblaciones.

write.table(c_ll_ki_n013_diversity, paste(wd,"c_ll_ki_n013_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(c_ll_no_n008_diversity, paste(wd,"c_ll_no_n008_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(c_ll_po_n008_diversity, paste(wd,"c_ll_po_n008_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(c_lp_sm_n019_diversity, paste(wd,"c_lp_sm_n019_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(c_lp_do_n012_diversity, paste(wd,"c_lp_do_n012_diversity.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
write.table(data_diversity_filtered_ave_corrected, paste(wd,"data_diversity_filtered_ave_corrected.csv",sep=""), quote = F,  row.names = F, sep =";", dec="." )
```

# -----------------------------------------------------------------
# -----------------------------------------------------------------
# START THE ANALYSIS
# Diversity per pop
## Load library & wd
```{r}
library(viridis)
library(ggplot2); theme_set(theme_minimal())
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(arules)
library(boot)
library(broom)
library(Hmisc)

wd <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/"
wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/per_pop/"
```

## Load table 
```{r}
data_diversity_filtered_ave_corrected <- read.table(paste(wd, "data_diversity_filtered_ave_corrected.csv", sep=""), header=T, na.strings = c("NA", "na"), row.names = NULL, stringsAsFactors = F, sep =";", dec=".") %>% 
  # No se pq no reconoce estos caracteres, así que los tengo que volver a añadir. 
  mutate (., color =  ifelse (Populations == "NE-Poland", viridis_pal()(5)[3], 
                      ifelse (Populations == "Kirov", viridis_pal()(5)[1], 
                      ifelse (Populations == "Norway", viridis_pal()(5)[2], 
                      ifelse (Populations == "Andujar", "#5DC863FF",
                      ifelse (Populations == "Doñana", "#FDE725FF", NA))))))

data_diversity_filtered_ave_corrected$Populations <- factor (data_diversity_filtered_ave_corrected$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))

data_diversity_filtered_ave_corrected$feature <- factor (data_diversity_filtered_ave_corrected$feature, levels=c("Intergenic", "Gen_promoter", "5UTR", "CDS", "Intron", "3UTR", "lncRNA_promoter", "lncRNA_exons", "lncRNA_intron", "ncRNA", "UCNE"))
```
# ----------
## Population metrics
Primero creo una formula para poder calcular la stdev basada en bootstrapping.
```{r}
sample.wtd.mean <- function(x, w, d) {
    return(weighted.mean(x = x[d], w = w[d], na.rm=T ))}
```

### Summary stats per pop
Now I group the data based on population.
```{r}
diversity_stats_pop <- function(DATAFRAME)
{
  diversity_stats_df <- 
             DATAFRAME %>% 
    # Esto zero - zero lo calculo para luego poder sacar el 95% de la distribución par los GO term de interes. 
             mutate(watterson_zero_zero=ifelse(watterson_zero==0, NA,watterson_zero)) %>% 
             mutate(pairwise_zero_zero=ifelse(pairwise_zero==0, NA,pairwise_zero)) %>% 
             dplyr::group_by(Populations) %>%
             dplyr::summarise(
                       total_count=n(), 
                       # Distribución sin corregir
                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       se_wmean_watterson_boot = sd(boot(watterson_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_pairwise_ave=weighted.mean(pairwise_ave,w=informative_sites),
                       se_wmean_pairwise_boot = sd(boot(pairwise_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_tajimaD=weighted.mean(tajimaD,w=informative_sites, na.rm = TRUE),
                       se_wmean_tajimaD_boot = sd(boot(tajimaD, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),
                       mean_tajimaD=mean(tajimaD, na.rm = TRUE),
                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),
                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),
                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),
                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),
                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,
                       lowerw_watterson_ave = q25_watterson_ave - 1.5 * IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5 * IQR_pairwise_ave,
                       upperw_watterson_ave = q75_watterson_ave + 1.5 * IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5 * IQR_pairwise_ave) %>% 
  mutate (., Species =ifelse (Populations == "NE_Poland", "L.lynx",
                            ifelse (Populations == "Kirov", "L.lynx",
                            ifelse (Populations == "c_ll_no_n008", "L.lynx",  
                            ifelse (Populations == "Andujar", "L.pardinus", 
                            ifelse (Populations == "Donana", "L.pardinus", NA))))))
diversity_stats_df$Populations <- factor (diversity_stats_df$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar", "Donana"))
return(diversity_stats_df)
}

# Creo las tablas
stats_df_pop_autosomes <- diversity_stats_pop(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes")) %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX <- diversity_stats_pop(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX")) %>%  mutate (type_chr="chrX")
# Las fusiono y las guardo
stats_df_pop <- rbind (stats_df_pop_autosomes, stats_df_pop_chrX)
write.table(stats_df_pop, paste(wd_output,"stats_diversity_per_pop.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
#rm (stats_df_pop_autosomes)
#rm (stats_df_pop_chrX)
```

### Summary stats per pop & different group (feature, chr, region, recom_category) 

```{r}
diversity_stats_grouped <- function(DATAFRAME ,GROUP)
{ diversity_stats_df_grouped <- 
             DATAFRAME %>% 
             dplyr::group_by_("Populations",GROUP) %>%
             dplyr::mutate(watterson_zero_zero=ifelse(watterson_zero==0, NA,watterson_zero)) %>% 
             dplyr::mutate(pairwise_zero_zero=ifelse(pairwise_zero==0, NA,pairwise_zero)) %>% 
             dplyr::summarise(
                       total_count=n(), 
                       # Valores sin corregir
                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       se_wmean_watterson_boot = sd(boot(watterson_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_pairwise_ave=weighted.mean(pairwise_ave,w=informative_sites),
                       se_wmean_pairwise_boot = sd(boot(pairwise_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_tajimaD=weighted.mean(tajimaD,w=informative_sites, na.rm = TRUE),
                       se_wmean_tajimaD_boot = sd(boot(tajimaD, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),
                       mean_tajimaD=mean(tajimaD, na.rm = TRUE),
                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),
                       median_tajimaD=median(tajimaD, na.rm = TRUE),
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),
                       q25_tajimaD=quantile(tajimaD,0.25, na.rm = TRUE),
                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),
                       q75_tajimaD=quantile(tajimaD,0.75, na.rm = TRUE),
                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),
                       q05_tajimaD=quantile(tajimaD,0.05, na.rm = TRUE),
                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),
                       q95_tajimaD=quantile(tajimaD,0.95, na.rm = TRUE),
                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,
                       IQR_tajimaD       = q75_tajimaD       - q25_tajimaD ,
                       lowerw_watterson_ave = q25_watterson_ave - 1.5* IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5* IQR_pairwise_ave,
                       lowerw_tajimaD       = q25_tajimaD       - 1.5* IQR_tajimaD,
                       upperw_watterson_ave = q75_watterson_ave + 1.5* IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5* IQR_pairwise_ave,
                       # Valores recombinación
                       mean_recombination_rate=mean(recombination_rate, na.rm=TRUE),
                       wmean_recombination_rate=weighted.mean(recombination_rate,w=informative_sites, na.rm=TRUE),
                       # Valores divergencia
                       mean_divergence_rate=mean(divergence, na.rm=TRUE),
                       wmean_divergence_rate=weighted.mean(divergence,w=informative_sites_substitutions, na.rm=TRUE)) %>% 
  dplyr::mutate (., Species =ifelse (Populations == "NE_Poland", "L.lynx",
                            ifelse (Populations == "Kirov", "L.lynx", 
                            ifelse (Populations == "Norway", "L.lynx", 
                            ifelse (Populations == "Andujar", "L.pardinus",
                            ifelse (Populations == "Donana", "L.pardinus", NA))))))
diversity_stats_df_grouped$Populations <- factor (diversity_stats_df_grouped$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar","Donana"))
if("chr" %in% colnames(diversity_stats_df_grouped))
{diversity_stats_df_grouped$chr <- factor(diversity_stats_df_grouped$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}
return (diversity_stats_df_grouped)
}

# Hacemos la tablas
stats_df_pop_autosomes_feature <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "feature") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_feature <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX"), "feature") %>%  mutate (type_chr="chrX")
stats_df_pop_autosomes_region  <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "region") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_region  <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX"), "region") %>%  mutate (type_chr="chrX")
stats_df_pop_chr     <- diversity_stats_grouped(data_diversity_filtered_ave_corrected, "chr")
stats_df_pop_autosomes_recomb <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "discrete_recomb") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_recomb <- diversity_stats_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX"), "discrete_recomb") %>%  mutate (type_chr="chrX")

# Fusiono y guardo
stats_df_pop_feature <- rbind (stats_df_pop_autosomes_feature, stats_df_pop_chrX_feature)
stats_df_pop_region <- rbind (stats_df_pop_autosomes_region, stats_df_pop_chrX_region)
stats_df_pop_recomb <- rbind (stats_df_pop_autosomes_recomb_category, stats_df_pop_chrX_recomb_category)
  
write.table(stats_df_pop_feature, paste(wd_output,"stats_diversity_per_pop_per_feature.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region, paste(wd_output,"stats_diversity_per_pop_per_region.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_chr, paste(wd_output,"stats_diversity_per_pop_per_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_recomb, paste(wd_output,"stats_diversity_per_pop_per_recomb.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

#rm (stats_df_pop_autosomes_feature)
#rm (stats_df_pop_chrX_feature)
#rm (stats_df_pop_autosomes_region)
#rm (stats_df_pop_chrX_region)
```


###  Summary stats per pop & different group - group (feature-chr, feature-region, chr-region) 


```{r}

diversity_stats_doble_grouped <- function(DATAFRAME, GROUP1, GROUP2)
{ diversity_stats_df_doble_grouped <- 
             DATAFRAME %>% 
             dplyr::group_by_("Populations",GROUP1, GROUP2) %>%
             dplyr::summarise(
                       total_count=n(), 
                       wmean_watterson_ave=weighted.mean(watterson_ave,w=informative_sites),
                       se_wmean_watterson_boot = sd(boot(watterson_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_pairwise_ave=weighted.mean(pairwise_ave,w=informative_sites),
                       se_wmean_pairwise_boot = sd(boot(pairwise_ave, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       wmean_tajimaD=weighted.mean(tajimaD,w=informative_sites, na.rm = TRUE),
                       se_wmean_tajimaD_boot = sd(boot(tajimaD, sample.wtd.mean, R = 100, w = informative_sites)$t),
                       mean_watterson_ave=mean(watterson_ave),
                       mean_pairwise_ave=mean(pairwise_ave),
                       mean_tajimaD=mean(tajimaD, na.rm = TRUE),
                       median_watterson_ave=median(watterson_ave),
                       median_pairwise_ave=median(pairwise_ave),
                       median_tajimaD=median(tajimaD, na.rm = TRUE),
                       q25_watterson_ave=quantile(watterson_ave,0.25),
                       q25_pairwise_ave=quantile(pairwise_ave,0.25),
                       q25_tajimaD=quantile(tajimaD,0.25, na.rm = TRUE),
                       q75_watterson_ave=quantile(watterson_ave,0.75),
                       q75_pairwise_ave=quantile(pairwise_ave,0.75),
                       q75_tajimaD=quantile(tajimaD,0.75, na.rm = TRUE),
                       q05_watterson_ave=quantile(watterson_ave,0.05),
                       q05_pairwise_ave=quantile(pairwise_ave,0.05),
                       q05_tajimaD=quantile(tajimaD,0.05, na.rm = TRUE),
                       q95_watterson_ave=quantile(watterson_ave,0.95),
                       q95_pairwise_ave=quantile(pairwise_ave,0.95),
                       q95_tajimaD=quantile(tajimaD,0.95, na.rm = TRUE),
                       IQR_watterson_ave = q75_watterson_ave - q25_watterson_ave,
                       IQR_pairwise_ave  = q75_pairwise_ave  - q25_pairwise_ave,
                       IQR_tajimaD       = q75_tajimaD       - q25_tajimaD ,
                       lowerw_watterson_ave = q25_watterson_ave - 1.5* IQR_watterson_ave,
                       lowerw_pairwise_ave  = q25_pairwise_ave  - 1.5* IQR_pairwise_ave,
                       lowerw_tajimaD       = q25_tajimaD       - 1.5* IQR_tajimaD,
                       upperw_watterson_ave = q75_watterson_ave + 1.5* IQR_watterson_ave,
                       upperw_pairwise_ave  = q75_pairwise_ave  + 1.5* IQR_pairwise_ave,
                       
                       # Valores recombinación
                       mean_recombination_rate=mean(recombination_rate, na.rm=TRUE),
                       wmean_recombination_rate=weighted.mean(recombination_rate,w=informative_sites, na.rm=TRUE),
                       
                       # Valores divergencia
                       mean_divergence_rate=mean(divergence, na.rm=TRUE),
                       wmean_divergence_rate=weighted.mean(divergence,w=informative_sites_substitutions, na.rm=TRUE)
                       ) %>% 
  mutate (., Species =ifelse (Populations == "NE_Poland", "L.lynx",
                            ifelse (Populations == "Kirov", "L.lynx",
                            ifelse (Populations == "Norway", "L.lynx", 
                            ifelse (Populations == "Andujar", "L.pardinus",
                            ifelse (Populations == "Donana", "L.pardinus", NA))))))

diversity_stats_df_doble_grouped$Populations <- factor (diversity_stats_df_doble_grouped$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar", "Donana"))
 if("chr" %in% colnames(diversity_stats_df_doble_grouped)){diversity_stats_df_doble_grouped$chr <- factor(diversity_stats_df_doble_grouped$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}
return (diversity_stats_df_doble_grouped)
}

# Hacemos la tablas
stats_df_pop_feature_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected, "feature", "chr")
stats_df_pop_region_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected, "region", "chr")
stats_df_pop_recomb_chr <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected, "discrete_recomb", "chr")

stats_df_pop_autosomes_feature_region <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "feature", "region") %>%  mutate (type_chr="autosomes")
stats_df_pop_autosomes_feature_recomb <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "feature", "discrete_recomb") %>%  mutate (type_chr="autosomes")
stats_df_pop_autosomes_region_recomb <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), "region", "discrete_recomb") %>%  mutate (type_chr="autosomes")

stats_df_pop_chrX_feature_region <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX"), "feature", "region") %>%  mutate (type_chr="chrX")
stats_df_pop_chrX_feature_recomb <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX"), "feature", "discrete_recomb") %>%  mutate (type_chr="chrX")
stats_df_pop_chrX_region_recomb <- diversity_stats_doble_grouped(data_diversity_filtered_ave_corrected %>% filter (type_chr=="chrX"), "region", "discrete_recomb") %>%  mutate (type_chr="chrX")

# Fusiono y guardo
stats_df_pop_feature_region <- rbind (stats_df_pop_autosomes_feature_region, stats_df_pop_chrX_feature_region)
stats_df_pop_feature_recomb <- rbind (stats_df_pop_autosomes_feature_recomb, stats_df_pop_chrX_feature_recomb)
stats_df_pop_region_recomb <- rbind (stats_df_pop_autosomes_region_recomb, stats_df_pop_chrX_region_recomb)

write.table(stats_df_pop_feature_chr, paste(wd_output,"stats_diversity_per_pop_per_feature_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region_chr, paste(wd_output,"stats_diversity_per_pop_per_region_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_recomb_chr, paste(wd_output,"stats_diversity_per_pop_per_recomb_chr.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_feature_region, paste(wd_output,"stats_diversity_per_pop_per_feature_region.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_feature_recomb, paste(wd_output,"stats_diversity_per_pop_per_feature_recomb.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region_recomb, paste(wd_output,"stats_diversity_per_pop_per_region_recomb.tsv",sep=""),quote = F,  row.names = F, sep =";", dec="," )

#rm (stats_df_pop_autosomes_feature_region)
#rm (stats_df_pop_chrX_feature_region)

```

# ----------

## *Plot basic stats

## Set up colours

```{r}
cols <- c("NE_Poland"=viridis_pal()(5)[3], 
          "Kirov"=viridis_pal()(5)[1], 
          "Norway"=viridis_pal()(5)[2], 
          "Andujar"="#5DC863FF",
          "Donana"="#FDE725FF")
```

## *Unit size
```{r}
# Tamaño de las unidades
ggplot (data = data_diversity_filtered_ave_corrected, aes(length)) +
  geom_histogram() +
  scale_fill_viridis() +
  facet_wrap (~feature, scales = "free")
ggsave(paste (wd_output, "length_per_unit_all_pops.pdf", sep=""))

for (pop in unique(data_diversity_filtered_ave_corrected$Populations))
  {
  print (pop)
  ggplot (data=dplyr::filter(data_diversity_filtered_ave_corrected,data_diversity_filtered_ave_corrected$Populations==!!pop), aes(length)) +
  geom_histogram() +
  scale_fill_viridis() +
  facet_wrap (~feature, scales = "free") 
  ggsave(paste (wd_output, "length_per_unit_",pop,".pdf", sep="" ), device="pdf")
  }
```

## *Recombination histogram

```{r}
# Hacemos un plot para ver la distribución de los valores, cogemos por ejemplo la población de kirov.
ggplot(filter(data_diversity_filtered_ave_corrected, pop=="c_ll_ki_n013"), aes(x=recombination_rate)) + 
  geom_histogram(binwidth=1, color="black", fill="white") +
  ggsave(paste (wd_output, "histogram_recombination_rate.pdf", sep=""))
```


## *Recombination and diversity

```{r}
ggplot() + 
  geom_point (data=subset(stats_df_pop_autosomes_recomb, !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_autosomes_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_autosomes.pdf",sep=""))


ggplot() + 
  geom_point (data=subset(stats_df_pop_autosomes_recomb, !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_autosomes_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_autosomes.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_chrX_recomb, !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_chrX_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_chrX.pdf",sep=""))


ggplot() + 
  geom_point (data=subset(stats_df_pop_autosomes_recomb, !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_autosomes_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~Species, ncol=1, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_chrX.pdf",sep=""))
  
  

# ggplot(data_diversity_autosomes_filtered_ave_corrected,aes(recombination_rate,watterson_ave))+
#   geom_point() +
#   scale_color_viridis(discrete=TRUE) +
#   scale_fill_viridis(discrete=TRUE) +
#   facet_grid(~pop)
# 
# ggplot(data_diversity_autosomes_filtered_ave_corrected,aes(recombination_rate,pairwise_ave, fill=pop, colour=pop))+
#   geom_point() +
#   scale_color_viridis(discrete=TRUE) +
#   scale_fill_viridis(discrete=TRUE) +
#   facet_grid(~pop)

```

## *Recombination and regions

```{r}

ggplot() + 
  geom_point (data=subset(stats_df_pop_autosomes_region_recomb, !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_autosomes_region_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(region~Populations, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_per_region.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_autosomes_region_recomb, !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_autosomes_region_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(region~Populations, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_per_region.pdf",sep=""))
  
  

  
ggplot(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), aes(region,recombination_rate))+
  geom_boxplot() + #geom_violin
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
 ggsave(paste (wd_output, "boxplot_violin_plot/","recombination_rate_per_region.pdf", sep="" ))


ggplot(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"), aes(region,recombination_rate))+
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
 ggsave(paste (wd_output, "boxplot_violin_plot/","recombination_rate_per_region_mean_se.pdf", sep="" ))


```
## *Recombination and features

```{r}

ggplot() + 
  geom_point (data=subset(stats_df_pop_autosomes_feature_recomb , !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_autosomes_feature_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~feature, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_per_feature_autosomes.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_autosomes_feature_recomb , !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_autosomes_feature_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~feature, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_per_feature_autosomes.pdf",sep=""))
  
  
  ggplot() + 
  geom_point (data=subset(stats_df_pop_chrX_feature_recomb , !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_watterson_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_chrX_feature_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_watterson_ave-se_wmean_watterson_boot, yend = wmean_watterson_ave+se_wmean_watterson_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~feature, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_watterson_per_feature_chrX.pdf",sep=""))
  
  
ggplot() + 
  geom_point (data=subset(stats_df_pop_chrX_feature_recomb , !is.na(discrete_recomb)), 
              aes(x=discrete_recomb, y=wmean_pairwise_ave, fill=Populations, colour=Populations)) +
  geom_segment (data=subset(stats_df_pop_chrX_feature_recomb, !is.na(discrete_recomb)), 
                aes(x = discrete_recomb, xend=discrete_recomb, y = wmean_pairwise_ave-se_wmean_pairwise_boot, yend = wmean_pairwise_ave+se_wmean_pairwise_boot, colour=Populations)) +
  scale_colour_manual(values = cols) +
  scale_fill_manual(values = cols) +
  facet_wrap(~feature, ncol=3, scales="free_y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggsave(paste(wd_output,"recombination_categories_vs_pairwise_per_feature_chrX.pdf",sep=""))

   
```
## **Divergence and regions

```{r}

ggplot(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"),aes(region,divergence))+
  geom_boxplot() + #geom_violin
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
 ggsave(paste (wd_output, "boxplot_violin_plot/","divergence_per_region.pdf", sep="" ))


ggplot(data_diversity_filtered_ave_corrected %>% filter (type_chr=="autosomes"),aes(region,divergence))+
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
 ggsave(paste (wd_output, "boxplot_violin_plot/","divergence_per_region_mean_se.pdf", sep="" ),height = 7, width = 7)


```


### Empirical boxplot & violin plot 

```{r}

library(rlang)

# Diversidad por población para cada especie y para cada indice
## BOXPLOT

# Feature and region in autosomes

INDICES=c("watterson_ave", "pairwise_ave")
GROUPS=c("feature", "region")

for (SPECIE in unique(data_diversity_autosomes_filtered_ave_corrected$specie))
{print (SPECIE)
  for (INDEX in INDICES)
  {print (INDEX)
    for (GROUP in GROUPS)
    {print (GROUP)
      # BOXPLOT
      ggplot(data=filter(data_diversity_autosomes_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
        geom_boxplot(outlier.shape=NA, color="black") +
        facet_grid(reformulate(GROUP), scales="free", switch="x") +
        scale_color_viridis(discrete=TRUE) +
        scale_fill_viridis(discrete=TRUE) +
        scale_y_continuous(trans = 'log10') +
        scale_x_discrete(GROUP) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
             # panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output, "boxplot_violin_plot/",INDEX,"_per_",GROUP,"_",SPECIE,"_autosomes_boxplot.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      
      # VIOLIN
      
      ggplot(data=filter(data_diversity_autosomes_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
        geom_violin() +
        facet_grid(reformulate(GROUP), scales="free", switch="x") +
        scale_y_continuous(trans = 'log10') +
        scale_x_discrete(GROUP) +
        scale_color_viridis(discrete=TRUE) +
        scale_fill_viridis(discrete=TRUE) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
            #  panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output,"boxplot_violin_plot/", INDEX,"_per_",GROUP,"_",SPECIE,"_autosomes_violin.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      
    }
  }
}

# Para cromosomas (teniendo en cuenta la tabla con autosomas + chr chrXes)

INDICES=c("watterson_ave", "pairwise_ave")
GROUPS=c("chr")

for (SPECIE in unique(data_diversity_filtered_ave_corrected$specie))
{print (SPECIE)
  for (INDEX in INDICES)
  {print (INDEX)
    for (GROUP in GROUPS)
    {print (GROUP)
      # BOXPLOT
      ggplot(data=filter(data_diversity_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
        geom_boxplot(outlier.shape=NA, color="black") +
        facet_grid(reformulate(GROUP), scales="free", switch="x") +
        scale_y_continuous(trans = 'log10') +
        scale_x_discrete(GROUP) +
        scale_color_viridis(discrete=TRUE) +
        scale_fill_viridis(discrete=TRUE) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
             # panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output, "boxplot_violin_plot/",INDEX,"_per_",GROUP,"_",SPECIE,"_boxplot.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      
      # VIOLIN
      
      ggplot(data=filter(data_diversity_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
        geom_violin() +
        facet_grid(reformulate(GROUP), scales="free", switch="x") +
        scale_y_continuous(trans = 'log10') +
        scale_x_discrete(GROUP) +
        scale_color_viridis(discrete=TRUE) +
        scale_fill_viridis(discrete=TRUE) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
            #  panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output,"boxplot_violin_plot/", INDEX,"_per_",GROUP,"_",SPECIE,"_violin.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      
    }
  }
}

```

### Empirical average considering ceros --> No lo corro

No lo corro.

```{r}

DATAFRAMES=c("stats_df_chr", "stats_df_feature","stats_df_region")
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="pairwise_zero", fill="Populations", color="Populations")) +
      geom_point() +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]), scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_pairwise_zero_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="watterson_zero", fill="Populations", color="Populations")) +
      geom_point() +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]), scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_watterson_zero_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    
   
   }
}

  
```


### Empirical weighted average --> No lo corro

No lo corro.

```{r}

DATAFRAMES=c("stats_df_chr", "stats_df_feature","stats_df_region")
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="wmean_pairwise_ave", fill="Populations", color="Populations")) +
      geom_point() +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]), scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"wmean_pairwise_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="wmean_watterson_ave", fill="Populations", color="Populations")) +
      geom_point() +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]), scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"wmean_watterson_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="wmean_tajimaD", fill="Populations", color="Populations")) +
      geom_point() +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]), scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"wmean_tajimaD_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
   }
}

  
```


### Empirical corrected value per pop --> No lo corro. 

No corro esto pq el dibujo es el mismo, y por tanto no tiene mucho sentido. 
Opcionalmente también boxplot y violin plot.

```{r}

library(rlang)
# Diversidad por población para cada especie y para cada indice
## BOXPLOT

INDICES=c("corrected_by_pairwise_average_intergenic_per_unit", "corrected_by_watterson_average_intergenic_per_unit")
GROUPS=c("feature")

for (SPECIE in unique(diversity_stats_df_feature_corrected$specie))
{print (SPECIE)
  for (INDEX in INDICES)
  {print (INDEX)
    for (GROUP in GROUPS)
    {print (GROUP)
      
      ggplot(data=filter(diversity_stats_df_feature_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations", color="Populations")) +
        geom_point() +
        facet_grid(~feature, scales="free", switch="x") +
        scale_x_discrete(GROUP) +
        xlab(label = "Genomic region") + #x title
        ylab(label = paste(INDEX)) + # y title
        # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
        theme(
              axis.line.y = element_line(color="black", size = 0.5),
              # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
              axis.text.x = element_blank(),
              axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
              axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
              axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
              #panel.grid.major = element_blank(),
              #panel.grid.minor = element_blank(),
              panel.border = element_blank(),
              panel.background = element_blank(),
              strip.background = element_blank(),
              strip.text = element_text(angle = 90))
              #panel.spacing = unit(1.5, "lines"))
      ggsave(paste (wd_output, INDEX,"_per_",GROUP,"_",SPECIE,".pdf", sep="" ),  device="pdf")
      
      
      # BOXPLOT
      # ggplot() +
      #   geom_boxplot(data=filter(data_diversity_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations"), color="black") +
      #   facet_grid(reformulate(GROUP), scales="free", switch="x") +
      #   scale_y_continuous(trans = 'log10') +
      #   scale_x_discrete(GROUP) +
      #   xlab(label = "Genomic region") + #x title
      #   ylab(label = paste(INDEX)) + # y title
      #   # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
      #   theme(
      #         axis.line.y = element_line(color="black", size = 0.5),
      #         # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
      #         axis.text.x = element_blank(),
      #         axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
      #         axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
      #         axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
      #         panel.grid.major = element_blank(),
      #         panel.grid.minor = element_blank(),
      #         panel.border = element_blank(),
      #         panel.background = element_blank(),
      #         strip.background = element_blank(),
      #         strip.text = element_text(angle = 90),
      #         panel.spacing = unit(1.5, "lines"))
      # ggsave(paste (wd_output, INDEX,"_per_",GROUP,"_",SPECIE,"_boxplot.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      # 
      # # VIOLIN
      # 
      # ggplot(data=filter(data_diversity_filtered_ave_corrected,specie==!!SPECIE), aes_string(x="Populations", y = INDEX, fill="Populations")) +
      #   geom_violin(color="black") +
      #   facet_grid(reformulate(GROUP), scales="free", switch="x") +
      #   scale_y_continuous(trans = 'log10') +
      #   scale_x_discrete(GROUP) +
      #   xlab(label = "Genomic region") + #x title
      #   ylab(label = paste(INDEX)) + # y title
      #   # scale_x_continuous(expand = c(0, 1)) +# + scale_y_continuous(expand = c(0, 0)) +
      #   theme(
      #         axis.line.y = element_line(color="black", size = 0.5),
      #         # axis.text.x = element_text(angle = 60, vjust = 0.8, hjust = 1),
      #         axis.text.x = element_blank(),
      #         axis.text.y = element_text(vjust = 0.2, hjust = 0.2),
      #         axis.title.y = element_text(margin=margin(r=0.3, unit="cm")),
      #         axis.title.x = element_text(margin=margin(t=0.5, unit="cm")),
      #         panel.grid.major = element_blank(),
      #         panel.grid.minor = element_blank(),
      #         panel.border = element_blank(),
      #         panel.background = element_blank(),
      #         strip.background = element_blank(),
      #         strip.text = element_text(angle = 90),
      #         panel.spacing = unit(1.5, "lines"))
      # ggsave(paste (wd_output, INDEX,"_per_",GROUP,"_",SPECIE,"_violin.pdf", sep="" ),  width = 50, height = 60, units = "cm", device="pdf")
      # 
      
      
      
    }
  }
}



```

# ---------------------------------------

## Cat info join

A nivel de chr podemos sacar muchas cosillas. Vamos a hacer un join de las tablas de información con las de diversidad y vamos a plotear algunas cosillas básicas.

```{r}

# Cargo la tabla con la información de gato.
cat_chr_info <- read.table("/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/cat_chr_gene_content_recombination_all_information.txt", header=T, na.strings = c("NA", "na"), dec=",")


# Creo tablas con la información de diversidad y de cromosomas. 
stas_df_pop_chr_plus_cat_info <- right_join(x = cat_chr_info, y = stats_df_pop_chr, by="chr") 
stas_df_pop_chr_plus_cat_info$pop <- factor (stas_df_pop_chr_plus_cat_info$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar", "Donana"))

```

#### Chromosome divergence

Voy a sacar la divergencia por cromosoma porque no la tengo

```{r}

average_divergence_per_pop <- data_diversity_filtered_ave_corrected %>% 
             dplyr::group_by_("Species","chr") %>%
             dplyr::summarise(mean_divergence=mean(divergence,na.rm=TRUE)) 


  
  if("chr" %in% colnames(average_divergence_per_pop)){average_divergence_per_pop$chr <- factor(average_divergence_per_pop$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}


# ggplot (average_divergence_per_pop, aes(chr, mean_divergence, fill=Species, color=Species)) +
#   geom_point()

# Hacemos la tablas

average_divergence_per_pop_spread <- average_divergence_per_pop %>% tidyr::spread(., Species, mean_divergence ) %>% as.data.frame(.) %>% dplyr::rename(., "L.lynx_divergence"="L.lynx") %>% dplyr::rename(.,"L.pardinus_divergence"="L.pardinus")

# Lo uno a los datos de gato

cat_chr_info_divergence <- right_join(x = cat_chr_info, y = average_divergence_per_pop_spread, by="chr") 

# Lo uno también con los datos de diversidad
stas_df_pop_chr_plus_extra_info <- right_join(stas_df_pop_chr_plus_cat_info, average_divergence_per_pop, by=c("chr", "Species") )

```


### General plots cat info

```{r}

library(GGally)

# La filtro para hacer plots

cat_chr_info_filtered <- cat_chr_info_divergence %>% filter(., chr!="chrX") %>% select (SizeMb_v8, GC_content, percentage_genes, cM.Mb, L.lynx_divergence, L.pardinus_divergence)


# Hago una matriz de correlación entre las variables

res <- cor(cat_chr_info_filtered )
round(res, 2)
cor(cat_chr_info_filtered, use = "complete.obs")

# http://www.sthda.com/english/wiki/correlation-matrix-a-quick-start-guide-to-analyze-format-and-visualize-a-correlation-matrix-using-r-software
# library("PerformanceAnalytics")
# chart.Correlation(cat_chr_info_filtered, histogram=TRUE, pch=19)

lowerFn <- function(data, mapping, method = "lm", ...) {
  p <- ggplot(data = data, mapping = mapping) +
    geom_point(colour = "black") +
    geom_smooth(method = method, color = "black", ...) 
  p
}


pdf(paste(wd_output, "correlation_matrix_1.pdf", sep="")) 
ggpairs(cat_chr_info_filtered,  lower = list(continuous = wrap(lowerFn, method = "lm")))
dev.off()

# https://stackoverflow.com/questions/30858337/how-to-customize-lines-in-ggpairs-ggally
#  diag = list(continuous = wrap("barDiag", colour = "blue")),
#  upper = list(continuous = wrap("cor", size = 10))


# Primero unas cuantas cosillas básicas respecto a los chr.

# Cat chr version size comparison
# ggplot(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v5 ,y=SizeMb_v8)) +
#   geom_point(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v5 ,y=SizeMb_v8, fill=chr, colour=chr))+
#   geom_smooth() +
# ggtitle("Cat chr version size comparison")
# ggsave(paste(wd_output, "cat_chr_size_comparison.pdf", sep=""), device = pdf)
# 
# 
# ggplot(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v8 ,y=cM.Mb)) +
#   geom_point(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v8 ,y=cM.Mb, fill=chr, colour=chr)) +
#   geom_smooth()+
# ggtitle("Recombination_rate cat genome v8")
# ggsave(paste(wd_output, "cat_recombination_size_comparison.pdf", sep=""), device = pdf)
# 
# 
# ggplot(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v8, y=percentage_genes )) +
#   geom_point(data=(cat_chr_info %>% filter(chr!="chrX")), aes(x=SizeMb_v8 ,y=percentage_genes , fill=chr, colour=chr)) +
#   geom_smooth()+
# ggtitle("Gene content vs size cat genome v8")
# ggsave(paste(wd_output, "cat_size_vs_gene_content_comparison.pdf", sep=""), device = pdf)

```

### Plot join with diversity data

```{r}

library(ggpmisc)

# Para todo esto quitamos el cromosoma X porque es un outlier!!!

#### SANITY CHECKS #### 

# Comprobamos que la tasa de recombinación que nosotros tenemos para cada cromosoma cuando hacemos la media es parecida a la de los cromosomas. 

# ggplot (stas_df_pop_chr_plus_extra_info, aes(cM.Mb, mean_recombination_rate))+
#   geom_point()+
#   coord_equal(xlim=c(0,6),ylim=c(0,6))
# 
# 
# ggplot (stas_df_pop_chr_plus_extra_info, aes(cM.Mb, wmean_recombination_rate))+
#   geom_point()+
#   coord_equal(xlim=c(0,6),ylim=c(0,6))
# 
# 
# ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes(mean_recombination_rate, SizeMb_v8))+
#   geom_point() +
#     geom_smooth()

# Coincide regulín. 

######################## 

my.formula <- y ~ x
INDEXES=c("mean_watterson_ave", "mean_pairwise_ave") 

max((stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"))$mean_watterson_ave)
                                                                    
# Diversidad vs tamaño

for (INDEX in INDEXES)
  {
  
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("SizeMb_v8", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(pop~.) +
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.00003) +
#theme selection for background and lines
  ggsave(paste(wd_output, "cat_size_vs_",INDEX,".pdf", sep=""))

}
    
# Diversidad vs gene content


for (INDEX in INDEXES)
  {
  
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("percentage_genes", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  facet_wrap(pop~.) +
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.00003) +


#theme selection for background and lines
  ggsave(paste(wd_output, "cat_gene-content_vs_",INDEX,".pdf", sep=""))

}
    
# Diversidad vs chr recombination

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("cM.Mb", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(pop~.) +
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.00003) +
  ggsave(paste(wd_output, "cat_chr-recomb_vs_",INDEX,".pdf", sep=""))

}

# Diversidad vs GC content

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("GC_content", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(pop~.) +
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.00003) +
  ggsave(paste(wd_output, "cat_GC_content_vs_",INDEX,".pdf", sep=""))

}

# Diversidad vs divergence

for (INDEX in INDEXES)
  {
ggplot (stas_df_pop_chr_plus_extra_info %>% filter(chr!="chrX"), aes_string("mean_divergence", INDEX, fill="Populations" , colour="Populations")) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(pop~.) +
  scale_color_viridis(discrete=TRUE) +
  scale_fill_viridis(discrete=TRUE) +
  theme(axis.text.x = element_text(angle = 90))+
  stat_poly_eq(formula = my.formula,coef.digits=2 ,
                aes(label = paste(..eq.label..)), 
                parse = TRUE,label.y = 0) +  
  stat_poly_eq(formula = my.formula, 
                aes(label = paste(..rr.label..)), 
                parse = TRUE,label.y = 0.00003) +
  ggsave(paste(wd_output, "divergence_vs_",INDEX,".pdf", sep=""))

}

```

# ---------------------------------------

Esta sería la forma corta de hacerlo, no haría falta hacer el bootstrapping como hemos hecho, pero como ya está optimizado, lo seguimos haciendo así. 

```{r}
# 
# # BOOTSTRAPPING --> http://r.789695.n4.nabble.com/ggplot-stat-summary-mean-cl-boot-td4021218.html
#   
# ggplot (data=data_diversity_autosomes_filtered_ave_corrected, aes(Populations, pairwise_ave, colour = Populations, fill=Populations)) +
#       stat_summary(fun.data = "mean_cl_boot", size = 0.5) +
#   # smean.cl.boot(x, conf.int=.95, B=1000, na.rm=TRUE, reps=FALSE) 
#       facet_grid(Species~feature,  scales="free", switch="x") +
#       scale_color_viridis(discrete=TRUE) +
#       scale_fill_viridis(discrete=TRUE) +
#       theme(
#             axis.text.x = element_blank(),strip.text = element_text(angle = 90))+
#    scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) 
# 
```
## Boot data

```{r}

# Cargo la funcion de bootstrap
boot_mean <- function(original_vector, resample_vector) {
   mean(original_vector[resample_vector])
}

# Cargo la función global
diversity_stats_grouped_boot <- function(DATAFRAME ,GROUP)
{ 
  
    DATAFRAME_nested <- DATAFRAME %>% dplyr::group_by_("pop", GROUP) %>% tidyr::nest()
  pairwise_average <- DATAFRAME_nested %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$pairwise_ave), statistic = boot_mean, R = ITERATION))) %>% 
    dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
  names(pairwise_average)[3] <- "values"
  pairwise_average_summary <- pairwise_average  %>% 
    group_by_(.dots=c("pop", GROUP)) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values)) %>% 
    mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "NE_Poland",
                              ifelse (pop == "c_ll_ki_n013", "Kirov",
                              ifelse (pop == "c_ll_no_n008", "Norway", 
                              ifelse (pop == "c_lp_sm_n019", "Andujar",
                              ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
    mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                              ifelse (pop == "c_ll_ki_n013", "L.lynx", 
                              ifelse (pop == "c_ll_no_n008", "L.lynx", 
                              ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
                              ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))
  names(pairwise_average_summary)[3] <- "mean_pairwise_boot"
  names(pairwise_average_summary)[4] <- "sd_pairwise_boot"
  
  
        DATAFRAME_nested <- DATAFRAME %>% dplyr::group_by_("pop", GROUP) %>% tidyr::nest()
  watterson_average <- DATAFRAME_nested %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$watterson_ave), statistic = boot_mean, R = ITERATION))) %>% 
    dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
  names(watterson_average)[3] <- "values"
  watterson_average_summary <- watterson_average  %>% 
    group_by_(.dots=c("pop", GROUP)) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values)) %>%     
    mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "NE_Poland",
                              ifelse (pop == "c_ll_ki_n013", "Kirov",
                              ifelse (pop == "c_ll_no_n008", "Norway", 
                              ifelse (pop == "c_lp_sm_n019", "Andujar", 
                              ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
    mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                              ifelse (pop == "c_ll_ki_n013", "L.lynx",  
                              ifelse (pop == "c_ll_no_n008", "L.lynx", 
                              ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
                              ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))
  names(watterson_average_summary)[3] <- "mean_watterson_boot"
  names(watterson_average_summary)[4] <- "sd_watterson_boot"
  
  
  
  # DATAFRAME_nested <- DATAFRAME %>% dplyr::group_by_("pop", GROUP) %>% tidyr::nest()
  # tajimaD <- DATAFRAME_nested %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$tajimaD), statistic = boot_mean, R = ITERATION))) %>% 
  #   dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
  #   dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
  # names(tajimaD)[3] <- "values"
  # tajimaD_summary <- tajimaD  %>% 
  #   group_by_(.dots=c("pop", GROUP)) %>%
  #   dplyr::summarise(mean=mean(values),sd=sd(values)) %>% 
  #       mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "NE_Poland",
  #                             ifelse (pop == "c_ll_ki_n013", "Kirov",
  #                             ifelse (pop == "c_ll_no_n008", "Norway", 
  #                             ifelse (pop == "c_lp_sm_n019", "Andujar",
  #                             ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
  #   mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
  #                             ifelse (pop == "c_ll_ki_n013", "L.lynx",  
  #                             ifelse (pop == "c_ll_no_n008", "L.lynx", 
  #                             ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
  #                             ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))
  # names(tajimaD_summary)[3] <- "mean_tajimaD_boot"
  # names(tajimaD_summary)[4] <- "sd_tajimaD_boot"
  
  tmp_group <- full_join (watterson_average_summary, pairwise_average_summary, by = c("pop", GROUP, "Populations", "Species")) 
  tmp_group$Populations <- factor (tmp_group$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar", "Donana"))
  
  if("chr" %in% colnames(tmp_group))
{tmp_group$chr <- factor(tmp_group$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}
  
  
return (tmp_group)
 
  rm (tmp_group)
  rm (watterson_average)
  rm (watterson_average_summary)
  rm (pairwise_average)
  rm (pairwise_average_summary)
  rm (tajimaD)
  rm (tajimaD_summary)
  rm (DATAFRAME_nested)
  
}


ITERATION=100


# Genero las tablas

stats_df_pop_autosomes_feature_boostrapped <- diversity_stats_grouped_boot(data_diversity_autosomes_filtered_ave_corrected, "feature") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_feature_boostrapped <- diversity_stats_grouped_boot(data_diversity_chrX_filtered_ave_corrected, "feature") %>%  mutate (type_chr="chrX")

stats_df_pop_autosomes_region_boostrapped <- diversity_stats_grouped_boot(data_diversity_autosomes_filtered_ave_corrected, "region") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_region_boostrapped <- diversity_stats_grouped_boot(data_diversity_chrX_filtered_ave_corrected, "region") %>%  mutate (type_chr="chrX")

stats_df_pop_chr_boostrapped <- diversity_stats_grouped_boot(data_diversity_filtered_ave_corrected, "chr") 

# Fusiono y guardo

stats_df_pop_feature_boostrapped <- rbind (stats_df_pop_autosomes_feature_boostrapped, stats_df_pop_chrX_feature_boostrapped)
stats_df_pop_region_boostrapped <- rbind(stats_df_pop_autosomes_region_boostrapped,stats_df_pop_chrX_region_boostrapped)

rm(stats_df_pop_autosomes_feature_boostrapped)
rm(stats_df_pop_chrX_feature_boostrapped)
rm(stats_df_pop_autosomes_region_boostrapped)
rm(stats_df_pop_chrX_region_boostrapped)

write.table(stats_df_pop_feature_boostrapped, paste(wd_output,"stats_diversity_per_pop_per_feature_boostrapped.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region_boostrapped, paste(wd_output,"stats_diversity_per_pop_per_region_boostrapped.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_chr_boostrapped, paste(wd_output,"stats_diversity_per_pop_per_chr_boostrapped.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )


```

Nota:
He comprobado la normalidad en un caso concreto, pero creo que puede ser aplicable a todo.

Para el caso:
kk <- DATAFRAME_nested %>%  filter(pop=="c_ll_ki_n013") %>% filter(feature=="CDS")
shapiro.test(kk$boot_matrix)

Shapiro-Wilk normality test

data:  kk$boot_matrix
W = 0.99973, p-value = 0.8071

From the output, the p-value > 0.05 implying that the distribution of the data are not significantly different from normal distribution. In other words, we can assume the normality.

Así que perfecto!


## Plot Bootstrapped data

```{r}

# Ploteo los datos de bootstraping  

DATAFRAMES=c("stats_df_pop_feature_boostrapped","stats_df_pop_region_boostrapped")
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(type_chr~get(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_pairwise_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_pairwise_boot), ymax=(mean_watterson_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(type_chr~get(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_watterson_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
   }
}


#####################
# Plot para main:

 ggplot(data=stats_df_pop_feature_boostrapped %>% filter(.,type_chr=="autosomes"), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(Species~feature,  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(axis.text.x = element_blank(),strip.text = element_text(angle = 90))+
   scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
   
    ggsave(paste (wd_output,"mean_pairwise_boot_per_feature_autosomes_both_species.pdf", sep="" ), device="pdf")


ggplot(data=stats_df_pop_feature_boostrapped %>% filter(.,type_chr=="autosomes"), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_watterson_boot), ymax=(mean_watterson_boot+sd_watterson_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(Species~feature,  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(axis.text.x = element_blank(),strip.text = element_text(angle = 90))+scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
    ggsave(paste (wd_output,"mean_watterson_boot_per_feature_autosomes_both_species.pdf", sep="" ), device="pdf")

## Chr x

 ggplot(data=stats_df_pop_feature_boostrapped %>% filter(.,type_chr=="chrX"), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(Species~feature,  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))+
   scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
    ggsave(paste (wd_output,"mean_pairwise_boot_per_feature_chrX_both_species.pdf", sep="" ), device="pdf")


ggplot(data=stats_df_pop_feature_boostrapped %>% filter(.,type_chr=="chrX"), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_watterson_boot), ymax=(mean_watterson_boot+sd_watterson_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(Species~feature,  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))+scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
    ggsave(paste (wd_output,"mean_watterson_boot_per_feature_chrX_both_species.pdf", sep="" ), device="pdf")




# Corro lo mismo xa la tabla con chr que no tengo que separar entre autosomas y chrXes

DATAFRAMES=c("stats_df_pop_chr_boostrapped") 
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_pairwise_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,"_autosomes.pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_pairwise_boot), ymax=(mean_watterson_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
     theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_watterson_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")


   }
}

  
```


## Bootstraped mean considering ceros


```{r}

library(boot)
library(broom)

# Cargo la funcion de bootstrap
boot_mean <- function(original_vector, resample_vector) {
   mean(original_vector[resample_vector])
}

# Cargo la función global
diversity_stats_grouped_ave_zero_boot <- function(DATAFRAME ,GROUP)
{ 
  
    DATAFRAME_nested <- DATAFRAME %>% dplyr::group_by_("pop", GROUP)  %>% tidyr::nest()
  pairwise_average <- DATAFRAME_nested %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$pairwise_zero), statistic = boot_mean, R = ITERATION))) %>% 
    dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
  names(pairwise_average)[3] <- "values"
  pairwise_average_summary <- pairwise_average  %>% 
    group_by_(.dots=c("pop", GROUP)) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values)) %>% 
    mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "NE_Poland",
                              ifelse (pop == "c_ll_ki_n013", "Kirov",
                              ifelse (pop == "c_ll_no_n008", "Norway", 
                              ifelse (pop == "c_lp_sm_n019", "Andujar",
                              ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
    mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                              ifelse (pop == "c_ll_ki_n013", "L.lynx", 
                              ifelse (pop == "c_ll_no_n008", "L.lynx", 
                              ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
                              ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))
  names(pairwise_average_summary)[3] <- "mean_pairwise_boot"
  names(pairwise_average_summary)[4] <- "sd_pairwise_boot"
  
  
        DATAFRAME_nested <- DATAFRAME  %>% dplyr::group_by_("pop", GROUP) %>% tidyr::nest()
  watterson_average <- DATAFRAME_nested %<>% dplyr::mutate(booted = purrr::map(.x = data, ~ boot::boot(data = as.numeric(.x$watterson_zero), statistic = boot_mean, R = ITERATION))) %>% 
    dplyr::mutate(boot_matrix = purrr::map(.x = booted, ~ .x$t)) %>% 
    dplyr::select(-data, -booted) %>% tidyr::unnest(boot_matrix)  
  names(watterson_average)[3] <- "values"
  watterson_average_summary <- watterson_average  %>% 
    group_by_(.dots=c("pop", GROUP)) %>%
    dplyr::summarise(mean=mean(values),sd=sd(values)) %>%     
    mutate (., Populations =  ifelse (pop == "c_ll_po_n008", "NE_Poland",
                              ifelse (pop == "c_ll_ki_n013", "Kirov",
                              ifelse (pop == "c_ll_no_n008", "Norway", 
                              ifelse (pop == "c_lp_sm_n019", "Andujar", 
                              ifelse (pop == "c_lp_do_n012", "Donana", NA)))))) %>% 
    mutate (., Species =ifelse (pop == "c_ll_po_n008", "L.lynx",
                              ifelse (pop == "c_ll_ki_n013", "L.lynx",  
                              ifelse (pop == "c_ll_no_n008", "L.lynx", 
                              ifelse (pop == "c_lp_sm_n019", "L.pardinus", 
                              ifelse (pop == "c_lp_do_n012", "L.pardinus", NA))))))
  names(watterson_average_summary)[3] <- "mean_watterson_boot"
  names(watterson_average_summary)[4] <- "sd_watterson_boot"
  
  tmp_group <- full_join (watterson_average_summary, pairwise_average_summary, by = c("pop", GROUP, "Populations", "Species")) 
  tmp_group$Populations <- factor (tmp_group$Populations, levels=c("Kirov","NE_Poland","Norway", "Andujar", "Donana"))
  
  if("chr" %in% colnames(tmp_group))
{tmp_group$chr <- factor(tmp_group$chr, levels = c("chrA1","chrC1","chrB1","chrA2","chrB2","chrC2","chrA3","chrB3","chrB4","chrD1","chrD2","chrD3","chrD4","chrE1","chrE2","chrF1","chrF2","chrX"))}
  
  
return (tmp_group)
 
  rm (tmp_group)
  rm (watterson_average)
  rm (watterson_average_summary)
  rm (pairwise_average)
  rm (pairwise_average_summary)
  rm (tajimaD)
  rm (tajimaD_summary)
  rm (DATAFRAME_nested)
  
}


ITERATION=100


# Genero las tablas

stats_df_pop_autosomes_feature_boostrapped_zero <- diversity_stats_grouped_ave_zero_boot(data_diversity_autosomes_filtered_ave_corrected, "feature") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_feature_boostrapped_zero <- diversity_stats_grouped_ave_zero_boot(data_diversity_chrX_filtered_ave_corrected, "feature") %>%  mutate (type_chr="chrX")

stats_df_pop_autosomes_region_boostrapped_zero <- diversity_stats_grouped_ave_zero_boot(data_diversity_autosomes_filtered_ave_corrected, "region") %>%  mutate (type_chr="autosomes")
stats_df_pop_chrX_region_boostrapped_zero <- diversity_stats_grouped_ave_zero_boot(data_diversity_chrX_filtered_ave_corrected, "region") %>%  mutate (type_chr="chrX")

stats_df_pop_chr_boostrapped_zero <- diversity_stats_grouped_ave_zero_boot(data_diversity_filtered_ave_corrected, "chr") 

# Fusiono y guardo

stats_df_pop_feature_boostrapped_zero <- rbind (stats_df_pop_autosomes_feature_boostrapped_zero, stats_df_pop_chrX_feature_boostrapped_zero)
stats_df_pop_region_boostrapped_zero <- rbind(stats_df_pop_autosomes_region_boostrapped_zero,stats_df_pop_chrX_region_boostrapped_zero)

rm(stats_df_pop_autosomes_feature_boostrapped_zero)
rm(stats_df_pop_chrX_feature_boostrapped_zero)
rm(stats_df_pop_autosomes_region_boostrapped_zero)
rm(stats_df_pop_chrX_region_boostrapped_zero)

write.table(stats_df_pop_feature_boostrapped_zero, paste(wd_output,"stats_diversity_per_pop_per_feature_boostrapped_zero.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_region_boostrapped_zero, paste(wd_output,"stats_diversity_per_pop_per_region_boostrapped_zero.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )
write.table(stats_df_pop_chr_boostrapped_zero, paste(wd_output,"stats_diversity_per_pop_per_chr_boostrapped_zero.tsv",sep=""), quote = F,  row.names = F, sep =";", dec="," )


```

## Plot Bootstrapped data considering zeros

```{r}

# Ploteo los datos de bootstraping  

DATAFRAMES=c("stats_df_pop_feature_boostrapped_zero","stats_df_pop_region_boostrapped_zero")
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(type_chr~get(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_pairwise_considering_zero_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_pairwise_boot), ymax=(mean_watterson_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(type_chr~get(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_watterson_considering_zero_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")
   }
}


#####################
# Plot para main:

 ggplot(data=stats_df_pop_feature_boostrapped_zero %>% filter(.,type_chr=="autosomes"), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(Species~feature,  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))+
   scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
   
    ggsave(paste (wd_output,"mean_pairwise_considering_zero_boot_per_feature_autosomes_both_species.pdf", sep="" ), device="pdf")


ggplot(data=stats_df_pop_feature_boostrapped_zero %>% filter(.,type_chr=="autosomes"), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_watterson_boot), ymax=(mean_watterson_boot+sd_watterson_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(Species~feature,  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))+scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
    ggsave(paste (wd_output,"mean_watterson_considering_zero_boot_per_feature_autosomes_both_species.pdf", sep="" ), device="pdf")

## Chr x

 ggplot(data=stats_df_pop_feature_boostrapped_zero %>% filter(.,type_chr=="chrX"), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(Species~feature,  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))+
   scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
    ggsave(paste (wd_output,"mean_pairwise_considering_zero_boot_per_feature_chrX_both_species.pdf", sep="" ), device="pdf")


ggplot(data=stats_df_pop_feature_boostrapped_zero %>% filter(.,type_chr=="chrX"), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_watterson_boot), ymax=(mean_watterson_boot+sd_watterson_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(Species~feature,  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))+scale_y_continuous(labels = function(x) format(x, scientific = TRUE)) +
    ggsave(paste (wd_output,"mean_watterson_considering_zero_boot_per_feature_chrX_both_species.pdf", sep="" ), device="pdf")




# Corro lo mismo xa la tabla con chr que no tengo que separar entre autosomas y chrX

DATAFRAMES=c("stats_df_pop_chr_boostrapped_zero") 
SPECIES=c("L.lynx","L.pardinus")

for (DATAFRAME in DATAFRAMES)
  {
  for (SPECIE in SPECIES)
  {
    print (SPECIE)
  ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_pairwise_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_pairwise_boot-sd_pairwise_boot), ymax=(mean_pairwise_boot+sd_pairwise_boot))) +
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_pairwise_considering_zero_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,"_autosomes.pdf", sep="" ), device="pdf")
    
    ggplot(data=get(DATAFRAME) %>% filter(.,Species==!!SPECIE), aes_string(x="Populations",y="mean_watterson_boot", fill="Populations", color="Populations")) +
      geom_point() +
      geom_errorbar(aes(ymin=(mean_watterson_boot-sd_pairwise_boot), ymax=(mean_watterson_boot+sd_pairwise_boot))) +
      # Con este facet soy capaz de separar autosomas de chr chrXes.
      facet_grid(reformulate(colnames(get(DATAFRAME))[2]),  scales="free", switch="x") +
      #scale_y_continuous(trans = 'log10') +
      scale_color_viridis(discrete=TRUE) +
      scale_fill_viridis(discrete=TRUE) +
      theme(
            axis.text.x = element_blank(),strip.text = element_text(angle = 90))
    ggsave(paste (wd_output,"mean_watterson_considering_zero_boot_per_",colnames(get(DATAFRAME))[2],"_",SPECIE,".pdf", sep="" ), device="pdf")


   }
}

  
```


