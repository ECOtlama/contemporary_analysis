---
title: "curation_notation_file_gff3"
output: html_document
---


# Curation of gff3 notation file & Diversity calculus per diversity units

It is based in several scripts:

Dviersity calculus per unit (inmmunocapture elena's folder) 18/11/2016
modif_per_unit
promoters
telomers
subtelomeric-centromeric_filtering.R
plotting_subtelomeric_region(...).Rmk

Create an input bedfile that contains all the features we are interested in:

Asumimos ( mirando el archivo ) que es uno based.We are in server a.


```{r, engine=bash, eval=FALSE}

cd /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/

  
# I create a folder and store there everything that is older as we want to run this script again:
# mkdir /home/mlucena/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/maria_curation

```

## 1. Get a non-redundant (i.e., just the main isoform- and its CDS and exons- per gene) gff3.

```{r, engine=bash, eval=FALSE}

cat <(cut -f 2 /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/Anotacion_PrincipaIsoforms_Nando/genes2transcript.nr.list | awk '{print $1";"}' ) <(echo -e "EVM_PASA\tgene") | grep -f - /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.fix.gff3 | sed 's/^\(.\{4\}\)/\1./' > /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.gff3 

# Al usar "EVM_PASA\tgene" podemos seleccionar todos los genes y no solo aquellos que están en el file de la isoforma principal. Esto pasaría por ejemplo para genes que sólo tengan una isoforma.

```

---> Sanity check: They are OK! 

How many genes are not in genes2transcript.nr.list file and are in my file? 

```{r, engine=bash, eval=FALSE}

diff <(cut -f 9 /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.gff3 | awk '{split ($0,a,"="); split (a[2],b,"T"); print b[1]}' | grep -v '^$' | sort | uniq | grep "LYPA" | sed 's/> //g') <(grep -v '^###$' /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.fix.gff3 | awk '{split ($0,a,"="); split (a[2],b,"T"); print b[1]}' | grep -v '^$' | sort | uniq | grep -v "lnc" | grep "LYPA" | sed 's/> //g')
## NONE!
```



---> Sanity check para comprobar si la longitud de los mRNA y de los genes es igual o no. 
```{r, engine=bash, eval=FALSE}

while read GENEID ;
do
echo "$GENEID"
grep "$GENEID" LYPA23C.all.fix.nr.gff3 | grep -P 'EVM_PASA\tgene' | awk -v OFS='\t' '{print $4,$5}' > temp.gene.to.merge.borrar
grep "$GENEID" LYPA23C.all.fix.nr.gff3 | grep -P 'EVM_PASA\tmRNA' | awk -v OFS='\t' '{print $4,$5,$7}' > temp.mRNA.to.merge.borrar
paste <(echo $GENEID) <(cat temp.gene.to.merge.borrar ) <(cat temp.mRNA.to.merge.borrar) >> GENE_vs_mRNA1.borrar
done < <( zcat /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/APPRIS/p23A.v3.14Oct2013/appris_data.corsair.lynx_pardinus.gff3.gz |  awk '$6>3 {  print $0 }' | awk '{ split($0,a,"Parent="); print a[2] }' | sort | uniq |  tr -d '"' | sed 's/LYPA23A/LYPA23C/g' )
 

echo -e "GENE\tGENEstart\tGENEend\tmRNAstart\tmRNAend\tsense" > header.borrar
cat header.borrar GENE_vs_mRNA1.borrar > GENE_vs_mRNA
rm GENE_vs_mRNA1.borrar

cat GENE_vs_mRNA | awk '{if ($6=="+") print $1,$2,$3,$4,$5,$4-$2,$6; else print $1,$2,$3,$4,$5,$3-$5,$6}' | grep -v " 0 +" | grep -v " 0 -" > GENE_vs_mRNA_not_coincident.csv

# Ordenamos para ver si hay mRNA más grandes que el gen

sort -nk 6,6 GENE_vs_mRNA_not_coincident.csv | head

LYPA23C009331 951644 1073145   1073145 
LYPA23C011646 1257920 1266478   1266478 
LYPA23C003666 508377 661952 508378 661952 1 +
LYPA23C006676 105603 123366 105604 123366 1 +
LYPA23C007565 165681 184310 165682 179940 1 +
LYPA23C008484 281592 436862 281593 436862 1 +
LYPA23C010147 409727 424659 409727 424658 1 -

# Vemos que hay dos genes que no han salido bien las cuentas: ¿Qué ha pasado? Lo que ha pasdo esque como restamos $4-$2, como la columna 2 tenía un valor se ha repetido de nuevo. De todos modos amos genes, están solo definidos como genes y no como mRNA. 

# ex.
grep LYPA23C011646 LYPA23C.all.fix.nr.gff3
lp23.s36500	EVM_PASA	gene	1257920	1266478	.	-	.	ID=LYPA23C011646

sort -nk 6,6 GENE_vs_mRNA_not_coincident.csv | tail

LYPA23C022341 2453896 2612651 2453896 2528534 84117 -
LYPA23C003536 95103 204860 95103 120325 84535 -
LYPA23C002911 412515 544333 412515 458827 85506 -
LYPA23C012269 550100 751240 550100 663083 88157 -
LYPA23C006999 47661 177299 47661 87628 89671 -
LYPA23C010193 42335 245145 42335 143884 101261 -
LYPA23C018690 774342 989373 774342 879936 109437 -
LYPA23C010854 2554 210393 137923 210393 135369 +
LYPA23C012216 3753370 4070238 3910256 4070238 156886 +

# Esto significa que hay genes definidos que son 1 base más larga que el mRNA pero también hay genes definidos que tienen hasta 156886 bases más. 
# Esto lo tenemos que tener en cuenta para lo UTR. 


rm *borrar
```
They are not always coincident, the file is called: "GENE_vs_mRNA_not_coincident.csv". What then?





## 2. Get the features represented in the bedfile

```{r, engine=bash, eval=FALSE}

cut -f 3 /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.gff3  | sort | uniq

# CDS
# exon
# gene
# mRNA

```

## 3. Get the features not represented (i.e., promoters, introns, 5'UTR and 3'UTR, lncRNA & ncRNA, intergenic) 

La estructura que queremos es SCAFFOLD EVM_PASA FEATURE START END POINT STRANDNESS FRAME IDRAW

### 3.a. Gene promoters. 

- Vamos a usar sólo la lista de los genes que están completos en toda su longitud filtrado desde el archivo generado con APPRIS

- Lista de genes que nos interesan, son los genes que están en appris_data.corsair.lynx_pardinus.gff3.gz y tienen una puntuación mayor que 3 en la 6th columna. Escogemos este corte porque:

Email Michael Trees: 
Si quieres sacar datos ya el fichero correcto es appris_data.corsair.lynx_pardinus.gff3.
Aparte del gen y transcrito lo importante seria el score de CORSAIR, que es la
columna justo despues de las coordinadas. Como lo hemos calculado
entonces habia un punto para cada especia alineado corectamente (aunque
perro valia 0.8, pollo 2, xenopus 2 y danio 2.5. Entonces para asegurar
que han alineado bien proteinas al menos dos especies (y asi es menos
probable que el isoforma ha alineado contra fragmentos) pondria un corte de tres.
lp23.s10430	3817466	3817966	PROMOTER:LYPA23C008622T2	0	+


- No usamos la lista de Fede porque gracias a algunos sanity checks comprobé que al menos un promotor solapaba con un gen (si quieres saber cómo lo supe: script antiguo). Tras hablar con Fede, nos ha confirmado que para la dirección - los promotores no están bien definidos, por tanto vamos a volver a definirlos nosotros desde el principio. 

Como los tenemos que definir de nuevo, los vamos a definir en base a una lista de 250, 500 y 1000bp. 

```{r, engine=bash, eval=FALSE}

rm LYPA23C.promoters_full_length_genes.nr.250bp.gff3
rm LYPA23C.promoters_full_length_genes.nr.500bp.gff3
rm LYPA23C.promoters_full_length_genes.nr.1000bp.gff3
while read GENEID ;
do

echo "$GENEID 250"
grep "$GENEID" LYPA23C.all.fix.nr.gff3 | grep -P 'EVM_PASA\tmRNA'  | \
awk -v OFS='\t' '{split($0,a,":"); if ($7=="+") print $1,"manual","promoter_gene_250",$4-251,$4-1,$6,$7,$8,$9"_promoter"; else print $1,"manual","promoter_gene_250",$5+1,$5+251,$6,$7,$8,$9"_promoter"}'>> LYPA23C.promoters_full_length_genes.nr.250bp.gff3

echo "$GENEID 500"
grep "$GENEID" LYPA23C.all.fix.nr.gff3 | grep -P 'EVM_PASA\tmRNA'  | \
awk -v OFS='\t' '{split($0,a,":"); if ($7=="+") print $1,"manual","promoter_gene_500",$4-501,$4-1,$6,$7,$8,$9"_promoter"; else print $1,"manual","promoter_gene_500",$5+1,$5+501,$6,$7,$8,$9"_promoter"}'>> LYPA23C.promoters_full_length_genes.nr.500bp.gff3

echo "$GENEID 1000"
grep "$GENEID" LYPA23C.all.fix.nr.gff3 | grep -P 'EVM_PASA\tmRNA'  | \
awk -v OFS='\t' '{split($0,a,":"); if ($7=="+") print $1,"manual","promoter_gene_1000",$4-1001,$4-1,$6,$7,$8,$9"_promoter"; else print $1,"manual","promoter_gene_1000",$5+1,$5+1001,$6,$7,$8,$9"_promoter"}'>> LYPA23C.promoters_full_length_genes.nr.1000bp.gff3

done < <( zcat APPRIS/p23A.v3.14Oct2013/appris_data.corsair.lynx_pardinus.gff3.gz |  awk '$6>3 {  print $0 }' | awk '{ split($0,a,"Parent="); print a[2] }' | sort | uniq |  tr -d '"' | sed 's/LYPA23A/LYPA23C/g')


# Me he dado cuenta haciendo un sanity check que los promotores pueden ir más alla del 0 al restar a un numero 250 500 o 1000. Por tanto lo voy a modificar para que esas posiciones empiecen en 1. 


# ############ ----> Sanity_check:
# # Todos los que son menores que 0 al restarle el promotor deben caer en genes +
# rm *borrar*
# for promoters_gene_list in LYPA23C.promoters_full_length_genes.nr*
# do
# awk -v OFS='\t' '{if ($4<0) print $0}' $promoters_gene_list | sort -nk 4,4 > ${promoters_gene_list/.nr./.borrar.}
# done
# for i in *borrar*
# do
# echo $i"--->+"
# grep "$(echo -e '\t+\t')" $i | wc -l 
# echo $i"--->-"
# grep "$(echo -e '\t-\t')" $i | wc -l 
# done
# 
# # LYPA23C.promoters_full_length_genes.borrar.1000bp.gff3--->+ 13
# # LYPA23C.promoters_full_length_genes.borrar.1000bp.gff3--->- 0
# # LYPA23C.promoters_full_length_genes.borrar.250bp.gff3--->+ 9
# # LYPA23C.promoters_full_length_genes.borrar.250bp.gff3--->- 0
# # LYPA23C.promoters_full_length_genes.borrar.500bp.gff3--->+ 10
# # LYPA23C.promoters_full_length_genes.borrar.500bp.gff3--->- 0  
# # ok!!
# # Por otro lado, todos los que se escapan por el otro lado deben ser más grandes que el scaffold:
# # Todos deben caer en genes -.
# rm *borrar*
# for promoters_gene_list in LYPA23C.promoters_full_length_genes.nr*
# do
# join -1 1 -2 1 <(cat /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23) <(LANG=en_EN sort -k 1,1 -k 4,4n -k 5,5n $promoters_gene_list) | awk -v OFS='\t' '{print $0, $2-$6}' | sort -nk 11,11 | awk -v OFS='\t' '{if ($11<0) print $0}' | tr ' ' '\t' > ${promoters_gene_list/.nr./.borrar.}
# done
# for i in *borrar*
# do
# echo $i"--->+"
# grep "$(echo -e '\t+\t')" $i | wc -l 
# echo $i"--->-"
# grep "$(echo -e '\t-\t')" $i | wc -l 
# done
# rm *borrar*
# # LYPA23C.promoters_full_length_genes.borrar.1000bp.gff3--->+0
# # LYPA23C.promoters_full_length_genes.borrar.1000bp.gff3--->-18
# # LYPA23C.promoters_full_length_genes.borrar.250bp.gff3--->+0
# # LYPA23C.promoters_full_length_genes.borrar.250bp.gff3--->-9
# # LYPA23C.promoters_full_length_genes.borrar.500bp.gff3--->+0
# # LYPA23C.promoters_full_length_genes.borrar.500bp.gff3--->-13
# # ok!!
##############

# Lo corrijo: 

# Para los que caen más allá del cero:

for promoters_gene_list in LYPA23C.promoters_full_length_genes.nr*
do
echo $promoters_gene_list
echo `wc -l $promoters_gene_list`
awk -v OFS='\t'  '{if ($4<0) print $1,$2,$3,"1",$5,$6,$7,$8,$9; else print $0}' $promoters_gene_list | awk -v OFS='\t' '$5!=0 && $5!=1 {print $0}' | LANG=en_EN sort -k 1,1 -k 4,4n -k 5,5n > ${promoters_gene_list/.nr./.fix.}
echo `wc -l ${promoters_gene_list/.nr./.fix.}`
done

# LYPA23C.promoters_full_length_genes.nr.1000bp.gff3
# 7394 LYPA23C.promoters_full_length_genes.nr.1000bp.gff3
# 7391 LYPA23C.promoters_full_length_genes.fix.1000bp.gff3
# LYPA23C.promoters_full_length_genes.nr.250bp.gff3
# 7394 LYPA23C.promoters_full_length_genes.nr.250bp.gff3
# 7391 LYPA23C.promoters_full_length_genes.fix.250bp.gff3
# LYPA23C.promoters_full_length_genes.nr.500bp.gff3
# 7394 LYPA23C.promoters_full_length_genes.nr.500bp.gff3
# 7391 LYPA23C.promoters_full_length_genes.fix.500bp.gff

# Compruebo que efectivamente son tres, y por tanto reemplazo el archivo.

for promoters_gene_list in LYPA23C.promoters_full_length_genes.nr*
do
mv ${promoters_gene_list/.nr./.fix.} $promoters_gene_list
done


# Tengo que comprobar que nos se nos escapa tampoco por el otro lado:

# Aquí lo imprimimos bien. Si su terminación real cae dentro del scaffold se imprime esta terminación y si no, el final del scaffold. 

for promoters_gene_list in LYPA23C.promoters_full_length_genes.nr*
do
echo $promoters_gene_list
join -1 1 -2 1 /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23 $promoters_gene_list | tr ' ' \\t | awk -v OFS='\t' '($5<$2) {print $0}' | 
awk -v OFS='\t' '{ if ($6<$2) print $1,$3,$4,$5,$6,$7,$8,$9,$10 ; else print $1,$3,$4,$5,$2,$7,$8,$9,$10 }' > ${promoters_gene_list/.nr./.fix.} # con el primer awk me quito todos aquellos que empiecen más alla del fin del scaffold. con el segundo awk todos los que acaben más alla del fin del scaffold 
awk -v OFS='\t' '{print $5-$4}' ${promoters_gene_list/.nr./.fix.} | sort -n > ${promoters_gene_list/.nr./.borrar.} # con este archivo luego comprobamos que la resta está bien hecha.  
done

###### ----> Sanity check
# for i in *borrar*
# do
# head -n 50 $i
# done
######

rm *borrar*

for promoters_gene_list in LYPA23C.promoters_full_length_genes.nr*
do
echo "${promoters_gene_list/.nr./.fix.} ----> $promoters_gene_list"
mv ${promoters_gene_list/.nr./.fix.} $promoters_gene_list
done

## todo perfecto!
  
```



### 3.b. Introns 

---> Sanity check para comprobar que es seguro usar el bed de Fede.

```{r, engine=bash, eval=FALSE}

# Comprobar que están bien calculados con algún ej a ojo. Tomo para el ejemplo los 10 primeros genes
grep gene LYPA23C.all.fix.nr.gff3 | head | awk '{ split($0,a,"ID="); print a[2] }'

GENES=('LYPA23C013748' 'LYPA23C013847' 'LYPA23C013736' 'LYPA23C013679' 'LYPA23C013712' 'LYPA23C013832' 'LYPA23C013840' 'LYPA23C013755' 'LYPA23C013826' 'LYPA23C013809')
rm check.introns.borrar
for GENEID in "${GENES[@]}"
do
echo "---------------------GENE = $GENEID---------------------------" >> check.introns.borrar
grep "ID=$GENEID" LYPA23C.all.fix.nr.gff3 | grep gene  >> check.introns.borrar
echo "---------------------EXONS---------------------------" >> check.introns.borrar
grep "$GENEID" LYPA23C.all.fix.nr.gff3 | grep exon  >> check.introns.borrar
echo "---------------------INTRONS---------------------------" >> check.introns.borrar
grep "ID=$GENEID" LYPA23C.introns.nr.gff3 | grep intron  >> check.introns.borrar
echo >> check.introns.borrar
echo >> check.introns.borrar
done
 
# Hemos comprobado que tenemos definidos intrones para menos genes de los que hay. Comprobamos que estos genes en cuestión no tienen más de un exón y por tanto no tienen intrones definidos.

rm exon_per_genes_in_my_nr_file_and_not_in_introns_bed.list
while read GENE;
do 
echo $GENE
grep $GENE /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.extra.genes.gff3 | grep -e $'\t''EVM_PASA'$'\t''CDS'$'\t' | awk '{split ($9,a,";"); print a[1]}' | uniq -c | sort -k1,1 | grep -v "1 Parent" >> CDS_per_genes_in_my_nr_file_and_not_in_introns_bed.list
done < <(cat genes_in_my_nr_file_and_not_in_introns_bed.list)

# Hablando con Fede y me ha comentado "Sólo he mirado el primero y el segundo. El intrón del gen LYPA23C001262 solapa con el UTR de otro gen. Por eso no se considera intrón “puro”. Lo mismo pasa con el segundo. Los genomas son muy raros ;-)". Por tanto estos intrones no se considerarían. 

```
Tras discutir con Fede las dudas que tenías vemos que los intrones están bien, solo tendríamos que corregir que están como 0based y nosotros queremos pasarlo a 1 based para el gff. 

Corregimos a 0 based:

```{r, engine=bash, eval=FALSE}
awk -v OFS='\t' '{split($4,a,":"); print $1,"MANUAL","intron",$2+1,$3,".",$6,$5,"ID="a[2]}' /home/GRUPOS/grupolince/copia_fabascal/FEATURES/introns.bed | awk -v OFS='\t' '{if ($9==prev) counter++; else counter=1; print ($1,$2,$3,$4,$5,$6,$7,$8,$9"_intron_"counter); prev=$9}'  > LYPA23C.introns.nr.gff3
```

### 3.c. UTRs

For each gene

Vamos a usar sólo la lista de los genes que están completos en toda su longitud filtrado desde el archivo generado con APPRIS

Lista de genes que nos interesan, son los genes que están en appris_data.corsair.lynx_pardinus.gff3.gz y tienen una puntuación mayor que 3 en la 6th columna. Escogemos este corte porque:

Email Michael Trees: 
Si quieres sacar datos ya el fichero correcto es appris_data.corsair.lynx_pardinus.gff3.
Aparte del gen y transcrito lo importante seria el score de CORSAIR, que es la
columna justo despues de las coordinadas. Como lo hemos calculado
entonces habia un punto para cada especia alineado corectamente (aunque
perro valia 0.8, pollo 2, xenopus 2 y danio 2.5. Entonces para asegurar
que han alineado bien proteinas al menos dos especies (y asi es menos
probable que el isoforma ha alineado contra fragmentos) pondria un corte de tres.

Las UTR se podrían definir como gene-exon,gene-cds y exon-cds. Tras discutir cual es la mejor aproximación, nos vamos a quedar con gene-cds

```{r, engine=bash, eval=FALSE}

rm LYPA23C.UTRs_gene-cds.nr.gff3
while read GENEID ;
do
echo "$GENEID" 
# gene
grep "$GENEID" /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.gff3   | # Solo si uso el file con todas las isoformas sed 's/^\(.\{4\}\)/\1./'  | \
grep -e $'\t''EVM_PASA'$'\t''gene'$'\t' | awk -v OFS='\t' '{print $1,$2,$3,$4-1,$5,$6,$7,$8,$9}' \
> gene.iter.bed.borrar
# He convertido el archivo en 0-based para hacer el substract. 
# cds
grep "$GENEID" /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.gff3  | # Solo si uso el file con todas las isoformassed 's/^\(.\{4\}\)/\1./'  | \
grep -e $'\t''EVM_PASA'$'\t''CDS'$'\t' | \
awk -v OFS='\t' 'NR == 1 {min = $4} NR>1 && $4<min {min = $4}; NR == 1 {max = $5} NR>1 && $5>max {max = $5} END {print  $1,min-1,max}'  \
> cds.iter.bed.borrar
# He convertido el archivo en 0-based para hacer el substract. 
# Get UTRs by doing gene-exon, gene-cds and exon-cds:
bedtools subtract -a gene.iter.bed.borrar -b cds.iter.bed.borrar > gene-cds.iter.bed.borrar
# Get UTRs
awk -v OFS='\t' 'NR==1 {if ($7=="+") print $1,$2,"5UTR",$4,$5,$6,$7,$8,$9,$5-$4 ; else print $1,$2,"3UTR",$4,$5,$6,$7,$8,$9,$5-$4} \
NR==2 {if ($7=="+") print $1,$2,"3UTR",$4,$5,$6,$7,$8,$9,$5-$4; else print $1,$2,"5UTR",$4,$5,$6,$7,$8,$9,$5-$4 }' gene-cds.iter.bed.borrar | \
awk -v OFS='\t' '$10>1 {print $1,$2,$3,$4+1,$5,$6,$7,$8,$9}' >>  LYPA23C.UTRs_gene-cds.nr.gff3  
# Lo que hace es quitarme todos los UTR que sean de un tamañao de 1 o 0. Además lo hago 1-based. 
done < <( zcat /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/APPRIS/p23A.v3.14Oct2013/appris_data.corsair.lynx_pardinus.gff3.gz |  awk '$6>3 {  print $0 }' | awk '{ split($0,a,"Parent="); print a[2] }' | sort | uniq |  tr -d '"' | sed 's/LYPA23A/LYPA23C/g')

# Este fallo se debe a que gene es igual a cds. 
# Error: Invalid record in file gene.iter.bed.borrar. Record is 
# lp23.s26762	EVM_PASA	gene	0	1635	.	-	.	ID=LYPA23C003834

# También se podría hacer como gene-exon o exon-cds. Esas combinaciones están en script antiguo. 
# Esto te daría 1-based directamente.

rm *.iter.bed.borrar

```

---> Sanity check para comprobar la longitud de los UTRs. 
```{r, engine=bash, eval=FALSE}

# Efectivamente como imaginabamos al hacer las cuentas gene - mRNA, hay UTR muy pequeños (de 1 base) hasta muy grandes. Aquí es incluso más dramático puesto que no es gene - mRNA sino gene - CDS. 

awk '{print $0,$5-$4}' LYPA23C.UTRs_gene-cds.nr.gff3  | sort -nk 10,10 | head

# lp23.s00346	EVM_PASA	5UTR	21453	21454	.	+	.	ID=LYPA23C020420 1
# lp23.s05474	EVM_PASA	5UTR	64682	64683	.	-	.	ID=LYPA23C017696 1
# lp23.s10489	EVM_PASA	5UTR	1054504	1054505	.	-	.	ID=LYPA23C009597 1
# lp23.s15671	EVM_PASA	5UTR	1956022	1956023	.	-	.	ID=LYPA23C022767 1
# lp23.s21030	EVM_PASA	5UTR	372327	372328	.	+	.	ID=LYPA23C020649 1
# lp23.s31313	EVM_PASA	5UTR	1885717	1885718	.	-	.	ID=LYPA23C017432 1
# lp23.s31393	EVM_PASA	5UTR	173018	173019	.	+	.	ID=LYPA23C019378 1
# lp23.s31562	EVM_PASA	5UTR	121955	121956	.	+	.	ID=LYPA23C007611 1
# lp23.s36556	EVM_PASA	5UTR	71669	71670	.	-	.	ID=LYPA23C015730 1
# lp23.s00065	EVM_PASA	5UTR	967477	967479	.	-	.	ID=LYPA23C022271 2

awk '{print $0,$5-$4}' LYPA23C.UTRs_gene-cds.nr.gff3  | sort -nk 10,10 | tail

# lp23.s31307	EVM_PASA	5UTR	587865	733709	.	+	.	ID=LYPA23C020193 145844
# lp23.s26098	EVM_PASA	5UTR	1161927	1311000	.	-	.	ID=LYPA23C010410 149073
# lp23.s10436	EVM_PASA	5UTR	72913	225062	.	+	.	ID=LYPA23C000428 152149
# lp23.s26073	EVM_PASA	5UTR	2999025	3153478	.	+	.	ID=LYPA23C022308 154453
# lp23.s00042	EVM_PASA	5UTR	249500	406004	.	-	.	ID=LYPA23C013118 156504
# lp23.s10505	EVM_PASA	5UTR	413463	570406	.	-	.	ID=LYPA23C023050 156943
# lp23.s36493	EVM_PASA	5UTR	3753370	3910352	.	+	.	ID=LYPA23C012216 156982
# lp23.s05347	EVM_PASA	5UTR	199934	369620	.	-	.	ID=LYPA23C021147 169686
# lp23.s10473	EVM_PASA	5UTR	937317	1122146	.	+	.	ID=LYPA23C019933 184829
# lp23.s36529	EVM_PASA	5UTR	217772	416565	.	+	.	ID=LYPA23C013936 198793


```


### 3.d. sncRNA


```{r, engine=bash, eval=FALSE}

# We have the final output of infernal package, and also a report explaining what we have. 
# The file is: infernal_1e6.gff3.zip  

sed 's/^\(.\{4\}\)/\1./' infernal_1e6.gff3 > infernal_1e6_fixed.gff3
mv infernal_1e6_fixed.gff3 LYPA23C.infernal_1e6_fixed.gff3

# This is not coming from a bed file, so I assumed that is 1-based


```



### 3.e. lncRNA

```{r, engine=bash, eval=FALSE}

# El archivo que tenemos es un archivo gtf que nos lo ha pasado Ionas Erb (Centre de Regulació Genòmica) de la última versión que hicieron del mismo. 
# El formato gtf es algo distinto a gff3. He encontrado un script de python que te los transforma y creo que ya los podríamos usar para lo que nos interesa.  

python /Users/marialucenaperez/Dropbox/PhD/contemporary/script/GTF_to_GFF3.py /Users/marialucenaperez/Desktop/lncRNAs_fixed.gtf > /Users/marialucenaperez/Desktop/lncRNAs_fixed.gff3
scp /Users/marialucenaperez/Desktop/lncRNAs_fixed.gtf GRUPOS@genomics-a.ebd.csic.es:///home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/
scp /Users/marialucenaperez/Desktop/lncRNAs_fixed.gff3 GRUPOS@genomics-a.ebd.csic.es:///home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/


sed 's/^\(.\{4\}\)/\1./' lncRNAs_fixed.gff3  | \
awk -v OFS='\t' '{split($9,a,";"); split (a[2],b,"\""); split ($11,c,"\""); print ($1,$2,$3,$4,$5,$6,$7,$8,b[1],c[2])}' | \
LANG=en_EN sort -k 9,9 -k 10,10 | \
awk -v OFS='\t' '{print ($1,$2,$3,$4,$5,$6,$7,$8,$9"_"$10)}' | \
awk -v OFS='\t' '{if ($9==prev) counter++; else counter=1; print ($1,$2,"lncRNA",$4,$5,$6,$7,$8,$9"_exon_"counter); prev=$9}' > lncRNAs_fixed_sorted.gff3 
mv lncRNAs_fixed_sorted.gff3 LYPA23C.lncRNAs_fixed_sorted.gff3


# This is not coming from a bed file, so I assumed that is 1-based

```


### 3.f. lncRNA introns

```{r, engine=bash, eval=FALSE}

rm LYPA23C.introns_lncRNA.gff3
rm cuentas.borrar
while read direction LNCRNA_ID ;
do
echo $LNCRNA_ID
grep "$LNCRNA_ID" LYPA23C.lncRNAs_fixed_sorted.gff3 | awk -v OFS='\t' '{print $1, $4, $5}' > exons.lncRNA.iter.borrar
wc -l exons.lncRNA.iter.borrar >> cuentas.borrar # To check if I should have more than an intron for a lncRNA. 
grep "$LNCRNA_ID" LYPA23C.lncRNAs_fixed_sorted.gff3 | \
awk -v OFS='\t' 'NR == 1 {min = $4} NR>1 && $4<min {min = $4}; NR == 1 {max = $5} NR>1 && $5>max {max = $5} END {print  $1,min,max}' > whole.lncRNA.iter.borrar
bedtools subtract -a whole.lncRNA.iter.borrar -b exons.lncRNA.iter.borrar > whole-exons.lncRNA.iter.bed.borrar
awk -v OFS='\t' '{print $1,"manual","intron_lncRNA",$2+1, $3-1,".","'${direction}'",".","GID='${LNCRNA_ID}'" }' whole-exons.lncRNA.iter.bed.borrar | awk -v OFS='\t' '{if ($9==prev) counter++; else counter=1; print ($1,$2,$3,$4,$5,$6,$7,$8,$9"_intron_"counter); prev=$9}'  >>  LYPA23C.introns_lncRNA.gff3
done < <( cat LYPA23C.lncRNAs_fixed_sorted.gff3| awk '{ split($0,a,"GID="); print $7, a[2] }' | awk '{ split($2,a,"_"); print $1, a[1]"_"a[2]"_"a[3]"_"a[4] }' | sort | uniq )
rm cuentas.borrar

```

### 3.g. lncRNA promoters

```{r, engine=bash, eval=FALSE}

rm LYPA23C.promoters_lncRNA.250bp.gff3
rm LYPA23C.promoters_lncRNA.500bp.gff3
rm LYPA23C.promoters_lncRNA.1000bp.gff3
while read LNCRNA_ID ;
do

echo "$LNCRNA_ID 250"
grep "$LNCRNA_ID" LYPA23C.lncRNAs_fixed_sorted.gff3 | \
awk -v OFS='\t' 'NR == 1 {min = $4} NR>1 && $4<min {min = $4}; NR == 1 {max = $5} NR>1 && $5>max {max = $5} END {print  $1,min,max,$7}' | 
awk -v OFS='\t' '{if ($4=="+") print $1,"manual","promoter_lncRNA_250",$2-251,$2-1,".",$4,".","GID='${LNCRNA_ID}'_promoter"; else print $1,"manual","promoter_lncRNA_250",$3+1,$3+251,".",$4,".","GID='${LNCRNA_ID}'_promoter"}' >> LYPA23C.promoters_lncRNA.250bp.gff3

echo "$LNCRNA_ID 500"
grep "$LNCRNA_ID" LYPA23C.lncRNAs_fixed_sorted.gff3 | \
awk -v OFS='\t' 'NR == 1 {min = $4} NR>1 && $4<min {min = $4}; NR == 1 {max = $5} NR>1 && $5>max {max = $5} END {print  $1,min,max,$7}' | 
awk -v OFS='\t' '{if ($4=="+") print $1,"manual","promoter_lncRNA_500",$2-501,$2-1,".",$4,".","GID='${LNCRNA_ID}'_promoter"; else print $1,"manual","promoter_lncRNA_500",$3+1,$3+501,".",$4,".","GID='${LNCRNA_ID}'_promoter"}' >> LYPA23C.promoters_lncRNA.500bp.gff3

echo "$LNCRNA_ID 1000"
grep "$LNCRNA_ID" LYPA23C.lncRNAs_fixed_sorted.gff3 | \
awk -v OFS='\t' 'NR == 1 {min = $4} NR>1 && $4<min {min = $4}; NR == 1 {max = $5} NR>1 && $5>max {max = $5} END {print  $1,min,max,$7}' | 
awk -v OFS='\t' '{if ($4=="+") print $1,"manual","promoter_lncRNA_1000",$2-1001,$2-1,".",$4,".","GID='${LNCRNA_ID}'_promoter"; else print $1,"manual","promoter_lncRNA_1000",$3+1,$3+1001,".",$4,".","GID='${LNCRNA_ID}'_promoter"}' >> LYPA23C.promoters_lncRNA.1000bp.gff3

done < <( cat LYPA23C.lncRNAs_fixed_sorted.gff3 | awk '{ split($0,a,"GID="); print a[2] }' | awk '{ split($0,a,"_"); print a[1]"_"a[2] }' | sort | uniq )


# Me he dado cuenta haciendo un sanity check que los promotores pueden ir más alla del 0 al restar a un numero 250 500 o 1000. Por tanto lo voy a modificar para que esas posiciones empiecen en 1. 


############ ----> Sanity_check:
# # Todos los que son menores que 0 al restarle el promotor deben caer en genes +
# rm *borrar*
# for promoters_lncRNA_list in LYPA23C.promoters_lncRNA*
# do
# echo $promoters_lncRNA_list
# awk -v OFS='\t' '{if ($4<0) print $0}' $promoters_lncRNA_list | sort -nk 4,4 > ${promoters_lncRNA_list/.gff3/.borrar.gff3}
# done
# for i in *borrar*
# do
# echo $i"--->+"
# grep "$(echo -e '\t+\t')" $i | wc -l
# echo $i"--->-"
# grep "$(echo -e '\t-\t')" $i | wc -l
# done
# 
# # LYPA23C.promoters_lncRNA.1000bp.borrar.gff3--->+32
# # LYPA23C.promoters_lncRNA.1000bp.borrar.gff3--->-0
# # LYPA23C.promoters_lncRNA.250bp.borrar.gff3--->+20
# # LYPA23C.promoters_lncRNA.250bp.borrar.gff3--->-0
# # LYPA23C.promoters_lncRNA.500bp.borrar.gff3--->+24
# # LYPA23C.promoters_lncRNA.500bp.borrar.gff3--->-0
# 
# # ok!!
# # Por otro lado, todos los que se escapan por el otro lado deben ser más grandes que el scaffold:
# # Todos deben caer en genes -.
# rm *borrar*
# for promoters_lncRNA_list in LYPA23C.promoters_lncRNA*
# do
# echo $promoters_lncRNA_list
# join -1 1 -2 1 <(cat /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23) <(LANG=en_EN sort -k 1,1 -k 4,4n -k 5,5n $promoters_lncRNA_list) | awk -v OFS='\t' '{print $0, $2-$6}' | sort -nk 11,11 | awk -v OFS='\t' '{if ($11<0) print $0}' | tr ' ' '\t' > ${promoters_lncRNA_list/.gff3/.borrar.gff3}
# done
# for i in *borrar*
# do
# echo $i"--->+"
# grep "$(echo -e '\t+\t')" $i | wc -l
# echo $i"--->-"
# grep "$(echo -e '\t-\t')" $i | wc -l
# done
#   
# # LYPA23C.promoters_lncRNA.1000bp.borrar.gff3--->+0
# # LYPA23C.promoters_lncRNA.1000bp.borrar.gff3--->-30
# # LYPA23C.promoters_lncRNA.250bp.borrar.gff3--->+0
# # LYPA23C.promoters_lncRNA.250bp.borrar.gff3--->-22
# # LYPA23C.promoters_lncRNA.500bp.borrar.gff3--->+0
# # LYPA23C.promoters_lncRNA.500bp.borrar.gff3--->-26
# 
# # ok!!!
#############

# Lo corrijo: 

# Para los que caen más allá del cero:

rm *borrar*

for promoters_lncRNA_list in LYPA23C.promoters_lncRNA*bp.gff3
do
echo $promoters_lncRNA_list
echo `wc -l $promoters_lncRNA_list`
awk -v OFS='\t' '{if ($4<0) print $1,$2,$3,"1",$5,$6,$7,$8,$9; else print $0}' $promoters_lncRNA_list | awk -v OFS='\t' '$5!=0 && $5!=1 {print $0}' | LANG=en_EN sort -k 1,1 -k 4,4n -k 5,5n > ${promoters_lncRNA_list/bp./bp.fix.}
echo `wc -l ${promoters_lncRNA_list/bp./bp.fix.}`
done


# LYPA23C.promoters_lncRNA.1000bp.gff3
# 3182 LYPA23C.promoters_lncRNA.1000bp.gff3
# 3180 LYPA23C.promoters_lncRNA.1000bp.fix.gff3
# LYPA23C.promoters_lncRNA.250bp.gff3
# 3182 LYPA23C.promoters_lncRNA.250bp.gff3
# 3180 LYPA23C.promoters_lncRNA.250bp.fix.gff3
# LYPA23C.promoters_lncRNA.500bp.gff3
# 3182 LYPA23C.promoters_lncRNA.500bp.gff3
# 3180 LYPA23C.promoters_lncRNA.500bp.fix.gff3

# #### Sanity check --> ok
# awk '{print $5-$4}' LYPA23C.promoters_lncRNA.250bp.fix.gff3 | sort -n | head
# awk '{print $5-$4}' LYPA23C.promoters_lncRNA.500bp.fix.gff3 | sort -n | head
# awk '{print $5-$4}' LYPA23C.promoters_lncRNA.1000bp.fix.gff3 | sort -n | head
# #### 

# Compruebo que efectivamente son dos, y por tanto reemplazo el archivo.

for promoters_lncRNA_list in LYPA23C.promoters_lncRNA*bp.gff3
do
echo "${promoters_lncRNA_list/bp./bp.fix.} ---> $promoters_lncRNA_list"
mv ${promoters_lncRNA_list/bp./bp.fix.} $promoters_lncRNA_list
done

# Tengo que comprobar que nos se nos escapa tampoco por el otro lado:

# Aquí lo imprimimos bien. Si su terminación real cae dentro del scaffold se imprime esta terminación y si no, el final del scaffold. 

for promoters_lncRNA_list in LYPA23C.promoters_lncRNA*bp.gff3
do
echo $promoters_lncRNA_list
join -1 1 -2 1 /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23 $promoters_lncRNA_list | tr ' ' \\t | awk -v OFS='\t' '($5<$2) {print $0}' | awk -v OFS='\t' '{ if ($6<$2) print $1,$3,$4,$5,$6,$7,$8,$9,$10 ; else print $1,$3,$4,$5,$2,$7,$8,$9,$10 }' > ${promoters_lncRNA_list/bp./bp.fix.} # con el primer awk me quito todos aquellos que empiecen más alla del fin del scaffold. con el segundo awk todos los que acaben más alla del fin del scaffold 
awk -v OFS='\t' '{print $5-$4}' ${promoters_lncRNA_list/bp./bp.fix.} | sort -n > ${promoters_lncRNA_list/bp./bp.fix.borrar.} # con este archivo luego comprobamos que la resta está bien hecha.  
done

###### ----> Sanity check
# for i in *borrar*
# do
# head -n 50 $i
# done
######

rm *borrar*

for promoters_lncRNA_list in LYPA23C.promoters_lncRNA*bp.gff3
do
echo "${promoters_lncRNA_list/bp./bp.fix.} ----> $promoters_lncRNA_list"
mv ${promoters_lncRNA_list/bp./bp.fix.} $promoters_lncRNA_list
done

## Todo perfecto!

```



## 4. Merging functional part of the genome (merging)


```{r, engine=bash, eval=FALSE}


# FUNCTIONAL FILE:
# Name: LYPA23C.CDS.EXON.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.nr.gff3 

# Files included:
# 	1. Original file LYPA23C.all.fix.nr.gff3 (CDS/EXON/GENE/mRNA).
# 	(3.a.). Promoters
#           250
#           500
#           1000
# 	(3.b.) Introns.
# 	(3.c.) 5'UTR and 3'UTR (UTR es la región no traducida del gen: LYPA23C.UTRs_gene-cds.nr.gff3)
# 	(3.d.) sncRNA
# 	(3.e.) lncRNA
#   (3.f.) lncRNA introns 
#   (3.g.) lncRNA promoters
#           250
#           500
#           1000


# Como los exones son redundantes con los CDS porque tenemos UTR, los eliminamos del archivo all.fix.nr:
awk -v OFS='\t' '{if ($3!="exon") print $0}' LYPA23C.all.fix.nr.gff3 > LYPA23C.GENE.mRNA.CDS.fix.nr.gff3

# Podríamos también quitar mRNA o gene y dejar uno de los dos. Pero puesto que hemos comprobado que a veces son mucho más grandes los genes que el mRNA quizás sea interesante dejarlo. 

# Tenemos que tener claro entonces que los UTR pasan a ser gene-cds, teniendo en cuenta que gene-mRNA a veces da unos valores muy altos; como ya hemos comprobado, esto es especialmente dramático para gene-cds. Por lo que a veces los UTR serán enormes. 

# Este archivo tendría todo lo funcional.

cat LYPA23C.GENE.mRNA.CDS.fix.nr.gff3 LYPA23C.promoters_full_length_genes.nr.250bp.gff3 LYPA23C.promoters_full_length_genes.nr.500bp.gff3 LYPA23C.promoters_full_length_genes.nr.1000bp.gff3 LYPA23C.introns.nr.gff3 LYPA23C.UTRs_gene-cds.nr.gff3 LYPA23C.infernal_1e6_fixed.gff3 LYPA23C.lncRNAs_fixed_sorted.gff3 LYPA23C.introns_lncRNA.gff3 LYPA23C.promoters_lncRNA.250bp.gff3 LYPA23C.promoters_lncRNA.500bp.gff3 LYPA23C.promoters_lncRNA.1000bp.gff3 | LANG=en_EN sort -k 1,1 -k 4,4n -k 5,5n > LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.gff3

```


---> Sanity check para comprobar que cada archivo tiene lo que se espera de él. 

```{r, engine=bash, eval=FALSE}


cut -f 3 LYPA23C.GENE.mRNA.CDS.fix.nr.gff3  | sort | uniq
cut -f 3 LYPA23C.promoters_full_length_genes.nr.250bp.gff3  | sort | uniq
cut -f 3 LYPA23C.promoters_full_length_genes.nr.500bp.gff3  | sort | uniq
cut -f 3 LYPA23C.promoters_full_length_genes.nr.1000bp.gff3  | sort | uniq
cut -f 3 LYPA23C.introns.nr.gff3  | sort | uniq
cut -f 3 LYPA23C.UTRs_gene-cds.nr.gff3  | sort | uniq
cut -f 3 LYPA23C.infernal_1e6_fixed.gff3  | sort | uniq
cut -f 3 LYPA23C.lncRNAs_fixed_sorted.gff3  | sort | uniq
cut -f 3 LYPA23C.introns_lncRNA.gff3  | sort | uniq
cut -f 3 LYPA23C.promoters_lncRNA.250bp.gff3  | sort | uniq
cut -f 3 LYPA23C.promoters_lncRNA.500bp.gff3  | sort | uniq
cut -f 3 LYPA23C.promoters_lncRNA.1000bp.gff3 | sort | uniq

# Salen todas bien!


cut -f 3 LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.gff3  | sort | uniq
# 3UTR
# 5UTR
# CDS
# gene
# intron
# intron_lncRNA
# lncRNA
# mRNA
# ncRNA
# promoter_gene_1000
# promoter_gene_250
# promoter_gene_500
# promoter_lncRNA_1000
# promoter_lncRNA_250
# promoter_lncRNA_500
# 
# Perfecto!



```

---> Sanity check para comprobar que cada archivo tiene lo que se espera de él. 

```{r, engine=bash, eval=FALSE}

# Miro a ver si nuestras construcciones ha provocado que algo se vaya más allá de cero. 

sort -nk 4,4 LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.gff3 | awk '($4<0){print $3}' | sort | uniq -c 
 
# OK!!! NADA! Esto es porque ya lo hemos solucionado con modificaciones del script arriba!!!


```

     
## 5. Defining intergenic regions

Fede tiene un bed de intergénico, pero dado que nosotros hemos:

1. Corregido los promotores que no estaban bien definidos para los genes -.
2. Añadido lncRNA (con promotores e intrones) y sncRNA

Por tanto, voy a usar mi file de funcional y restarle al genoma todas esas regiones. 

Vamos a construir dos tipos de regiones intergénicas:
1. Por un lado, tendríamos las regiones intergénicas que salen directamente de la resta del genoma menos la región funcional.
2. Por otro vamos a crear un intergénico que recoja las regiones que estén al menos a 1000pb de cualquier zona funcional. 


```{r, engine=bash, eval=FALSE}

# 1. 


# Por un lado, tendríamos las regiones intergénicas que salen directamente de la resta del genoma menos la región funcional.

# First create bed file based on the previous file. Como es un bed lo pasamos a es 0-based.

awk -v OFS='\t' '{print $1, $4-1, $5}' LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.gff3 | bedtools merge -i stdin -d 1 > LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.bed

#### ---> Sanity check:
# wc -l LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.gff3
# 468341 LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.gff3
# [mlucena@genomics_b Lyp_annotation_Apr14_final]$ wc -l LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.bed
# 29799 LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.bed
# ¡¡¡Solapan muchas cosas!!! Tambien tenemos que tener en cuenta que tenemos gene y mRNA que solapan, pero también promotores 250, 500 y 100 para genes y lncRNa que solapan también completamente. 
##### 


# Define intergenic region 1-based!!

bedtools subtract -a /home/mlucena/grupolince/reference_genomes/lynx_pardinus_genome/bed_file_all_the_genome.bed -b LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.bed > LYPA23C.intergenic.bed




# 2. 


# Por otro vamos a crear un intergénico que recoja las regiones que estén al menos a 1000pb de cualquier zona funcional. 
# First create bed file based on the previous file. Como es un bed lo pasamos a es 0-based.

# con este awk sustituyo la columna que yo quiero por un valor concreto y el resto lo dejo igual. 

awk -v OFS='\t' '{$4=$4-1000; $5=$5+1000; print}' LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.gff3 > LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.PLUS1000bp.gff3


join -1 1 -2 1 <(cat /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/Length_scaffolds_lp23)  <(LANG=en_EN sort -k 1,1 -k 4,4n -k 5,5n LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.PLUS1000bp.gff3) |  
awk -v OFS='\t' '{if ($5<0) {$5="1"} else {$5=$5}; print}' | awk -v OFS='\t' '{if ($6>$2) {$6=$2} else {$6=$6}; print $1,$5-1,$6}' | bedtools merge -i stdin -d 1 > LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.PLUS1000bp.bed

## Nota:Con este awk:
# awk -v OFS='\t' '{if ($5<0) {$5="1"} else {$5=$5}; print}' | awk -v OFS='\t' '{if ($6>$2) {$6=$2} else {$6=$6}; print $1,$5-1,$6}'
 # Lo que hago es mirar que nada se escape por debajo de 0 y si es así lo sustituyo por 1, lo que no se escapa se imprime igualmente. Además mira que nada sea más grande que el scaffold, y si es así, lo sustituyo por el valor de la longitud del scaffold, si no es más grande deja el mismo valor. En ambos casos, elimino del archivo el valor longitud de scaffold que está en columna 2 porque ya hemos hecho las comprobaciones que queremos. 
# También he guardado este archivito resultante de hacer estos awk e hice algunas comprobaciones. Concretamente miré que nada se escapaba por debajo de 0 en el límite superior y que nada se escapaba por encima de la longitud del scaffold. En definitiva, que el script funcionaba bien. 
# Este script además te imprime solo las columnas de las coordenadas en formato 0-based. 
# Si quisieras eliminar una columna, por ejemplo la 6: awk -v OFS='\t' '{if ($5<0) {$5="1"; $6=""} else {$5=$5; $6=""}; print}'


# Define strict intergenic region 1-based!!

bedtools subtract -a /home/mlucena/grupolince/reference_genomes/lynx_pardinus_genome/bed_file_all_the_genome.bed -b LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.nr.PLUS1000bp.bed > LYPA23C.intergenic.PLUS1000.bed

```
















## 6. Merging all categories.



```{r, engine=bash, eval=FALSE}

################################

## Therefore I created the definitive file with all the features; i.e., 

# ALL FEATURES FILE:
# Name: LYPA23C.CDS.EXON.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.intergenic.nr.gff3 
# Files included:
# 	ORIGINAL FILE (CDS/EXON/GENE/mRNA)
# 	promoters
# 	introns
# 	5'UTR and 3'UTR (UTR es la región no traducida del gen por tanto nos quedamos con: LYPA23C.UTRs_gene-cds.nr.gff3)
# 	lncRNA
# 	ncRNA
# 	intergenic gff3 file

#Modify intergenic_sorted_nr_fixed.gff3 to change - by dots and pass it to one based

cat intergenic_sorted_nr_fixed.gff3 | tr '-' '.' | awk -v OFS='\t' '{ print $1,$2,$3,$4+1,$5,$6,$7,$8,$9;}' > intergenic_sorted_nr_fixed2.gff3

cat LYPA23C.all.fix.nr.extra.genes.gff3 LYPA23C.promoters_full_length_genes.nr.gff3 LYPA23C.introns.nr.gff3 LYPA23C.UTRs_gene-cds.nr.positions.fixed.gff3 lncRNAs_fixed_sorted.gff3 infernal_1e6_fixed.gff3 intergenic_sorted_nr_fixed2.gff3 | LANG=en_EN sort -k 1,1 -k 4,4n -k 5,5n > LYPA23C.CDS.EXON.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.gff3 

# I remove exons (=CDS) and mRNA (=gene) cause I don't need them:

cat LYPA23C.CDS.EXON.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.gff3 | awk '{if ($3!="exon") print $0}' | awk '{if ($3!="mRNA") print $0}' > LYPA23C.CDS.GENE.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.gff3

# I had a look and it seems very good! 





# ¢ AÑADIR TELOMERO Y CENTRÓMERO Y PREGUNTAR A FEDE LO DE LOS GENES TAN GRANDES!
######################################################################################################################################################################################################################
######################################################################################################################################################################################################################
######################################################################################################################################################################################################################

######################################################################################################################################################################################################################
#
# MARIA's project
#
######################################################################################################################################################################################################################
# Now that I have the file to run over the calculus per unit. To do it in a efficient way I will split this file into as many files as scaffolds. I will do the same with my thetas file. 
# That way I will just have to search over the file that contains the scaffold, and bedtools will be faster.  


##### Thetas files:

cd /home/GRUPOS/grupolince/analysis_genomes_5x/diversity_per_unit

POPS=("KIR_separated_by_scaffold" "DON_separated_by_scaffold" "SMO_separated_by_scaffold" "BIA_separated_by_scaffold" "NOR_separated_by_scaffold")
for MYPOP in "${POPS[@]}"
do
echo "---------------------------------------------------$MYPOP---------------------------------------------------"
mkdir $MYPOP;
done
 

mv BIA.transformedThetas BIA_separated_by_scaffold/
mv DON.transformedThetas DON_separated_by_scaffold/
mv NOR.transformedThetas NOR_separated_by_scaffold/
mv SMO.transformedThetas SMO_separated_by_scaffold/
mv KIR.transformedThetas KIR_separated_by_scaffold/


POPS=("KIR" "DON" "SMO" "BIA" "NOR")
for POP in "${POPS[@]}"
do
echo $POP
cd  /home/GRUPOS/grupolince/analysis_genomes_5x/diversity_per_unit/"$POP"_separated_by_scaffold
# Create multiple files base on one column: transformedThetas:
awk '{print >> $1; close($1)}' "$POP".transformedThetas
rm scaffold 
done

# Rename the files: transformedThetas:
for POP in "${POPS[@]}"
do
cd /home/GRUPOS/grupolince/analysis_genomes_5x/diversity_per_unit/"$POP"_separated_by_scaffold
for file in lp23*
do
echo $file
mv $file ${file/lp23/"$POP".transformedThetas_lp23}
done
done



##### Gff3 files:
cd /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final
mkdir LYPA23C.CDS.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.gff3.PerScaffold
cd LYPA23C.CDS.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.gff3.PerScaffold
# Create multiple files base on one column: gff3:
awk '{print >> $1; close($1)}' ../LYPA23C.CDS.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.gff3
# Rename gff3.
for file in lp23*
do
echo $file
mv $file ${file/lp23/LYPA23C.CDS.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr_lp23}
done



###
LANZADO PARA:
BIA: # running
KIR: # running
NOR: # running
DON: # running
SMO: # running


POPS=("SMO")

POP=c_ll_ki_n020
screen -S "$POP"_scaffold_per_unit
script log_screen_"$POP"_scaffold_per_unit

##WG variables
#SCAFFOLDS_FOLDER=/home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/
#SCAFFOLDS_PATH=/home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.CDS.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.gff3.PerScaffold/#LYPA23C.CDS.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr
#cd $SCAFFOLDS_FOLDER
#SCAFFOLDS=($(ls LYPA23C.CDS.GENE.mRNA.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr* | cut -d'_' -f2 | uniq))
#DIVERSITY_PER_UNIT_FOLDER=/home/GRUPOS/grupolince/analysis_genomes_5x/diversity_per_unit/

#immunome variables
POP=h_lp_al-h_lp_cr-h_lp_do-h_lp_mt-h_lp_pa_n056

screen -S perunit_$POP
POP=h_lp_al-h_lp_cr-h_lp_do-h_lp_mt-h_lp_pa_n056


script perunit_$POP.log
POP=h_lp_al-h_lp_cr-h_lp_do-h_lp_mt-h_lp_pa_n056


SCAFFOLDS_FOLDER=/home/emarmesat/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/immunocapture.PerScaffold/per_scaffold/
SCAFFOLDS_PATH=/home/emarmesat/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/immunocapture.PerScaffold/per_scaffold/LYPA23C.CDS.GENE.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.immuno-intersect_
cd $SCAFFOLDS_FOLDER
SCAFFOLDS=($(ls LYPA23C.CDS.GENE.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.immuno-intersect_* | cut -d'_' -f2 | uniq))
DIVERSITY_PER_UNIT_FOLDER=/home/emarmesat/grupolince/immunocapture/ansgd/diversity_per_unit/

#for POP in "${POPS[@]}"
#do

echo "---------------------------------------------------$POP---------------------------------------------------"

cd "$DIVERSITY_PER_UNIT_FOLDER""$POP"_separated_by_scaffold

# Create headers for the outfile
echo -e "scaffold\tstart\tend\tlength\tNAs\tfeature\tstrandness\tframe\tid_gene\tid\twatterson_ave\twatterson_sd\tpairwise_ave\tpairwise_sd\ttajimaD" > "$POP".per.unit.averages.tsv


for SCAFFOLD in "${SCAFFOLDS[@]}"
do
echo "---------------------$SCAFFOLD---------------------"


#For each unit
while read LOCATION METHOD FEATURE START_ONEBASED END POINT STRANDNESS FRAME IDRAW;
do
echo "--------$SCAFFOLD:$FEATURE--------"
LENGTH=$(expr $END - $START_ONEBASED) 
if [ "$METHOD" = "PipeR" ]; then
	ID_GENE=$(echo $IDRAW | awk -F "_" '{ split ($0, a, "ID="); split (a[2],b,"_"); print b[1]"_"b[2] }')
	else
	ID_GENE=$(echo $IDRAW | awk '{ split($0,a,"ID="); split (a[2],b,";"); split(b[1],c,"T"); print c[1] }') 
fi

if [ "$FEATURE" = "CDS" ]; then
	ID=$(echo $IDRAW | awk -F "_" '{split ($0,a,"Target="); split(a[2],b,";"); print b[1]}' |  awk '{print $1"_"$2"_"$3}' )
	else
	ID=$(echo $IDRAW | awk '{ split($0,a,"ID="); split (a[2],b,";"); print b[1] }')
fi

#Intersect bed of the unit (first remove header)
cat "$POP".transformedThetas_"$SCAFFOLD" | bedtools intersect -a stdin -b <(echo -e "$LOCATION\t$START_ONEBASED\t$END") > "$POP".iter.transformedThetas.borrar

WATTERSON_AVERAGE_PER_UNIT=$(cut -f 4 "$POP".iter.transformedThetas.borrar | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i }} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sum[i]/NR )}}' | sed 's/[eE]+\{0,1\}/*10^/g')
WATTERSON_SD_PER_UNIT=$(cut -f 4 "$POP".iter.transformedThetas.borrar | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR))}}' | sed 's/[eE]+\{0,1\}/*10^/g')


PAIRWISE_AVERAGE_PER_UNIT=$(cut -f 5 "$POP".iter.transformedThetas.borrar | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i }} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sum[i]/NR )}}' | sed 's/[eE]+\{0,1\}/*10^/g') 
PAIRWISE_SD_PER_UNIT=$(cut -f 5  "$POP".iter.transformedThetas.borrar | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR))}}' | sed 's/[eE]+\{0,1\}/*10^/g') 


DIFFERENCE_PAIRWISE_WATTERSON_SD_PER_UNIT=$(cut -f 6  "$POP".iter.transformedThetas.borrar   |  awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR ))}}' | sed 's/[eE]+\{0,1\}/*10^/g') 
TAJIMAS_D_PER_UNIT=$(echo "(($PAIRWISE_AVERAGE_PER_UNIT) - ($WATTERSON_SD_PER_UNIT))/($DIFFERENCE_PAIRWISE_WATTERSON_SD_PER_UNIT)" | bc -l | awk '{printf ("%.10e\n",$1)}' |  sed 's/[eE]+\{0,1\}/*10^/g' )

NR=$(wc -l "$POP".iter.transformedThetas.borrar | cut -d" " -f1)
NAs=$(expr $LENGTH - $NR)

# Calculate averages, and standatd deviations and paste them
paste \
<(echo $LOCATION ) \
<(echo $START_ONEBASED ) \
<(echo $END ) \
<(echo $LENGTH ) \
<(echo $NAs) \
<(echo $FEATURE ) \
<(echo $STRANDNESS ) \
<(echo $FRAME ) \
<(echo $ID_GENE ) \
<(echo $ID) \
<(echo $WATTERSON_AVERAGE_PER_UNIT) \
<(echo $WATTERSON_SD_PER_UNIT) \
<(echo $PAIRWISE_AVERAGE_PER_UNIT) \
<(echo $PAIRWISE_SD_PER_UNIT) \
<(echo $TAJIMAS_D_PER_UNIT) |\
sed 's/ /\t/g'| sed 's/\t\+/\t/g' >>  "$POP".per.unit.averages.tsv
done < <(cat "$SCAFFOLDS_PATH""$SCAFFOLD")
done
# sed 's/ \* /\t/g' "$POP".per.unit.averages.tsv > borrar
rm "$POP".iter.transformedThetas.borrar


#done 









#########ESTOS SON PROBLEMÁTICOS!!!######### no me calcula watterson etc. check pq?

lp23.s00001     5963447 5963590 143     143     CDS     -       2       LYPA23C013812   LYPA23C013812P1_442_490 
lp23.s00001     5963800 5963912 112     0       CDS     -       1       LYPA23C013812   LYPA23C013812P1_404_442 5.0754623776*10^-06     9.5479321550*10^-06     3.6431904233*10^-06     8.2915919056*10^-06     -4.4002365131*10^00
lp23.s00001     5964104 5964116 12      12      CDS     -       2       LYPA23C013812   LYPA23C013812P1_400_404 




# Para hacer una pruebina cojo los 5 primeros scaffolds:



grep -nr lp23.s00005 SMO.per.unit.averages.tsv | tail

8825:lp23.s00005	4609089	4673100	64011	30278	intergenic	x	x	none	none	6.3901712366*10^-05	3.8870657122*10^-03	4.1396801326*10^-05	2.7664932224*10^-03	-2.1810913415*10^00

awk '{if (NR < 8825) print $0}' SMO.per.unit.averages.tsv > SMO.per.unit.averages_lp23.s00001-s00005.tsv
awk '{if (NR < 8825) print $0}' DON.per.unit.averages.tsv > DON.per.unit.averages_lp23.s00001-s00005.tsv


######################################################################################################################################################################################################################
######################################################################################################################################################################################################################
######################################################################################################################################################################################################################

##### ALL THIS PART IS IMPLEMENTED TO RUN OVER THE ENTIRE FILE. I WILL NOT USE THIS AS IT IS VERY TIME CONSUMING. I WILL BE USING THE SCRIPT BEFORE THIS AS IT SPLIT THE FILES AS IT IS WAY MORE FAST.
## I HAVEN'T CHECK IT LATELY --> DON'T KNOW IF IT WORKS ## 

# Compute the Thetas per unit defined in the input bedfile
# Infile product of running ANGSD-sfs...= "$MYPOP".transformedThetas

# cd /home/emarmesat/grupolince/immunocapture/ansgd/sfs
# ruta primera prueba maria: /home/GRUPOS/grupolince/analysis_genomes_5x/diversity_per_unit
# screen -S per_unint_diversity_run1
# script per_unint_diversity_run1.log

# Lanzado1 ( voy lanzando los que van estando listos
# POPS=(KIR DON SMO BIA NOR)

for MYPOP in "${POPS[@]}"
do
echo "---------------------------------------------------$MYPOP---------------------------------------------------"
# Create headers for the outfile
echo -e "scaffold\tstart\tend\tlength\tNAs\tfeature\tstrandness\tframe\tid_gene\tid\twatterson_ave\twatterson_sd\tpairwise_ave\tpairwise_sd\ttajimaD" > "$POP".per.unit.averages.tsv
#For each unit
while read SCAFFOLD METHOD FEATURE START_ONEBASED END POINT STRANDNESS FRAME IDRAW;
do
LENGTH=$(expr $END - $START_ONEBASED) 
if [ "$METHOD" = "PipeR" ]; then
	ID_GENE=$(echo $IDRAW | awk -F "_" '{ split ($0, a, "ID="); split (a[2],b,"_"); print b[1]"_"b[2] }')
	else
	ID_GENE=$(echo $IDRAW | awk '{ split($0,a,"ID="); split (a[2],b,";"); split(b[1],c,"T"); print c[1] }') 
fi
if [ "$FEATURE" = "CDS" ]; then
	ID=$(echo $IDRAW | awk -F "_" '{split ($0,a,"Target="); split(a[2],b,";"); print b[1]}' |  awk '{print $1"_"$2"_"$3}' )
	else
	ID=$(echo $IDRAW | awk '{ split($0,a,"ID="); split (a[2],b,";"); print b[1] }')
fi
#Intersect bed of the unit (first remove header)
tail -n +2 "$MYPOP".transformedThetas | bedtools intersect -a stdin -b <(echo -e "$SCAFFOLD\t$START_ONEBASED\t$END") > "$MYPOP".iter.transformedThetas.borrar
WATTERSON_AVERAGE_PER_UNIT=$(cut -f 4 "$MYPOP".iter.transformedThetas.borrar  | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i }} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sum[i]/NR )}}' | sed 's/[eE]+\{0,1\}/*10^/g')
WATTERSON_SD_PER_UNIT=$(cut -f 4 "$MYPOP".iter.transformedThetas.borrar | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR))}}' | sed 's/[eE]+\{0,1\}/*10^/g')
PAIRWISE_AVERAGE_PER_UNIT=$(cut -f 5  "$MYPOP".iter.transformedThetas.borrar |  awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i }} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sum[i]/NR )}}' | sed 's/[eE]+\{0,1\}/*10^/g') 
PAIRWISE_SD_PER_UNIT=$(cut -f 5  "$MYPOP".iter.transformedThetas.borrar | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR))}}' | sed 's/[eE]+\{0,1\}/*10^/g') 
DIFFERENCE_PAIRWISE_WATTERSON_SD_PER_UNIT=$(cut -f 6  "$MYPOP".iter.transformedThetas.borrar   |  awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR ))}}' | sed 's/[eE]+\{0,1\}/*10^/g') 
TAJIMAS_D_PER_UNIT=$(echo "(($PAIRWISE_AVERAGE_PER_UNIT) - ($WATTERSON_SD_PER_UNIT))/($DIFFERENCE_PAIRWISE_WATTERSON_SD_PER_UNIT)" | bc -l | awk '{printf ("%.10e\n",$1)}' |  sed 's/[eE]+\{0,1\}/*10^/g' )
NR=$(wc -l "$MYPOP".iter.transformedThetas.borrar | cut -d" " -f1)
NAs=$(expr $LENGTH - $NR)
# Calculate averages, and standatd deviations and paste them
paste \
<(echo $LOCATION ) \
<(echo $START_ONEBASED ) \
<(echo $END ) \
<(echo $LENGTH ) \
<(echo $NAs) \
<(echo $FEATURE ) \
<(echo $STRANDNESS ) \
<(echo $FRAME ) \
<(echo $ID_GENE ) \
<(echo $ID) \
<(echo $WATTERSON_AVERAGE_PER_UNIT) \
<(echo $WATTERSON_SD_PER_UNIT) \
<(echo $PAIRWISE_AVERAGE_PER_UNIT) \
<(echo $PAIRWISE_SD_PER_UNIT) \
<(echo $TAJIMAS_D_PER_UNIT) | \
sed 's/ /\t/g'| sed 's/\t\+/\t/g' >>  "$MYPOP".per.unit.averages.tsv
done < /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA23C.all.features.nr.gff3
# sed 's/ \* /\t/g' "$MYPOP".per.unit.averages.tsv > borrar
rm "$MYPOP".iter.transformedThetas.borrar
done 

######################################################################################################################################################################################################################
######################################################################################################################################################################################################################
######################################################################################################################################################################################################################
####################################################################################################################################################################################################################
#
# ELENA's IMMUNOCAPTURE project
#
######################################################################################################################################################################################################################
# Now that I have the file to run over the calculus per unit. To do it in a efficient way I will split this file into as many files as scaffolds. I will do the same with my thetas file. 
# That way I will just have to search over the file that contains the scaffold, and bedtools will be faster.  


######################################################################################
#                       IMMUNOCAPTURE      Gff3 REFERENCE files                      #
######################################################################################
#I'll work with a working version of the annotation where cds and intergenic is properly designes (which are the only features I'm interested in)
#I'll rename it so I'm sure that it's never erased

mv ../LYPA23C.CDS.GENE.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.gff3 LYPA23C.CDS.GENE.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.immunocapture20170303.gff3 


#I'll intersect the per scaffolds files with my capture so that I have even smaller files!

#I'll rename it so I'm sure that it's never erased

ANNOTATION_GFF3="LYPA23C.CDS.GENE.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.immunocapture20170303.gff3"
TARGET="/home/emarmesat/grupolince/immunocapture/capture/nimblegene_final_design/140723_IMMUNOCAP_EMB_EZ_sorted.bed"
#Intersect the current file with the bed file so it only contaings regions of the capture
bedtools intersect -a $ANNOTATION_GFF3 -b $TARGET > ${ANNOTATION_GFF3/immunocapture20170303/immuno-intersect}

mkdir per_scaffold
cd per_scaffold
# Create multiple files base on one column: gff3:
awk '{print >> $1; close($1)}' ../LYPA23C.CDS.GENE.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.immuno-intersect.gff3
# Rename gff3.
for file in lp23*
do
echo $file
mv $file ${file/lp23/LYPA23C.CDS.GENE.PROMOTERS.INTRONS.UTR.lncRNA.ncRNA.INTERGENIC.nr.immuno-intersect_lp23}
done






```









# Modification over per unit script: modif_per_unit_script:


```{r, engine=bash, eval=FALSE}
cat LYPA23C.all.features.nr.gff3 | grep -v "exon" > LYPA23C.all.features.nr.without_exons.gff3


##### Thetas files:

cd /home/mlucena/grupolince/analysis_genomes_5x/diversity_per_unit

POPS=("KIR_separated_by_scaffold" "DON_separated_by_scaffold" "SMO_separated_by_scaffold" "BIA_separated_by_scaffold" "NOR_separated_by_scaffold")
for MYPOP in "${POPS[@]}"
do
echo "---------------------------------------------------$MYPOP---------------------------------------------------"
mkdir $MYPOP;
done
 

mv BIA.transformedThetas BIA_separated_by_scaffold/
mv DON.transformedThetas DON_separated_by_scaffold/
mv NOR.transformedThetas NOR_separated_by_scaffold/
mv SMO.transformedThetas SMO_separated_by_scaffold/
mv KIR.transformedThetas KIR_separated_by_scaffold/


POPS=("KIR" "DON" "SMO" "BIA" "NOR")
for POP in "${POPS[@]}"
do
echo $POP
cd  /home/mlucena/grupolince/analysis_genomes_5x/diversity_per_unit/"$POP"_separated_by_scaffold
# Create multiple files base on one column: transformedThetas:
awk '{print >> $1; close($1)}' "$POP".transformedThetas
rm scaffold 
done

# Rename the files: transformedThetas:
for POP in "${POPS[@]}"
do
cd /home/mlucena/grupolince/analysis_genomes_5x/diversity_per_unit/"$POP"_separated_by_scaffold
for file in lp23*
do
echo $file
mv $file ${file/lp23/"$POP".transformedThetas_lp23}
done
done



##### Gff3 files:
cd /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final
mkdir LYPA.perScaffold
cd LYPA.perScaffold
# Create multiple files base on one column: gff3:
awk '{print >> $1; close($1)}' LYPA23C.all.features.nr.without_exons.gff3
# Rename gff3.
for file in lp23*
do
echo $file
mv $file ${file/lp23/LYPA23C.all.features.nr.without_exons_lp23}
done



###
LANZADO PARA:
BIA: # --> RUNNING!
KIR: # --> RUNNING!
NOR: # --> RUNNING!
DON: # --> RUNNING!
SMO: # --> RUNNING!



screen -S SMO_scaffold_per_unit
script log_screen_SMO_scaffold_per_unit
POPS=("SMO")
SCAFFOLDS=($(ls /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA.perScaffold/LYPA23C.all.features.nr.without_exons_* | cut -d'_' -f7 | uniq))


for MYPOP in "${POPS[@]}"
do

echo "---------------------------------------------------$MYPOP---------------------------------------------------"

cd /home/mlucena/grupolince/analysis_genomes_5x/diversity_per_unit/"$MYPOP"_separated_by_scaffold

# Create headers for the outfile
echo -e "scaffold\tstart\tend\tlength\tNAs\tfeature\tstrandness\tframe\tid\twatterson_ave\twatterson_sd\tpairwise_ave\tpairwise_sd\tpairwise-watterson" > "$MYPOP".per.unit.averages.tsv


for SCAFFOLD in "${SCAFFOLDS[@]}"
do
echo "---------------------$SCAFFOLD---------------------"


#For each unit
while read LOCATION METHOD FEATURE START_ONEBASED END POINT STRANDNESS FRAME IDRAW;

do
echo "--------$SCAFFOLD:$FEATURE--------"
LENGTH=$(expr $END - $START_ONEBASED) 
ID_GENE=$(echo $IDRAW | awk '{ split($0,a,"ID="); split (a[2],b,";"); split(b[1],c,"T"); print c[1] }') 
if [ "$FEATURE" = "CDS" ]; then
	ID=$(echo $IDRAW | awk -F "_" '{split ($0,a,"Target="); split(a[2],b,";"); print b[1]}' |  awk '{print $1"_"$2"_"$3}' )
	else
	ID=$(echo $IDRAW | awk '{ split($0,a,"ID="); split (a[2],b,";"); print b[1] }')
fi

#Intersect bed of the unit (first remove header)
cat "$MYPOP".transformedThetas_"$SCAFFOLD" | bedtools intersect -a stdin -b <(echo -e "$LOCATION\t$START_ONEBASED\t$END") > "$MYPOP".iter.transformedThetas.borrar

WATTERSON_AVERAGE_PER_UNIT=$(cut -f 4 "$MYPOP".iter.transformedThetas.borrar  | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i }} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sum[i]/NR )}}' | sed 's/[eE]+\{0,1\}/*10^/g')
WATTERSON_SD_PER_UNIT=$(cut -f 4 "$MYPOP".iter.transformedThetas.borrar | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR))}}' | sed 's/[eE]+\{0,1\}/*10^/g')


PAIRWISE_AVERAGE_PER_UNIT=$(cut -f 5  "$MYPOP".iter.transformedThetas.borrar |  awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i }} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sum[i]/NR )}}' | sed 's/[eE]+\{0,1\}/*10^/g') 
PAIRWISE_SD_PER_UNIT=$(cut -f 5  "$MYPOP".iter.transformedThetas.borrar | awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR))}}' | sed 's/[eE]+\{0,1\}/*10^/g') 


DIFFERENCE_PAIRWISE_WATTERSON_SD_PER_UNIT=$(cut -f 6  "$MYPOP".iter.transformedThetas.borrar   |  awk -v OFS='\t' '{for(i=1;i<=NF;i++) {sum[i] += $i; sumsq[i] += ($i)^2}} END {for (i=1;i<=NF;i++) {printf ("%.10e\n", sqrt((sumsq[i]-sum[i]^2/NR)/NR ))}}' | sed 's/[eE]+\{0,1\}/*10^/g') 
TAJIMAS_D_PER_UNIT=$(echo "(($PAIRWISE_AVERAGE_PER_UNIT) - ($WATTERSON_SD_PER_UNIT))/($DIFFERENCE_PAIRWISE_WATTERSON_SD_PER_UNIT)" | bc -l | awk '{printf ("%.10e\n",$1)}' |  sed 's/[eE]+\{0,1\}/*10^/g' )

NR=$(wc -l "$MYPOP".iter.transformedThetas.borrar | cut -d" " -f1)
NAs=$(expr $LENGTH - $NR)

# Calculate averages, and standatd deviations and paste them
paste \
<(echo $LOCATION ) \
<(echo $START_ONEBASED ) \
<(echo $END ) \
<(echo $LENGTH ) \
<(echo $NAs) \
<(echo $FEATURE ) \
<(echo $STRANDNESS ) \
<(echo $FRAME ) \
<(echo $ID_GENE ) \
<(echo $ID) \
<(echo $WATTERSON_AVERAGE_PER_UNIT) \
<(echo $WATTERSON_SD_PER_UNIT) \
<(echo $PAIRWISE_AVERAGE_PER_UNIT) \
<(echo $PAIRWISE_SD_PER_UNIT) \
<(echo $TAJIMAS_D_PER_UNIT) |\
sed 's/ /\t/g'| sed 's/\t\+/\t/g' >>  "$MYPOP".per.unit.averages.tsv

done < <( cat /home/GRUPOS/grupolince/Lynx_annotation/Lyp_annotation_Apr14_final/LYPA.perScaffold/LYPA23C.all.features.nr.without_exons_$SCAFFOLD)
done
# sed 's/ \* /\t/g' "$MYPOP".per.unit.averages.tsv > borrar
rm "$MYPOP".iter.transformedThetas.borrar
done 


## I stopped it after a while and rename files:
POPS=("KIR" "DON" "SMO" "BIA" "NOR")
for MYPOP in "${POPS[@]}"
do

echo "---------------------------------------------------$MYPOP---------------------------------------------------"

cd /home/mlucena/grupolince/analysis_genomes_5x/diversity_per_unit/"$MYPOP"_separated_by_scaffold
mv "$MYPOP".per.unit.averages.tsv "$MYPOP".per.unit.averages.test.tsv
done

```



