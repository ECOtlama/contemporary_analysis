---
title: "13.Diversity_lost_modelling"
output: html_document
---

15/09/2019
We are going to explore different HGAM to try to explain the differences in changes in diversity after a bottleneck.
Models are pretty complex, so we will start by trying to explain the accumulation of diversity in CDS.

I could also run my model in the server, therefore I create a folder. 
```{bash}
mkdir /home/mlucena/diversity_loss_modeling
scp -p /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/*diversity.txt  mlucena@genomics-b.ebd.csic.es:/home/mlucena/diversity_loss_modeling
```

Script de R que puedo correr en local o en el servidor. 

## Library load

```{r}
library(viridis)
library(ggplot2); theme_set(theme_minimal())
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(mgcv)
library(MuMIn) 
library(mgcViz) #--> Need X11
library(gratia) 
library (Hmisc)
```

## Data load 

```{r}
########################
### Server ###
# all_comparisons_diversity_bootleneck_vs_non_bootleneck <- read.table ("/home/mlucena/diversity_loss_modeling/all_comparisons_diversity_bootleneck_vs_non_bootleneck.txt", row.names = NULL, sep =";", dec=",", header=T, stringsAsFactors = F, comment.char="")
# wd_output <- ""
#####################
### Local ###
wd <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/comparison_among_pops/"
wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/GAM_models/"
all_comparisons_diversity_bootleneck_vs_non_bootleneck <- read.table (paste0 (wd, "all_comparisons_diversity_bootleneck_vs_non_bootleneck.txt"), row.names = NULL, sep =";", dec=",", header=T, comment.char="", na.strings = c("NA", "na"))
##########################
```

## Data filtering

Because I might use cat coordinates for assessing spatial autocorrelation, I will first inspect the data to see if the position cat end - position cat start is similar to that reported for the scaffold coordinates, i.e. whether the unit is well annotated not only regarding the chr, but also the precise position within chr. 

We have already remove those units that were annotated for more than a chr, but we haven't done this filtering before because it didn't affect all the other results. However to consider spatial autocorrelation, we have to use only those units with the precise position. 
```{r}
all_comparisons_diversity_bootleneck_vs_non_bootleneck_test <- all_comparisons_diversity_bootleneck_vs_non_bootleneck %>% mutate (cat_length=cat_position_end-cat_position_start) %>% mutate (difference_cat_lenght_lynx_lenght=as.numeric(cat_length-length))

# En cuantos casos coincide perfecto la longitud de gato y de lince?
nrow(all_comparisons_diversity_bootleneck_vs_non_bootleneck_test)
# 1081057
nrow(all_comparisons_diversity_bootleneck_vs_non_bootleneck_test %>% filter (difference_cat_lenght_lynx_lenght==0))
# 547203

# Aproximadamente la mitad.

# Y si yo eliminase todo aquello que tiene mas de 10000 bases de distancia?

nrow(all_comparisons_diversity_bootleneck_vs_non_bootleneck_test %>% filter (difference_cat_lenght_lynx_lenght<10000) %>% filter( difference_cat_lenght_lynx_lenght>-10000))
# 1078065

#Me quedo con el 99,72! esta super bien!
#Incluso puedo intentar filtrar un poco mas.  
nrow(all_comparisons_diversity_bootleneck_vs_non_bootleneck_test %>% filter (difference_cat_lenght_lynx_lenght<1000) %>% filter( difference_cat_lenght_lynx_lenght>-1000))
# 1027583
# Filtrando todas las que se pasan de 1000 bases de diferencia, me quedo con 95%! este filtro me parece bien. 

nrow(all_comparisons_diversity_bootleneck_vs_non_bootleneck_test %>% filter (difference_cat_lenght_lynx_lenght<500) %>% filter( difference_cat_lenght_lynx_lenght>-500))
# 986314
# 91.23608


# Elegir threshold. Ahora mismo voy a escoger 1000 para las pruebas. 
ggplot (data=all_comparisons_diversity_bootleneck_vs_non_bootleneck_test %>% filter (difference_cat_lenght_lynx_lenght!=0) %>% filter (comparison=="Andujar-Donana") %>% filter (difference_cat_lenght_lynx_lenght<1000) %>% filter( difference_cat_lenght_lynx_lenght>-1000), aes(length, cat_length)) +
  geom_point()+
  geom_abline(intercept = 0)

# El plot se ve bastante bien. 

all_comparisons_diversity_bootleneck_vs_non_bootleneck_filtered <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_test %>% filter (difference_cat_lenght_lynx_lenght<1000) %>% filter( difference_cat_lenght_lynx_lenght>-1000)


```


## Sanity check

```{r}
# Antes de seleccionar las variables, vamos a hacer algunas comprobaciones

# 1. ¿Cómo se relacionan los informative sites de ambas poblaciones?
ggplot (head (all_comparisons_diversity_bootleneck_vs_non_bootleneck, n=5000), aes(informative_sites.x, informative_sites.y)) +
  geom_point() +
  ggsave(paste0(wd_output, "informative_sites_lm.pdf"))
# La relación es completamente lineal, así que podemos usar como covariables (variable respuesta) los de cualquiera de la poblacion implicada en esa comparación (.x o .y) indistintamente. 
 
# 2. Should I scale my variables?
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$watterson_zero.x)
# 0.02426801
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$informative_sites.x)
# 544166
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$rvis_score, na.rm=TRUE)
# 10.78656
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$recombination_rate, na.rm=TRUE)
# 70.90716
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$divergence, na.rm=TRUE)
# 0.5
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$GC_content)
# 0.876033

# Yes! The magnitude is completely different, so it makes sense to scale then to be able to interpret our results; i.e. a change of one unit (whatever a unit is) of this variable, have this effect. 

# Now I will check value distribution of the recombination.
hist(all_comparisons_diversity_bootleneck_vs_non_bootleneck$recombination_rate)

```

## Modif my data to fit the model

```{r}
# Como veo hay muy pocos valores por encima de 20, y creo que esto puede estar falseando mis datos, ya que:
# 1. Afecta al escalado agrupando valores de baja recombinación que realmente deberían de estar separados.
# 2. Esto puede hacer que los efectos de valores bajos de recombinación queden ocultos.
# 3. Los hotspot de recombinación NO estan conservados entre especies, y por tanto no tendría sentido mantenerlo.

all_comparisons_diversity_bootleneck_vs_non_bootleneck <- all_comparisons_diversity_bootleneck_vs_non_bootleneck %>% 
  # Filtramos los recombination hotspot.
  filter (recombination_rate<10) #%>% 
  # Nos quedamos sólo con los que tienen ganancia de divesidad
  #filter (delta_watterson_per_unit_zero<0)

nrow(all_comparisons_diversity_bootleneck_vs_non_bootleneck)
# 962955

# Ahora escalamos las variables respuestas
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale <- all_comparisons_diversity_bootleneck_vs_non_bootleneck %>% 
  mutate (watterson_zero.x_scale=scale (watterson_zero.x)) %>% 
  mutate (pairwise_zero.x_scale=scale (pairwise_zero.x)) %>% 
  mutate (informative_sites.x_scale=scale (informative_sites.x)) %>% 
  mutate (recombination_rate_scale=scale (recombination_rate)) %>% 
  mutate (recombination_rate_log=log (recombination_rate)) %>% 
  mutate (divergence_scale=scale (divergence)) %>% 
  mutate (GC_content_scale=scale (GC_content)) %>% 
  mutate (rvis_score_scale=scale (rvis_score)) %>% 
  mutate (delta_watterson_per_unit_zero_scale=scale(delta_watterson_per_unit_zero)) %>% 
  mutate (k.x=watterson_zero.x*informative_sites.x) %>% 
  mutate (k.y=watterson_zero.y*informative_sites.y)

# Otra manera de escalar sería la siguiente
# rescale <- function (x) { (x - mean (x)) / sd (x) }
# for (i in ncol (data)) {
#   data[, i] <-  rescale (data[, i])
# }

# I also have to remove the order of the random factors I will be using. 
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$feature <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$feature , ordered = FALSE )
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$chr <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$chr , ordered = FALSE )
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$region <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$region , ordered = FALSE )
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$scaffold <- as.factor(all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$scaffold)

```

## Modif my data FILTERED to fit the model

```{r}
# Como veo hay muy pocos valores por encima de 20, y creo que esto puede estar falseando mis datos, ya que:
# 1. Afecta al escalado agrupando valores de baja recombinación que realmente deberían de estar separados.
# 2. Esto puede hacer que los efectos de valores bajos de recombinación queden ocultos.
# 3. Los hotspot de recombinación NO estan conservados entre especies, y por tanto no tendría sentido mantenerlo.

all_comparisons_diversity_bootleneck_vs_non_bootleneck_filtered <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_filtered %>% 
  # Filtramos los recombination hotspot.
  filter (recombination_rate<10) #%>% 
  # Nos quedamos sólo con los que tienen ganancia de divesidad
  #filter (delta_watterson_per_unit_zero<0)

nrow(all_comparisons_diversity_bootleneck_vs_non_bootleneck_filtered)
# En este caso son 915819 en lugar de 962955, por el filtrado de la posición!

# Ahora escalamos las variables respuestas
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_filtered %>% 
  mutate (watterson_zero.x_scale=scale (watterson_zero.x)) %>% 
  mutate (pairwise_zero.x_scale=scale (pairwise_zero.x)) %>% 
  mutate (informative_sites.x_scale=scale (informative_sites.x)) %>% 
  mutate (recombination_rate_scale=scale (recombination_rate)) %>% 
  mutate (recombination_rate_log=log (recombination_rate)) %>% 
  mutate (divergence_scale=scale (divergence)) %>% 
  mutate (GC_content_scale=scale (GC_content)) %>% 
  mutate (rvis_score_scale=scale (rvis_score)) %>% 
  mutate (delta_watterson_per_unit_zero_scale=scale(delta_watterson_per_unit_zero)) %>% 
  mutate (k.x=watterson_ave_corrected.x*informative_sites.x) %>% 
  mutate (k.y=watterson_ave_corrected.y*informative_sites.y)

# Otra manera de escalar sería la siguiente
# rescale <- function (x) { (x - mean (x)) / sd (x) }
# for (i in ncol (data)) {
#   data[, i] <-  rescale (data[, i])
# }

# I also have to remove the order of the random factors I will be using. 
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$feature <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$feature , ordered = FALSE )
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$chr <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$chr , ordered = FALSE )
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$region <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$region , ordered = FALSE )
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$scaffold <- as.factor(all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$scaffold)

```


## Subset my data for different models
## - Select CDS 
I will use only CDS to try to explain changes in diversity in this particular category. 

### Kirov-Norway
```{r}
CDS_c_ll_ki_c_ll_no_dataframe <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale %>% 
  dplyr::filter (feature=="CDS") %>% 
  dplyr::filter (chr!="chrX") %>% 
  dplyr::filter (comparison=="Kirov-Norway") %>% 
  dplyr::mutate (middle_position_cat=cat_position_start+(cat_length/2)) %>% 
  select (comparison,
          scaffold,
          start_cero_based,
          cat_position_start,
          cat_position_end,
          middle_position_cat,
          delta_watterson_per_unit_zero_scale,
          delta_watterson_per_unit_zero, 
          #delta_pairwise_per_unit_zero,
          informative_sites.x_scale,
          watterson_zero.x_scale, 
          watterson_zero.y,
          k.x,
          k.y,
          #pairwise_zero.x_scale, 
          recombination_rate_scale,
          divergence_scale, 
          GC_content_scale,  
          rvis_score_scale,
          region,
          chr, 
          informative_sites.x,
          informative_sites.y,
          watterson_zero.x, 
          pairwise_zero.x,
          recombination_rate,
          recombination_rate_log,
          divergence, 
          GC_content,  
          rvis_score)

# Name is mod I because each one of the variable could have a different function and smother depending on the random factor  (check paper)
# Remove cases with no data. 
CDS_c_ll_ki_c_ll_no_dataframe <- CDS_c_ll_ki_c_ll_no_dataframe[complete.cases(CDS_c_ll_ki_c_ll_no_dataframe), ]
nrow(CDS_c_ll_ki_c_ll_no_dataframe)
# n=29950 --> Kirov-Norway
# n=29950 --> Kirov-Ne_Poland
# n=28941 --> Andujar-Doñana

## Submuestreo de las celdas con 0
CDS_c_ll_ki_c_ll_no_dataframe_only0 <- filter(CDS_c_ll_ki_c_ll_no_dataframe, delta_watterson_per_unit_zero==0) %>% sample_n(., 500, replace=F)
CDS_c_ll_ki_c_ll_no_dataframe_no0 <- filter(CDS_c_ll_ki_c_ll_no_dataframe, delta_watterson_per_unit_zero!=0)
CDS_c_ll_ki_c_ll_no_dataframe2 <- rbind(CDS_c_ll_ki_c_ll_no_dataframe_only0, CDS_c_ll_ki_c_ll_no_dataframe_no0)

dataframe=CDS_c_ll_ki_c_ll_no_dataframe
 
test <- dataframe %>% filter(watterson_zero.x==0) %>% mutate (delta_round=round(delta_watterson_per_unit_zero, digits=4)*-10000)



```

### Andujar-Doñana
```{r}
CDS_c_lp_sm_c_lp_do_dataframe <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale %>% 
  dplyr::filter (feature=="CDS") %>% 
  dplyr::filter (chr!="chrX") %>% 
  dplyr::filter (comparison=="Andujar-Donana") %>% 
   dplyr::mutate (middle_position_cat=cat_position_start+(cat_length/2)) %>% 
  select (comparison,
          scaffold,
          start_cero_based,
          cat_position_start,
          cat_position_end,
          middle_position_cat,
          delta_watterson_per_unit_zero_scale,
          delta_watterson_per_unit_zero, 
          #delta_pairwise_per_unit_zero,
          informative_sites.x_scale,
          watterson_zero.x_scale, 
          watterson_zero.y,
          k.x,
          k.y,
          #pairwise_zero.x_scale, 
          recombination_rate_scale,
          divergence_scale, 
          GC_content_scale,  
          rvis_score_scale,
          region,
          chr, 
          informative_sites.x,
          informative_sites.y,
          watterson_zero.x, 
          pairwise_zero.x,
          recombination_rate,
          recombination_rate_log,
          divergence, 
          GC_content,  
          rvis_score)
# Name is mod I because each one of the variable could have a different function and smother depending on the random factor  (check paper)
# Remove cases with no data. 
CDS_c_lp_sm_c_lp_do_dataframe <- CDS_c_lp_sm_c_lp_do_dataframe[complete.cases(CDS_c_lp_sm_c_lp_do_dataframe), ]
nrow(CDS_c_lp_sm_c_lp_do_dataframe)
# n=29950 --> Kirov-Norway
# n=29950 --> Kirov-Ne_Poland
# n=28941 --> Andujar-Doñana

#dataframe=CDS_c_ll_ki_c_ll_no_dataframe 
#dataframe=CDS_c_ll_ki_c_ll_po_dataframe
dataframe=CDS_c_lp_sm_c_lp_do_dataframe
smo_don_LD <- dataframe %>% filter(watterson_zero.x==0) %>% mutate (delta_round=round(delta_watterson_per_unit_zero, digits=4)*-10000)

```

### Gplot relationships

```{r}
Pop_comparison="c_lp_sm_c_lp_do"

## Initial diversity
ggplot (data=dataframe, aes (watterson_zero.x, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_watterson_delta_watterson.pdf"))


ggplot (data=dataframe, aes (watterson_zero.x, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_watterson_delta_watterson_by_chr.pdf"))



## Recombination
ggplot (data=dataframe, aes (recombination_rate, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_recombination_delta_watterson.pdf"))


ggplot (data=dataframe, aes (recombination_rate, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_recombination_delta_watterson_by_chr.pdf"))




## Divergence
ggplot (data=dataframe, aes (divergence, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_divergence_delta_watterson.pdf"))


ggplot (data=dataframe, aes (divergence, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_divergence_delta_watterson_by_chr.pdf"))



## rvis
ggplot (data=dataframe, aes (rvis_score, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_rvis_delta_watterson.pdf"))


ggplot (data=dataframe, aes (rvis_score, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_rvis_delta_watterson_by_chr.pdf"))



## GC content
ggplot (data=dataframe, aes (GC_content, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_GC_delta_watterson.pdf"))


ggplot (data=dataframe, aes (GC_content, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_GC_delta_watterson_by_chr.pdf"))

```




### Nule model selection

```{r}
# First I will run an histogram of my response variable.

hist((dataframe$delta_watterson_per_unit_zero))
# como vemos es una normal con un pico muy grande en 0. Esto corresponde a la familia gaussian. Además he probado a modelar con otras familias y no puedo porque tiene valores negativos. 
m0a<-gam(delta_watterson_per_unit_zero ~ 1, data = dataframe,  family = gaussian)
AICc(m0a)
# -351521.4
```

#### Check overdispersion
```{r}
overdisp_fun <- function(model) {
  rdf <- model$df.res
  rp <- resid(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  c(chisq=Pearson.chisq,OverdispersionParameter=prat,rdf=rdf,p=pval)
}

overdisp_fun(m0a)
#chisq OverdispersionParameter                     rdf                       p 
#           8.994523e-03            3.107990e-07            2.894000e+04            1.000000e+00 
sum(residuals(m0a, type = "deviance")^2)/m0a$df.residual

# Overdispersion (cu?nto m?s alejado est? de 0 el valor mayor sobredispersi?n)
# 3.10799e-07

ovd_a <- resid(m0a, type = "pearson")
(overdispersion <- sum(ovd_a^2) / (m0a$df.res)) # 3.10799e-07

# Si estuviese eligiendo familia me quedaría con la que menor sobredispersión tuviese, pero como no es el caso lo calculo para luego compararlo con mis modelos ajustados. 

# De nuevo vemos que el modelo con la familia nb es el que menos overdispersi?n tiene

rm(m0a,ovd_a)

```

### Correlation between vars.

Aunque yo ya la había calculado, voy a repetirlo, porque hay algunos cambios, como que la recombinación solo llega a 10, y las variables que uso. 

```{r}
# Relacion recombinación-divergencia. 
ggplot (dataframe, aes(recombination_rate_scale, divergence_scale)) +
  geom_smooth()


cormatrix <- rcorr(as.matrix(dataframe %>% dplyr::select(-region, -chr))) 
cormatrix
cordata = melt(cormatrix$r)
correlation <- ggplot(cordata, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() + xlab("") + ylab("")
ggsave(paste (wd_output, "correlation_plot.tiff", sep = "/"),
       correlation, device = NULL,
       scale = 1, width = 20, height = 10, units = c("in"),
       dpi = 600)


cor(dataframe %>% dplyr::select(-region, -chr), method = "spearman")
Spearman <- as.data.frame(cor(dataframe %>% dplyr::select(-region, -chr), method = "spearman"))
write.table(Spearman,paste (wd_output, "Spearman.txt"),quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)

# Nota Isa: En esa tabla que acabas de guardar miras las variables correlacionadas, aqu? debes decidir
# el valor de rho |r| a partir del cu?l descartas variables, puedes ser flexible hasta 0.7
# aunque ultimente los papers est?n siendo m?s estrictos bajando hasta el 0.5 e incluso el 0.4


# Nota mía: He comprobado que ninguna de mis variables están correlacionadas a más de 0.4, por tanto puedo incluirlas todas. 

rm(cormatrix, correlation, Spearman)

# When you have you correlated variables then:

# Nota María: Esto no lo tengo que hacer porque no están correlacionadas. 
## Fit models to know which variable you need to delete from the dataset
## eg: your correlated variables are var1 with var2 & var4 with var7
# 
# m0a<-gam(sbalphy ~ s(var1), offset = (log (effort)), data = data,  family = nb)
# m0b<-gam(sbalphy ~ s(var2), offset = (log (effort)), data = data,  family = nb)
# 
# AIC(m0a); AIC(m0b)
# [m0a] 864.3353
# [m0b] 837.2231
# 
# # So we delete var1
# 
# m0a<-gam(sbalphy ~ s(var4), offset = (log (effort)), data = data,  family = nb)
# m0b<-gam(sbalphy ~ s(var7), offset = (log (effort)), data = data,  family = nb)
# 
# AIC(m0a); AIC(m0b)
# [m0a] 871.046
# [m0b] 870.3191

```
### GLM diversity

```{r}
hist(dataframe$watterson_zero.x)
hist(dataframe$watterson_zero.y)

model_glm <- glm (1+watterson_zero.y ~ watterson_zero.x, family = Gamma(), data = dataframe)

TEST_data_frame <- cbind(dataframe, resid=resid(model_glm), fitted=fitted(model_glm))

plot(dataframe$watterson_zero.x, dataframe$watterson_zero.y)

summary (model_glm)
plot(model_glm)

#https://drsimonj.svbtle.com/visualising-residuals

#https://www.researchgate.net/post/Is_it_possible_to_use_the_residuals_from_a_first_stage_regression_on_a_non-linear_model
```



### FIT GAMs 
#### Simple model 

Voy a hacer una especie de diario / script de los pasos que voy dando. El diario se puede encontrar en el día 4 de Enero de 2020. 

Lo primero que voy a correr es un modelo en el que la delta solo dependa de la diversidad inicial, para ver cómo se comportan los residuos. 

```{r}
# Hago un subset de mi data frame para que corra más rápido. 
# dataframe1 <- sample_n(dataframe, 1000)
model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_watterson_zero_k10"

model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_watterson_zero_cat_position_by_chr"

model1  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp")+
                    s(middle_position_cat, by=chr),
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)
# SERVER
#save(model1, file=paste0(model_name))

#wd_output<- ""
# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

gam.check(model1)

qq.gam(model1)
rqgam.check(model1)
install.packages("dsm")
```

#### Model with variables 

```{r}

model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_round_informative_cat_position_recomb_diver_GC_rvis_recomb_rvis_interaction_ziplss"



model2  <- gam (list(delta_round ~
# Covariables: las metemos como explicativas #  
  s(informative_sites.x, bs="tp") +
# Explicativas
  s(middle_position_cat, by=chr) +
  s(recombination_rate_scale, by=chr)+
  s(divergence_scale, by=chr)+
  s(GC_content_scale, by=chr)+
  s(rvis_score_scale, by=chr)+
  ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp")),
  ~  s(informative_sites.x, bs="tp") +
# Explicativas
  s(middle_position_cat, by=chr) +
  s(recombination_rate_scale, by=chr)+
  s(divergence_scale, by=chr)+
  s(GC_content_scale, by=chr)+
  s(rvis_score_scale, by=chr)+
  ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"))),
# Explicativas  
  # offset = (log(informative_sites.x)),
  # Dataframe
   data=smo_don_LD,
  # Method and family
  #method="REML",
   family=ziplss())


#gam.check(model2)
# Save the model
save(model2, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model2)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model2))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model2)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model2)
dev.off()


plot (predict(model2,type="response"), residuals(model2))
plot (predict(model2,type="response"), model2$y);abline(0,1,col=2)

```
Lo que comprobamos es que los residuos parecen tener problemas de tendencia y de dispersión. 

Por tanto voy a probar a transformar mi variable respuesta a ver si mejora.
Las transformaciones que se me ocurren probar son varias:

Lo primero que voy a hacer es probar a quitar los ceros. Los ceros son unidades que ni ganan ni pierden diversidad y por tanto no aportan tanto. 

### LOAD MODELS FROM THE SERVER

```{bash}
scp -p mlucena@genomics-b.ebd.csic.es:/home/mlucena/diversity_loss_modeling/mod_CDS_c_lp_sm_c_lp_do_delta_round_informative_cat_position_recomb_diver_GC_rvis_recomb_rvis_interaction_ziP* /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/GAM_models/
```
  
    
```{r}
model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_round_informative_cat_position_recomb_diver_GC_rvis_recomb_rvis_interaction_ziP_filtered"
load(paste0(wd_output,model_name), .GlobalEnv)


plot (predict(model2,type="response"), residuals(model2))
plot (predict(model2,type="response"), model2$y);abline(0,1,col=2)

qqplot(model2)
```






##### Remove 0 from response variable. 

Lo que he hecho ha sido añadir como variables delta_watterson_per_unit_normalized_zero, y como esta variable coge valor NA cuando la otra es cero, así ya la elimino. 
```{r}
model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_no0_watterson_zero_k10"
hist(dataframe$delta_watterson_per_unit_zero)
# El histograma tiene mejor pinta!

model1  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

Vemos que la distribución de residuos y Q-Q plot no mejora, así que pruebo con la delta normalizada. 

##### Normalized delta.

```{r}
model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_normalized_watterson_zero_k10"
hist(dataframe$delta_watterson_per_unit_normalized_zero)

model1  <- gam (delta_watterson_per_unit_normalized_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```
##### Transform normalized delta.

```{r}
model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_normalized_arcsine_watterson_zero_k10"

model1  <- gam (asin(delta_watterson_per_unit_normalized_zero) ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

#### Model with varibales on normalized data

```{r}

model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_normalized_watterson_zero_informative_sites_recombination_rvis_interaction_k10"

model1  <- gam (delta_watterson_per_unit_normalized_zero ~
 # Covariables: las metemos como explicativas #  
                    s(informative_sites.x_scale, bs="tp", k=10) +
                    s(watterson_zero.x_scale,  bs="tp", k=10) +
                    ti(watterson_zero.x_scale, informative_sites.x_scale, bs=c("tp", "tp"), k=c(10,10))+
                    # Variables explicativas # 
                    s(recombination_rate_scale, bs="tp", k=10, m=2)+
                    ti(recombination_rate_scale, watterson_zero.x_scale,bs=c("tp", "tp"), k=c(10,10))+
                    #s(divergence_scale,  bs="tp", k=10)+
                    #s(GC_content_scale,  bs="tp", k=10)+
                    s(rvis_score_scale,  bs="tp", k=10)+
                    ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(10,10)),
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")


# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```


# Norway and Kirov

```{r}
CDS_c_ll_ki_c_ll_no_dataframe_complete <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale %>% 
  dplyr::filter (feature=="CDS") %>% 
  dplyr::filter(comparison=="Kirov-Norway") %>% 
  select (delta_watterson_per_unit_zero_scale,
          delta_watterson_per_unit_zero, 
          delta_pairwise_per_unit_zero,
          delta_watterson_per_unit_normalized_zero, 
          delta_pairwise_per_unit_normalized_zero,
          informative_sites.x_scale,
          watterson_zero.x_scale, 
          pairwise_zero.x_scale, 
          recombination_rate_scale,
          divergence_scale, 
          GC_content_scale,  
          rvis_score_scale,
          region,
          chr, 
          informative_sites.x,
          watterson_zero.x, 
          pairwise_zero.x,
          recombination_rate,
          recombination_rate_log,
          divergence, 
          GC_content,  
          rvis_score,
          region,
          chr)

# Name is mod I because each one of the variable could have a different function and smother depending on the random factor  (check paper)
# Remove cases with no data. 
CDS_c_ll_ki_c_ll_no_dataframe <- CDS_c_ll_ki_c_ll_no_dataframe_complete[complete.cases(CDS_c_ll_ki_c_ll_no_dataframe_complete), ]
nrow(CDS_c_ll_ki_c_ll_no_dataframe)
# n=29950 --> Kirov-Norway
# n=29950 --> Kirov-Ne_Poland
# n=28941 --> Andujar-Doñana

#dataframe=CDS_c_ll_ki_c_ll_no_dataframe 
#dataframe=CDS_c_ll_ki_c_ll_po_dataframe
dataframe=CDS_c_ll_ki_c_ll_no_dataframe

```


### FIT GAMs 
#### Simple model 

Voy a hacer una especie de diario / script de los pasos que voy dando. El diario se puede encontrar en el día 4 de Enero de 2020. 

Lo primero que voy a correr es un modelo en el que la delta solo dependa de la diversidad inicial, para ver cómo se comportan los residuos. 

```{r}
# Hago un subset de mi data frame para que corra más rápido. 
#dataframe1 <- sample_n(dataframe, 1000)

model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_watterson_zero_k10"
model1  <- gam (log(delta_watterson_per_unit_zero +1) ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

Lo que comprobamos es que los residuos parecen tener problemas de tendencia y de dispersión. 

Por tanto voy a probar a transformar mi variable respuesta a ver si mejora.
Las transformaciones que se me ocurren probar son varias:

Lo primero que voy a hacer es probar a quitar los ceros. Los ceros son unidades que ni ganan ni pierden diversidad y por tanto no aportan tanto. 
##### Remove 0 from response variable. 

Lo que he hecho ha sido añadir como variables delta_watterson_per_unit_normalized_zero, y como esta variable coge valor NA cuando la otra es cero, así ya la elimino. 
```{r}
model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_no0_watterson_zero_k10"
hist(dataframe$delta_watterson_per_unit_zero)

# Plotea log var +1

# El histograma tiene mejor pinta!

model1  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

Vemos que la distribución de residuos y Q-Q plot no mejora, así que pruebo con la delta normalizada. 

##### Normalized delta.

```{r}
model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_normalized_watterson_zero_k10"
hist(dataframe$delta_watterson_per_unit_normalized_zero)

model1  <- gam (delta_watterson_per_unit_normalized_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```
##### Transform normalized delta.

```{r}
model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_normalized_arcsine_watterson_zero_k10"

model1  <- gam (asin(delta_watterson_per_unit_normalized_zero) ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

## run model with varibales on normalized data

```{r}

model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_normalized_watterson_zero_informative_sites_recombination_rvis_interaction_k10"

model1  <- gam (delta_watterson_per_unit_normalized_zero ~
 # Covariables: las metemos como explicativas #  
                    s(informative_sites.x_scale, bs="tp", k=10) +
                    s(watterson_zero.x_scale,  bs="tp", k=10) +
                    ti(watterson_zero.x_scale, informative_sites.x_scale, bs=c("tp", "tp"), k=c(10,10))+
                    # Variables explicativas # 
                    s(recombination_rate_scale, bs="tp", k=10, m=2)+
                    ti(recombination_rate_scale, watterson_zero.x_scale,bs=c("tp", "tp"), k=c(10,10))+
                    #s(divergence_scale,  bs="tp", k=10)+
                    #s(GC_content_scale,  bs="tp", k=10)+
                    s(rvis_score_scale,  bs="tp", k=10)+
                    ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(10,10)),
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")


# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```



```{r}

# Check the names of the variables in the model 
getAllTerms(model1)




model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_no_re_k10"
model1  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(informative_sites.x, bs="tp", k=10) +
                    s(watterson_zero.x,  bs="tp", k=10) +
                    ti(watterson_zero.x, informative_sites.x, bs=c("tp", "tp"), k=c(10,10))+
                    # Variables explicativas # 
                    s(recombination_rate, bs="tp", k=10, m=2)+
                    s(divergence,  bs="tp", k=10)+
                    s(GC_content,  bs="tp", k=10)+
                    s(rvis_score,  bs="tp", k=10),
                    ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(10,10)),
                    # Dataframe
                    data=dataframe1,  
                    # Method and family
                    method="REML", family="gaussian")


# Mirar overdispersion!
overdisp_fun

# Dredge keeping initial diversity and informative sites as fixed factors.
options(na.action = "na.fail") # Require for dredge to run
rm(model1_dredge)
model1_dredge <- dredge(model1, beta = F, evaluate = T, extra = c("R^2", "adjR^2", rank= "AICc"),
                                            # Fix one of the variables
                                            fixed = c("s(watterson_zero.x_scale, bs = \"tp\", k = 5)")) 
options(na.action = "na.omit") # set back to default

model1_dredge
write.table(model1_dredge, file=paste0(wd_output, model_name, "_dedgre.txt"), sep="\t", dec=",", quote=F, row.names = F)
save(model1_dredge,file=paste0(wd_output, model_name, "_dedgre.RData"))

rm(model1)

# Corro el mejor modelo
### Tengo que modificarlo para cada caso!!

model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_no_re_best_model"
model2  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    #s(informative_sites.x_scale, bs="tp", k=5) +
                    s(watterson_zero.x_scale,  bs="tp", k=5) +
                    ti(watterson_zero.x_scale, informative_sites.x_scale, bs=c("tp", "tp"), k=c(5,5))+
                    # Variables explicativas # 
                    #s(recombination_rate_scale, bs="tp", k=5, m=2)+
                    s(divergence_scale,  bs="tp", k=5)+
                    s(GC_content_scale,  bs="tp", k=5),
                    #s(rvis_score_scale,  bs="tp", k=5)+
                    #ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(5,5)),
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")


# Save the model
save(model2, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model2)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model2))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model2)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model2)
dev.off()

rm(model2)

```


# ----

# Mas codigo

```{r}
# Check the names of the variables in the model 
getAllTerms(modG_CDS_c_ll_ki_c_ll_no_watterson_re)

# Dredge manteniendo como fijo que 
options(na.action = "na.fail") # Require for dredge to run
rm(modI_CDS_c_ll_ki_c_ll_no_watterson)
dredge(modI_CDS_c_ll_ki_c_ll_no_watterson)


modI_CDS_c_ll_ki_c_ll_no_watterson_dregde <- MuMIn::dredge(global.model=mod1_c_ll_ki_n013_c_ll_no_n008, beta = "none", evaluate = T, rank = AICc, 
                                            # Fix the weeks and random effects
                                            fixed = c("s(informative_sites.x, bs = \"tp\", k = 5)",
                                                      "s(watterson_ave_corrected.x, bs = \"tp\", k = 5)", 
                                                      "ti(watterson_ave_corrected.x, informative_sites.x, bs = c(\"tp\", \"tp\"), k = c(5, 5))"))

dredge(test, beta = "none", evaluate = T, rank = AICc)

options(na.action = "na.omit") # set back to default
modI_6_Inc_female_VR_i_Abn_dredge

# save.image("F:/Ruben/Datos_nuevos/06_Descrip_Analyses/00_analyses/GAM/Residuals/Both_6/Both_6_female/Analyses/Inc/env_modI_Inc_female_VR_i_Abn.RData")
save.image("C:/Users/ruben/Both_6/Both_6_female/Analyses/Inc/env_modI_Inc_female_VR_i_Abn.RData")
save(modI_6_Inc_female_VR_i_Abn_dredge, 
     # file="F:/Ruben/Datos_nuevos/06_Descrip_Analyses/00_analyses/GAM/Residuals/Both_6/Both_6_female/Analyses/Inc/dredge_Inc_female_VR_i_Abn.RData")
     file="C:/Users/ruben/Both_6/Both_6_female/Analyses/Inc/dredge_Inc_female_VR_i_Abn.RData")
####_####

```

## GAM

El artículo 
```{r}

#### Modelo más complejo ####
# Voy a lanzar el modelo más complejo, porque luego podría hacer la función dredge, y me fabrica todos los modelos más simples a partir de este. 
#variables categóricas, sin más. 
#s() variables sencillas
#s(bs="tp") # probablemente el tuyo
#s(k=) # Cuanto mas mejor. pero para probar empieza con valores bajos (e.g. 5). Por defecto son 10
#s(m=2 o m=1) # Si no usas random no necesitas esto, lo explica en el paper. 
#ti() # para las interactions (se podría poner solo te() y el programa te sacaría la interacción, pero si se pone ti es mas limpio, te saca cada una por separado y luego la interacción)

# Características de mi modelo:
# 1. Voy a incluir como variables explicativas que son covariables a mi variable respuesta y que quiero que siempre estén en el modelo, las siguientes:
# a. Number of informative sites (suma de los informative sites en ambas poblaciones).
# b. Diversidad inicial.
# c. Interacción de ambas.
# 2. Variables explicatives per se:
# a. Recombinación
# b. Divergencia
# c. GC content
# d. Feature

# https://mfasiolo.github.io/mgcViz/articles/mgcviz.html
mod_all_var <- gam (delta_watterson_per_unit_zero ~
                      s(recombination_rate,by=as.factor(feature), bs="tp"),
data=c_ll_ki_n013_diversity_c_ll_no_n008_diversity, method="REML", family="gaussian")

                    +
                      ## Terminos que siempre quiero que vayan porque son covariable de mi variable explicativa ##
                ti(recombination_rate, bs = "tp"),
                    ti(watterson_ave_corrected.x, bs="tp"),
                                    ti(watterson_ave_corrected.x, bs="tp", k=5)+
                                    ti(informative_sites.x+informative_sites.y, bs="tp", k=5)+
                                    ti(watterson_ave_corrected.x *(informative_sites.x+informative_sites.y), bs="tp", k=5)+
                                    feature +
                                    region +
                                    chr +
                                
                                    data=c_ll_ki_n013_diversity_c_ll_no_n008_diversity, method="REML", family="gaussian")

mod_all_var <- getViz(mod_all_var)     
print(plot(mod_all_var, allTerms = TRUE), pages = 1)
gratia::draw(mod_all_var)
summary(mod_all_var)
plot.gam(mod_all_var)

save(mod_all_var, 
     file="/Users/marialucenaperez/mod_all_var1.RData")
load("/Users/marialucenaperez/mod_all_var1.RData", .GlobalEnv)


saveRDS(mod_all_var, "/Users/marialucenaperez/model.rds")
my_model <- readRDS("/Users/marialucenaperez/model.rds")
# Check the names of the variables in the model 
getAllTerms(my_model)

# Dredge manteniendo como fijo que 
options(na.action = "na.fail") # Require for dredge to run
rm(modI_6_Inc_female_VR_i_Abn_dredge)
modI_6_Inc_female_VR_i_Abn_dredge <- dredge(modI_6_Inc_female_VR_i_Abn, beta = F, evaluate = T, rank = AICc, 
                                            # Fix the weeks and random effects
                                            # fixed = c("s(Weeks, by = Pop_uo, bs = \"cc\", k = 8, m = 2)",
                                            fixed = c("s(Pop_uo, bs = \"re\", k = length(unique(db_analyse_Inc_female$Pop_uo)))",
                                                      "s(Pop_uo, bs = \"re\", by = Spp_uo)")) 
options(na.action = "na.omit") # set back to default
modI_6_Inc_female_VR_i_Abn_dredge

# save.image("F:/Ruben/Datos_nuevos/06_Descrip_Analyses/00_analyses/GAM/Residuals/Both_6/Both_6_female/Analyses/Inc/env_modI_Inc_female_VR_i_Abn.RData")
save.image("C:/Users/ruben/Both_6/Both_6_female/Analyses/Inc/env_modI_Inc_female_VR_i_Abn.RData")
save(modI_6_Inc_female_VR_i_Abn_dredge, 
     # file="F:/Ruben/Datos_nuevos/06_Descrip_Analyses/00_analyses/GAM/Residuals/Both_6/Both_6_female/Analyses/Inc/dredge_Inc_female_VR_i_Abn.RData")
     file="C:/Users/ruben/Both_6/Both_6_female/Analyses/Inc/dredge_Inc_female_VR_i_Abn.RData")
####_####
saveRDS(mod, "mymodel.rds")
# # get models
# # https://sites.google.com/site/rforfishandwildlifegrads/home/mumin_usage_examples
# lowest_AIC <- min(modI_6_Inc_female_VR_i_Abn_dredge$AICc)
# library(dplyr)
# dredge_models <- as.data.frame(modI_6_Inc_female_VR_i_Abn_dredge)
# col_weeks <- which(names(dredge_models) %in% names(dredge_models)[grep("Weeks", names(dredge_models))])
# if(dredge_models$AICc[1]==lowest_AIC){
#   ss_dredge_models <- dredge_models %>% 
#     filter(AICc<=(lowest_AIC+4)) 
#   ss_dredge_models <- ss_dredge_models %>% 
#     filter( !(ss_dredge_models[,col_weeks[1]]=="+" & is.na(ss_dredge_models[,col_weeks[2]])) ) %>%   
#     filter( !(ss_dredge_models[,col_weeks[2]]=="+" & is.na(ss_dredge_models[,col_weeks[1]])) )
# }
# ss_dredge_models
# 
# colnames(ss_dredge_models) <- c("Abn_lag_6_female",
#                                 "phiB_6_female",
#                                 "phiNB_6_female",
#                                 "psiBNB_6_female",
#                                 "psiNBB_6_female",
#                                 "Weeks_1",
#                                 "Weeks_2",
#                                 "psiNBB_6_female",
#                                 "Weeks_1",
#                                 )
# 
# top_model <- get.models(GTmodel_dredge, subset = 1)[[1]]
# top_model



```
