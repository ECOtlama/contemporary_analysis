---
title: "13.Diversity_lost_modelling"
output: html_document
---

15/09/2019
We are going to explore different HGAM to try to explain the differences in changes in diversity after a bottleneck.
Models are pretty complex, so we will start by trying to explain the accumulation of diversity in CDS.

I could also run my model in the server, therefore I create a folder. 
```{bash}
mkdir /home/mlucena/diversity_loss_modeling
scp -p /Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/ANGSD/sfs/pop_comparison/*diversity.txt  mlucena@genomics-b.ebd.csic.es:/home/mlucena/diversity_loss_modeling
```

Script de R que puedo correr en local o en el servidor. 

## Library load

```{r}
library(viridis)
library(ggplot2); theme_set(theme_minimal())
library(tidyr)
library(plyr)
library(dplyr)
library(data.table)
library(mgcv)
library(MuMIn) #--> Not available in the server. 
library(mgcViz) #--> Not available in the server. 
library(gratia) #--> Not available in the server. 
library (Hmisc)
```

## Data load 

```{r}
########################
### Server ###
# all_comparisons_diversity_bootleneck_vs_non_bootleneck <- read.table ("/home/mlucena/diversity_loss_modeling/all_comparisons_diversity_bootleneck_vs_non_bootleneck.txt", row.names = NULL, sep =";", dec=",", header=T, stringsAsFactors = F, comment.char="")
#####################
### Local ###
wd <- "/Users/marialucenaperez/Documents/WG_lynx_diversity_per_unit/comparison_among_pops/"
wd_output <- "/Users/marialucenaperez/Owncloud/publico/PhD/WG_diversity/GAM_models/"
all_comparisons_diversity_bootleneck_vs_non_bootleneck <- read.table (paste0 (wd, "all_comparisons_diversity_bootleneck_vs_non_bootleneck.txt"), row.names = NULL, sep =";", dec=",", header=T, comment.char="", na.strings = c("NA", "na"))
##########################
```

## Sanity check

```{r}
# Antes de seleccionar las variables, vamos a hacer algunas comprobaciones

# 1. ¿Cómo se relacionan los informative sites de ambas poblaciones?
ggplot (head (all_comparisons_diversity_bootleneck_vs_non_bootleneck, n=5000), aes(informative_sites.x, informative_sites.y)) +
  geom_point() +
  ggsave(paste0(wd_output, "informative_sites_lm.pdf"))
# La relación es completamente lineal, así que podemos usar como covariables (variable respuesta) los de cualquiera de la poblacion implicada en esa comparación (.x o .y) indistintamente. 
 
# 2. Should I scale my variables?
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$watterson_zero.x)
# 0.02426801
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$informative_sites.x)
# 544166
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$rvis_score, na.rm=TRUE)
# 10.78656
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$recombination_rate, na.rm=TRUE)
# 70.90716
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$divergence, na.rm=TRUE)
# 0.5
max(all_comparisons_diversity_bootleneck_vs_non_bootleneck$GC_content)
# 0.876033

# Yes! The magnitude is completely different, so it makes sense to scale then to be able to interpret our results; i.e. a change of one unit (whatever a unit is) of this variable, have this effect. 

# Now I will check value distribution of the recombination.
hist(all_comparisons_diversity_bootleneck_vs_non_bootleneck$recombination_rate)

```

## Modif my data to fit the model

```{r}
# Como veo hay muy pocos valores por encima de 20, y creo que esto puede estar falseando mis datos, ya que:
# 1. Afecta al escalado agrupando valores de baja recombinación que realmente deberían de estar separados.
# 2. Esto puede hacer que los efectos de valores bajos de recombinación queden ocultos.
# 3. Los hotspot de recombinación NO estan conservados entre especies, y por tanto no tendría sentido mantenerlo.

all_comparisons_diversity_bootleneck_vs_non_bootleneck <- all_comparisons_diversity_bootleneck_vs_non_bootleneck %>% 
  # Filtramos los recombination hotspot.
  filter (recombination_rate<10) #%>% 
  # Nos quedamos sólo con los que tienen ganancia de divesidad
  #filter (delta_watterson_per_unit_zero<0)

nrow(all_comparisons_diversity_bootleneck_vs_non_bootleneck)
# 962955

# Ahora escalamos las variables respuestas
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale <- all_comparisons_diversity_bootleneck_vs_non_bootleneck %>% 
  mutate (watterson_zero.x_scale=scale (watterson_zero.x)) %>% 
  mutate (pairwise_zero.x_scale=scale (pairwise_zero.x)) %>% 
  mutate (informative_sites.x_scale=scale (informative_sites.x)) %>% 
  mutate (recombination_rate_scale=scale (recombination_rate)) %>% 
  mutate (recombination_rate_log=log (recombination_rate)) %>% 
  mutate (divergence_scale=scale (divergence)) %>% 
  mutate (GC_content_scale=scale (GC_content)) %>% 
  mutate (rvis_score_scale=scale (rvis_score)) %>% 
  mutate (delta_watterson_per_unit_zero_scale=scale(delta_watterson_per_unit_zero))

# Otra manera de escalar sería la siguiente
# rescale <- function (x) { (x - mean (x)) / sd (x) }
# for (i in ncol (data)) {
#   data[, i] <-  rescale (data[, i])
# }

# I also have to remove the order of the random factors I will be using. 
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$feature <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$feature , ordered = FALSE )
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$chr <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$chr , ordered = FALSE )
all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$region <- factor( all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale$region , ordered = FALSE )

```

## Subset my data for different models
## - Select CDS 
I will use only CDS to try to explain changes in diversity in this particular category. 

### Kirov-Norway
```{r}
CDS_c_ll_ki_c_ll_no_dataframe <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale %>% 
  dplyr::filter (feature=="CDS") %>% 
  dplyr::filter (chr!="chrX") %>% 
  dplyr::filter (comparison=="Kirov-Norway") %>% 
  select (comparison,
          scaffold,
          start_cero_based,
          delta_watterson_per_unit_zero_scale,
          delta_watterson_per_unit_zero, 
          #delta_pairwise_per_unit_zero,
          informative_sites.x_scale,
          watterson_zero.x_scale, 
          #pairwise_zero.x_scale, 
          recombination_rate_scale,
          divergence_scale, 
          GC_content_scale,  
          rvis_score_scale,
          region,
          chr, 
          informative_sites.x,
          watterson_zero.x, 
          pairwise_zero.x,
          recombination_rate,
          recombination_rate_log,
          divergence, 
          GC_content,  
          rvis_score,
          region,
          chr)

# Name is mod I because each one of the variable could have a different function and smother depending on the random factor  (check paper)
# Remove cases with no data. 
CDS_c_ll_ki_c_ll_no_dataframe <- CDS_c_ll_ki_c_ll_no_dataframe[complete.cases(CDS_c_ll_ki_c_ll_no_dataframe), ]
nrow(CDS_c_ll_ki_c_ll_no_dataframe)
# n=29950 --> Kirov-Norway
# n=29950 --> Kirov-Ne_Poland
# n=28941 --> Andujar-Doñana

## Submuestreo de las celdas con 0

CDS_c_ll_ki_c_ll_no_dataframe_only0 <- filter(CDS_c_ll_ki_c_ll_no_dataframe, delta_watterson_per_unit_zero==0) %>% sample_n(., 500, replace=F)


CDS_c_ll_ki_c_ll_no_dataframe_no0 <- filter(CDS_c_ll_ki_c_ll_no_dataframe, delta_watterson_per_unit_zero!=0)

CDS_c_ll_ki_c_ll_no_dataframe2 <- rbind(CDS_c_ll_ki_c_ll_no_dataframe_only0, CDS_c_ll_ki_c_ll_no_dataframe_no0)

dataframe=CDS_c_ll_ki_c_ll_no_dataframe2
 

hist(CDS_c_ll_ki_c_ll_no_dataframe$delta_watterson_per_unit_zero)
hist(CDS_c_ll_ki_c_ll_no_dataframe1$delta_watterson_per_unit_zero)
hist(CDS_c_ll_ki_c_ll_no_dataframe2$delta_watterson_per_unit_zero)

```

### Andujar-Doñana
```{r}
CDS_c_lp_sm_c_lp_do_dataframe <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale %>% 
  dplyr::filter (feature=="CDS") %>% 
  dplyr::filter (chr!="chrX") %>% 
  dplyr::filter (comparison=="Andujar-Donana") %>% 
  select (delta_watterson_per_unit_zero_scale,
          delta_watterson_per_unit_zero, 
          #delta_pairwise_per_unit_zero,
          informative_sites.x_scale,
          watterson_zero.x_scale, 
          #pairwise_zero.x_scale, 
          recombination_rate_scale,
          divergence_scale, 
          GC_content_scale,  
          rvis_score_scale,
          region,
          chr, 
          informative_sites.x,
          watterson_zero.x, 
          pairwise_zero.x,
          recombination_rate,
          recombination_rate_log,
          divergence, 
          GC_content,  
          rvis_score,
          region,
          chr)

# Name is mod I because each one of the variable could have a different function and smother depending on the random factor  (check paper)
# Remove cases with no data. 
CDS_c_lp_sm_c_lp_do_dataframe <- CDS_c_lp_sm_c_lp_do_dataframe[complete.cases(CDS_c_lp_sm_c_lp_do_dataframe), ]
nrow(CDS_c_lp_sm_c_lp_do_dataframe)
# n=29950 --> Kirov-Norway
# n=29950 --> Kirov-Ne_Poland
# n=28941 --> Andujar-Doñana

#dataframe=CDS_c_ll_ki_c_ll_no_dataframe 
#dataframe=CDS_c_ll_ki_c_ll_po_dataframe
dataframe=CDS_c_lp_sm_c_lp_do_dataframe

```

### Gplot relationships

```{r}
Pop_comparison="c_lp_sm_c_lp_do"

## Initial diversity
ggplot (data=dataframe, aes (watterson_zero.x, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_watterson_delta_watterson.pdf"))


ggplot (data=dataframe, aes (watterson_zero.x, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_watterson_delta_watterson_by_chr.pdf"))



## Recombination
ggplot (data=dataframe, aes (recombination_rate, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_recombination_delta_watterson.pdf"))


ggplot (data=dataframe, aes (recombination_rate, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_recombination_delta_watterson_by_chr.pdf"))




## Divergence
ggplot (data=dataframe, aes (divergence, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_divergence_delta_watterson.pdf"))


ggplot (data=dataframe, aes (divergence, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_divergence_delta_watterson_by_chr.pdf"))



## rvis
ggplot (data=dataframe, aes (rvis_score, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_rvis_delta_watterson.pdf"))


ggplot (data=dataframe, aes (rvis_score, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_rvis_delta_watterson_by_chr.pdf"))



## GC content
ggplot (data=dataframe, aes (GC_content, delta_watterson_per_unit_zero)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_GC_delta_watterson.pdf"))


ggplot (data=dataframe, aes (GC_content, delta_watterson_per_unit_zero, colour=chr)) +
  geom_smooth() +
  theme(legend.position = "top") +
  ggsave(paste0(wd_output, "LOESS_smoothers/",Pop_comparison,"_GC_delta_watterson_by_chr.pdf"))

```




### Nule model selection

```{r}
# First I will run an histogram of my response variable.

hist((dataframe$delta_watterson_per_unit_zero))
# como vemos es una normal con un pico muy grande en 0. Esto corresponde a la familia gaussian. Además he probado a modelar con otras familias y no puedo porque tiene valores negativos. 
m0a<-gam(delta_watterson_per_unit_zero ~ 1, data = dataframe,  family = gaussian)
AICc(m0a)
# -351521.4
```

#### Check overdispersion
```{r}
overdisp_fun <- function(model) {
  rdf <- model$df.res
  rp <- resid(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  c(chisq=Pearson.chisq,OverdispersionParameter=prat,rdf=rdf,p=pval)
}

overdisp_fun(m0a)
#chisq OverdispersionParameter                     rdf                       p 
#           8.994523e-03            3.107990e-07            2.894000e+04            1.000000e+00 
sum(residuals(m0a, type = "deviance")^2)/m0a$df.residual

# Overdispersion (cu?nto m?s alejado est? de 0 el valor mayor sobredispersi?n)
# 3.10799e-07

ovd_a <- resid(m0a, type = "pearson")
(overdispersion <- sum(ovd_a^2) / (m0a$df.res)) # 3.10799e-07

# Si estuviese eligiendo familia me quedaría con la que menor sobredispersión tuviese, pero como no es el caso lo calculo para luego compararlo con mis modelos ajustados. 

# De nuevo vemos que el modelo con la familia nb es el que menos overdispersi?n tiene

rm(m0a,ovd_a)

```

### Correlation between vars.

Aunque yo ya la había calculado, voy a repetirlo, porque hay algunos cambios, como que la recombinación solo llega a 10, y las variables que uso. 

```{r}
# Relacion recombinación-divergencia. 
ggplot (dataframe, aes(recombination_rate_scale, divergence_scale)) +
  geom_smooth()


cormatrix <- rcorr(as.matrix(dataframe %>% dplyr::select(-region, -chr))) 
cormatrix
cordata = melt(cormatrix$r)
correlation <- ggplot(cordata, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile() + xlab("") + ylab("")
ggsave(paste (wd_output, "correlation_plot.tiff", sep = "/"),
       correlation, device = NULL,
       scale = 1, width = 20, height = 10, units = c("in"),
       dpi = 600)


cor(dataframe %>% dplyr::select(-region, -chr), method = "spearman")
Spearman <- as.data.frame(cor(dataframe %>% dplyr::select(-region, -chr), method = "spearman"))
write.table(Spearman,paste (wd_output, "Spearman.txt"),quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)

# Nota Isa: En esa tabla que acabas de guardar miras las variables correlacionadas, aqu? debes decidir
# el valor de rho |r| a partir del cu?l descartas variables, puedes ser flexible hasta 0.7
# aunque ultimente los papers est?n siendo m?s estrictos bajando hasta el 0.5 e incluso el 0.4


# Nota mía: He comprobado que ninguna de mis variables están correlacionadas a más de 0.4, por tanto puedo incluirlas todas. 

rm(cormatrix, correlation, Spearman)

# When you have you correlated variables then:

# Nota María: Esto no lo tengo que hacer porque no están correlacionadas. 
## Fit models to know which variable you need to delete from the dataset
## eg: your correlated variables are var1 with var2 & var4 with var7
# 
# m0a<-gam(sbalphy ~ s(var1), offset = (log (effort)), data = data,  family = nb)
# m0b<-gam(sbalphy ~ s(var2), offset = (log (effort)), data = data,  family = nb)
# 
# AIC(m0a); AIC(m0b)
# [m0a] 864.3353
# [m0b] 837.2231
# 
# # So we delete var1
# 
# m0a<-gam(sbalphy ~ s(var4), offset = (log (effort)), data = data,  family = nb)
# m0b<-gam(sbalphy ~ s(var7), offset = (log (effort)), data = data,  family = nb)
# 
# AIC(m0a); AIC(m0b)
# [m0a] 871.046
# [m0b] 870.3191

```

### FIT GAMs 
#### Simple model 

Voy a hacer una especie de diario / script de los pasos que voy dando. El diario se puede encontrar en el día 4 de Enero de 2020. 

Lo primero que voy a correr es un modelo en el que la delta solo dependa de la diversidad inicial, para ver cómo se comportan los residuos. 

```{r}
# Hago un subset de mi data frame para que corra más rápido. 
# dataframe1 <- sample_n(dataframe, 1000)
model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_watterson_zero_k10"
model1  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp") ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

gam.check(model1)

qq.gam(model1)
rqgam.check(model1)
install.packages("dsm")
```

#### Model with varibales 

```{r}

model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_watterson_zero_informative_sites_recombination_rvis_GC_divergence_interaction_rvis_recomb_k10_offset_informative_sites"

model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_watterson_zero_informative_sites_recombination_rvis_GC_divergence_interaction_rvis_recomb_k10_offset_informative_sites"

model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_watterson_zero_informative_sites_recombination_rvis_GC_divergence_interaction_rvis_recomb_k10_offset_informative_sites_zero_truncated"

model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_watterson_zero_informative_sites_recombination_rvis_GC_divergence_offset_informative_sites_zero_truncated"

model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_watterson_zero_informative_sites_recombination_rvis_GC_divergence_offset_informative_sites_zero_based_scaffold_start_cero_based"

model2  <- gam (delta_watterson_per_unit_zero ~
 # Covariables: las metemos como explicativas #  
                    #s(informative_sites.x_scale, bs="tp", k=10) +
                    s(watterson_zero.x_scale, bs="tp", k=10) +
                    # Variables explicativas # 
                    s(recombination_rate_scale, bs="tp",  k=10)+
                    s(divergence_scale, bs="tp", k=10)+
                    s(GC_content_scale, bs="tp", k=10)+
                    s(rvis_score_scale, bs="tp", k=10)+
                    s(start_cero_based, by=scaffold, k=5, bs="tp", m=2)+
                    s(scaffold, bs="re", k=6),
                    #ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(10,10)),
                    offset = informative_sites.x_scale,             
                    # Dataframe
                   data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

gam.check(model2)
# Save the model
save(model2, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model2)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model2))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model2)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model2)
dev.off()

```
Lo que comprobamos es que los residuos parecen tener problemas de tendencia y de dispersión. 

Por tanto voy a probar a transformar mi variable respuesta a ver si mejora.
Las transformaciones que se me ocurren probar son varias:

Lo primero que voy a hacer es probar a quitar los ceros. Los ceros son unidades que ni ganan ni pierden diversidad y por tanto no aportan tanto. 
##### Remove 0 from response variable. 

Lo que he hecho ha sido añadir como variables delta_watterson_per_unit_normalized_zero, y como esta variable coge valor NA cuando la otra es cero, así ya la elimino. 
```{r}
model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_no0_watterson_zero_k10"
hist(dataframe$delta_watterson_per_unit_zero)
# El histograma tiene mejor pinta!

model1  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

Vemos que la distribución de residuos y Q-Q plot no mejora, así que pruebo con la delta normalizada. 

##### Normalized delta.

```{r}
model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_normalized_watterson_zero_k10"
hist(dataframe$delta_watterson_per_unit_normalized_zero)

model1  <- gam (delta_watterson_per_unit_normalized_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```
##### Transform normalized delta.

```{r}
model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_normalized_arcsine_watterson_zero_k10"

model1  <- gam (asin(delta_watterson_per_unit_normalized_zero) ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

#### Model with varibales on normalized data

```{r}

model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_normalized_watterson_zero_informative_sites_recombination_rvis_interaction_k10"

model1  <- gam (delta_watterson_per_unit_normalized_zero ~
 # Covariables: las metemos como explicativas #  
                    s(informative_sites.x_scale, bs="tp", k=10) +
                    s(watterson_zero.x_scale,  bs="tp", k=10) +
                    ti(watterson_zero.x_scale, informative_sites.x_scale, bs=c("tp", "tp"), k=c(10,10))+
                    # Variables explicativas # 
                    s(recombination_rate_scale, bs="tp", k=10, m=2)+
                    ti(recombination_rate_scale, watterson_zero.x_scale,bs=c("tp", "tp"), k=c(10,10))+
                    #s(divergence_scale,  bs="tp", k=10)+
                    #s(GC_content_scale,  bs="tp", k=10)+
                    s(rvis_score_scale,  bs="tp", k=10)+
                    ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(10,10)),
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")


# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```


# Norway and Kirov

```{r}
CDS_c_ll_ki_c_ll_no_dataframe_complete <- all_comparisons_diversity_bootleneck_vs_non_bootleneck_scale %>% 
  dplyr::filter (feature=="CDS") %>% 
  dplyr::filter(comparison=="Kirov-Norway") %>% 
  select (delta_watterson_per_unit_zero_scale,
          delta_watterson_per_unit_zero, 
          delta_pairwise_per_unit_zero,
          delta_watterson_per_unit_normalized_zero, 
          delta_pairwise_per_unit_normalized_zero,
          informative_sites.x_scale,
          watterson_zero.x_scale, 
          pairwise_zero.x_scale, 
          recombination_rate_scale,
          divergence_scale, 
          GC_content_scale,  
          rvis_score_scale,
          region,
          chr, 
          informative_sites.x,
          watterson_zero.x, 
          pairwise_zero.x,
          recombination_rate,
          recombination_rate_log,
          divergence, 
          GC_content,  
          rvis_score,
          region,
          chr)

# Name is mod I because each one of the variable could have a different function and smother depending on the random factor  (check paper)
# Remove cases with no data. 
CDS_c_ll_ki_c_ll_no_dataframe <- CDS_c_ll_ki_c_ll_no_dataframe_complete[complete.cases(CDS_c_ll_ki_c_ll_no_dataframe_complete), ]
nrow(CDS_c_ll_ki_c_ll_no_dataframe)
# n=29950 --> Kirov-Norway
# n=29950 --> Kirov-Ne_Poland
# n=28941 --> Andujar-Doñana

#dataframe=CDS_c_ll_ki_c_ll_no_dataframe 
#dataframe=CDS_c_ll_ki_c_ll_po_dataframe
dataframe=CDS_c_ll_ki_c_ll_no_dataframe

```


### FIT GAMs 
#### Simple model 

Voy a hacer una especie de diario / script de los pasos que voy dando. El diario se puede encontrar en el día 4 de Enero de 2020. 

Lo primero que voy a correr es un modelo en el que la delta solo dependa de la diversidad inicial, para ver cómo se comportan los residuos. 

```{r}
# Hago un subset de mi data frame para que corra más rápido. 
#dataframe1 <- sample_n(dataframe, 1000)

model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_watterson_zero_k10"
model1  <- gam (log(delta_watterson_per_unit_zero +1) ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

Lo que comprobamos es que los residuos parecen tener problemas de tendencia y de dispersión. 

Por tanto voy a probar a transformar mi variable respuesta a ver si mejora.
Las transformaciones que se me ocurren probar son varias:

Lo primero que voy a hacer es probar a quitar los ceros. Los ceros son unidades que ni ganan ni pierden diversidad y por tanto no aportan tanto. 
##### Remove 0 from response variable. 

Lo que he hecho ha sido añadir como variables delta_watterson_per_unit_normalized_zero, y como esta variable coge valor NA cuando la otra es cero, así ya la elimino. 
```{r}
model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_no0_watterson_zero_k10"
hist(dataframe$delta_watterson_per_unit_zero)

# Plotea log var +1

# El histograma tiene mejor pinta!

model1  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

Vemos que la distribución de residuos y Q-Q plot no mejora, así que pruebo con la delta normalizada. 

##### Normalized delta.

```{r}
model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_normalized_watterson_zero_k10"
hist(dataframe$delta_watterson_per_unit_normalized_zero)

model1  <- gam (delta_watterson_per_unit_normalized_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```
##### Transform normalized delta.

```{r}
model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_normalized_arcsine_watterson_zero_k10"

model1  <- gam (asin(delta_watterson_per_unit_normalized_zero) ~
                    # Covariables: las metemos como explicativas #  
                    s(watterson_zero.x,  bs="tp", k=10) ,
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")

# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```

## run model with varibales on normalized data

```{r}

model_name <- "mod_CDS_c_ll_ki_c_ll_no_delta_watterson_normalized_watterson_zero_informative_sites_recombination_rvis_interaction_k10"

model1  <- gam (delta_watterson_per_unit_normalized_zero ~
 # Covariables: las metemos como explicativas #  
                    s(informative_sites.x_scale, bs="tp", k=10) +
                    s(watterson_zero.x_scale,  bs="tp", k=10) +
                    ti(watterson_zero.x_scale, informative_sites.x_scale, bs=c("tp", "tp"), k=c(10,10))+
                    # Variables explicativas # 
                    s(recombination_rate_scale, bs="tp", k=10, m=2)+
                    ti(recombination_rate_scale, watterson_zero.x_scale,bs=c("tp", "tp"), k=c(10,10))+
                    #s(divergence_scale,  bs="tp", k=10)+
                    #s(GC_content_scale,  bs="tp", k=10)+
                    s(rvis_score_scale,  bs="tp", k=10)+
                    ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(10,10)),
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")


# Save the model
save(model1, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model1)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model1))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model1)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model1)
dev.off()

```



```{r}

# Check the names of the variables in the model 
getAllTerms(model1)




model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_no_re_k10"
model1  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    s(informative_sites.x, bs="tp", k=10) +
                    s(watterson_zero.x,  bs="tp", k=10) +
                    ti(watterson_zero.x, informative_sites.x, bs=c("tp", "tp"), k=c(10,10))+
                    # Variables explicativas # 
                    s(recombination_rate, bs="tp", k=10, m=2)+
                    s(divergence,  bs="tp", k=10)+
                    s(GC_content,  bs="tp", k=10)+
                    s(rvis_score,  bs="tp", k=10),
                    ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(10,10)),
                    # Dataframe
                    data=dataframe1,  
                    # Method and family
                    method="REML", family="gaussian")


# Mirar overdispersion!
overdisp_fun

# Dredge keeping initial diversity and informative sites as fixed factors.
options(na.action = "na.fail") # Require for dredge to run
rm(model1_dredge)
model1_dredge <- dredge(model1, beta = F, evaluate = T, extra = c("R^2", "adjR^2", rank= "AICc"),
                                            # Fix one of the variables
                                            fixed = c("s(watterson_zero.x_scale, bs = \"tp\", k = 5)")) 
options(na.action = "na.omit") # set back to default

model1_dredge
write.table(model1_dredge, file=paste0(wd_output, model_name, "_dedgre.txt"), sep="\t", dec=",", quote=F, row.names = F)
save(model1_dredge,file=paste0(wd_output, model_name, "_dedgre.RData"))

rm(model1)

# Corro el mejor modelo
### Tengo que modificarlo para cada caso!!

model_name <- "mod_CDS_c_lp_sm_c_lp_do_delta_watterson_no_re_best_model"
model2  <- gam (delta_watterson_per_unit_zero ~
                    # Covariables: las metemos como explicativas #  
                    #s(informative_sites.x_scale, bs="tp", k=5) +
                    s(watterson_zero.x_scale,  bs="tp", k=5) +
                    ti(watterson_zero.x_scale, informative_sites.x_scale, bs=c("tp", "tp"), k=c(5,5))+
                    # Variables explicativas # 
                    #s(recombination_rate_scale, bs="tp", k=5, m=2)+
                    s(divergence_scale,  bs="tp", k=5)+
                    s(GC_content_scale,  bs="tp", k=5),
                    #s(rvis_score_scale,  bs="tp", k=5)+
                    #ti(recombination_rate_scale, rvis_score_scale, bs=c("tp", "tp"), k=c(5,5)),
                    # Dataframe
                    data=dataframe,  
                    # Method and family
                    method="REML", family="gaussian")


# Save the model
save(model2, 
     file=paste0(wd_output,model_name))
#load(paste0(wd_output,model_name), .GlobalEnv)

# Summary
summary(model2)
sink(paste0(wd_output,model_name, ".txt"))
print(summary(model2))
sink()

# Plot the model
#https://www.r-bloggers.com/introducing-gratia/
pdf(paste0(wd_output, model_name, '.pdf'), 15, 15)
gratia::draw(model2)
dev.off()

# Sanity checks
pdf(paste0(wd_output, model_name, '_diagnosis.pdf'))
appraise(model2)
dev.off()

rm(model2)

```


# ----

# Mas codigo

```{r}
# Check the names of the variables in the model 
getAllTerms(modG_CDS_c_ll_ki_c_ll_no_watterson_re)

# Dredge manteniendo como fijo que 
options(na.action = "na.fail") # Require for dredge to run
rm(modI_CDS_c_ll_ki_c_ll_no_watterson)
dredge(modI_CDS_c_ll_ki_c_ll_no_watterson)


modI_CDS_c_ll_ki_c_ll_no_watterson_dregde <- MuMIn::dredge(global.model=mod1_c_ll_ki_n013_c_ll_no_n008, beta = "none", evaluate = T, rank = AICc, 
                                            # Fix the weeks and random effects
                                            fixed = c("s(informative_sites.x, bs = \"tp\", k = 5)",
                                                      "s(watterson_ave_corrected.x, bs = \"tp\", k = 5)", 
                                                      "ti(watterson_ave_corrected.x, informative_sites.x, bs = c(\"tp\", \"tp\"), k = c(5, 5))"))

dredge(test, beta = "none", evaluate = T, rank = AICc)

options(na.action = "na.omit") # set back to default
modI_6_Inc_female_VR_i_Abn_dredge

# save.image("F:/Ruben/Datos_nuevos/06_Descrip_Analyses/00_analyses/GAM/Residuals/Both_6/Both_6_female/Analyses/Inc/env_modI_Inc_female_VR_i_Abn.RData")
save.image("C:/Users/ruben/Both_6/Both_6_female/Analyses/Inc/env_modI_Inc_female_VR_i_Abn.RData")
save(modI_6_Inc_female_VR_i_Abn_dredge, 
     # file="F:/Ruben/Datos_nuevos/06_Descrip_Analyses/00_analyses/GAM/Residuals/Both_6/Both_6_female/Analyses/Inc/dredge_Inc_female_VR_i_Abn.RData")
     file="C:/Users/ruben/Both_6/Both_6_female/Analyses/Inc/dredge_Inc_female_VR_i_Abn.RData")
####_####

```

## GAM

El artículo 
```{r}

#### Modelo más complejo ####
# Voy a lanzar el modelo más complejo, porque luego podría hacer la función dredge, y me fabrica todos los modelos más simples a partir de este. 
#variables categóricas, sin más. 
#s() variables sencillas
#s(bs="tp") # probablemente el tuyo
#s(k=) # Cuanto mas mejor. pero para probar empieza con valores bajos (e.g. 5). Por defecto son 10
#s(m=2 o m=1) # Si no usas random no necesitas esto, lo explica en el paper. 
#ti() # para las interactions (se podría poner solo te() y el programa te sacaría la interacción, pero si se pone ti es mas limpio, te saca cada una por separado y luego la interacción)

# Características de mi modelo:
# 1. Voy a incluir como variables explicativas que son covariables a mi variable respuesta y que quiero que siempre estén en el modelo, las siguientes:
# a. Number of informative sites (suma de los informative sites en ambas poblaciones).
# b. Diversidad inicial.
# c. Interacción de ambas.
# 2. Variables explicatives per se:
# a. Recombinación
# b. Divergencia
# c. GC content
# d. Feature

# https://mfasiolo.github.io/mgcViz/articles/mgcviz.html
mod_all_var <- gam (delta_watterson_per_unit_zero ~
                      s(recombination_rate,by=as.factor(feature), bs="tp"),
data=c_ll_ki_n013_diversity_c_ll_no_n008_diversity, method="REML", family="gaussian")

                    +
                      ## Terminos que siempre quiero que vayan porque son covariable de mi variable explicativa ##
                ti(recombination_rate, bs = "tp"),
                    ti(watterson_ave_corrected.x, bs="tp"),
                                    ti(watterson_ave_corrected.x, bs="tp", k=5)+
                                    ti(informative_sites.x+informative_sites.y, bs="tp", k=5)+
                                    ti(watterson_ave_corrected.x *(informative_sites.x+informative_sites.y), bs="tp", k=5)+
                                    feature +
                                    region +
                                    chr +
                                
                                    data=c_ll_ki_n013_diversity_c_ll_no_n008_diversity, method="REML", family="gaussian")

mod_all_var <- getViz(mod_all_var)     
print(plot(mod_all_var, allTerms = TRUE), pages = 1)
gratia::draw(mod_all_var)
summary(mod_all_var)
plot.gam(mod_all_var)

save(mod_all_var, 
     file="/Users/marialucenaperez/mod_all_var1.RData")
load("/Users/marialucenaperez/mod_all_var1.RData", .GlobalEnv)


saveRDS(mod_all_var, "/Users/marialucenaperez/model.rds")
my_model <- readRDS("/Users/marialucenaperez/model.rds")
# Check the names of the variables in the model 
getAllTerms(my_model)

# Dredge manteniendo como fijo que 
options(na.action = "na.fail") # Require for dredge to run
rm(modI_6_Inc_female_VR_i_Abn_dredge)
modI_6_Inc_female_VR_i_Abn_dredge <- dredge(modI_6_Inc_female_VR_i_Abn, beta = F, evaluate = T, rank = AICc, 
                                            # Fix the weeks and random effects
                                            # fixed = c("s(Weeks, by = Pop_uo, bs = \"cc\", k = 8, m = 2)",
                                            fixed = c("s(Pop_uo, bs = \"re\", k = length(unique(db_analyse_Inc_female$Pop_uo)))",
                                                      "s(Pop_uo, bs = \"re\", by = Spp_uo)")) 
options(na.action = "na.omit") # set back to default
modI_6_Inc_female_VR_i_Abn_dredge

# save.image("F:/Ruben/Datos_nuevos/06_Descrip_Analyses/00_analyses/GAM/Residuals/Both_6/Both_6_female/Analyses/Inc/env_modI_Inc_female_VR_i_Abn.RData")
save.image("C:/Users/ruben/Both_6/Both_6_female/Analyses/Inc/env_modI_Inc_female_VR_i_Abn.RData")
save(modI_6_Inc_female_VR_i_Abn_dredge, 
     # file="F:/Ruben/Datos_nuevos/06_Descrip_Analyses/00_analyses/GAM/Residuals/Both_6/Both_6_female/Analyses/Inc/dredge_Inc_female_VR_i_Abn.RData")
     file="C:/Users/ruben/Both_6/Both_6_female/Analyses/Inc/dredge_Inc_female_VR_i_Abn.RData")
####_####
saveRDS(mod, "mymodel.rds")
# # get models
# # https://sites.google.com/site/rforfishandwildlifegrads/home/mumin_usage_examples
# lowest_AIC <- min(modI_6_Inc_female_VR_i_Abn_dredge$AICc)
# library(dplyr)
# dredge_models <- as.data.frame(modI_6_Inc_female_VR_i_Abn_dredge)
# col_weeks <- which(names(dredge_models) %in% names(dredge_models)[grep("Weeks", names(dredge_models))])
# if(dredge_models$AICc[1]==lowest_AIC){
#   ss_dredge_models <- dredge_models %>% 
#     filter(AICc<=(lowest_AIC+4)) 
#   ss_dredge_models <- ss_dredge_models %>% 
#     filter( !(ss_dredge_models[,col_weeks[1]]=="+" & is.na(ss_dredge_models[,col_weeks[2]])) ) %>%   
#     filter( !(ss_dredge_models[,col_weeks[2]]=="+" & is.na(ss_dredge_models[,col_weeks[1]])) )
# }
# ss_dredge_models
# 
# colnames(ss_dredge_models) <- c("Abn_lag_6_female",
#                                 "phiB_6_female",
#                                 "phiNB_6_female",
#                                 "psiBNB_6_female",
#                                 "psiNBB_6_female",
#                                 "Weeks_1",
#                                 "Weeks_2",
#                                 "psiNBB_6_female",
#                                 "Weeks_1",
#                                 )
# 
# top_model <- get.models(GTmodel_dredge, subset = 1)[[1]]
# top_model



```
